<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OpenCV入门学习-图像处理（一）</title>
    <url>/2025/02/06/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="绘图基础">绘图基础</h2>
<p>本文介绍如何使用OpenCV进行基础图形绘制，包括直线、椭圆、矩形、圆形和填充多边形的实现方法。所有代码均使用C++语法，并明确标注命名空间。</p>
<h3 id="核心数据结构">核心数据结构</h3>
<h4 id="cvpoint">cv::Point</h4>
<p>表示二维坐标系中的点，可通过以下两种方式定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Point pt1;</span><br><span class="line">pt<span class="number">1.</span>x = <span class="number">10</span>;  <span class="comment">// x 坐标</span></span><br><span class="line">pt<span class="number">1.</span>y = <span class="number">8</span>;   <span class="comment">// y 坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function">cv::Point <span class="title">pt2</span><span class="params">(<span class="number">10</span>, <span class="number">8</span>)</span></span>;  <span class="comment">// 直接初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="cvscalar">cv::Scalar</h4>
<p>表示四维向量，常用于表示 BGR 颜色值（仅使用前三个参数）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">Scalar</span>(blue, green, red);  <span class="comment">// BGR 颜色模型示例</span></span><br></pre></td></tr></table></figure>
<h3 id="基础绘图函数实现">基础绘图函数实现</h3>
<h4 id="创建画布">创建画布</h4>
<p>初始化 400x400 的黑色背景图像：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat atom_image = cv::Mat::<span class="built_in">zeros</span>(w, w, CV_8UC3);  <span class="comment">// 原子结构画布</span></span><br><span class="line">cv::Mat rook_image = cv::Mat::<span class="built_in">zeros</span>(w, w, CV_8UC3);  <span class="comment">// 城堡结构画布</span></span><br></pre></td></tr></table></figure>
<h4 id="绘制直线">绘制直线</h4>
<p>通过 <code>cv::line</code> 实现直线绘制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLine</span><span class="params">(cv::Mat img, cv::Point start, cv::Point end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> lineType = cv::LINE_8;</span><br><span class="line">    cv::<span class="built_in">line</span>(img, start, end, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness, lineType);</span><br><span class="line">    <span class="comment">// 参数说明：目标图像、起点、终点、颜色（黑色）、线宽、连线类型。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绘制椭圆">绘制椭圆</h4>
<p>使用 <code>cv::ellipse</code> 绘制旋转椭圆：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEllipse</span><span class="params">(cv::Mat img, <span class="type">double</span> angle)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">ellipse</span>(img, </span><br><span class="line">        cv::<span class="built_in">Point</span>(w/<span class="number">2</span>, w/<span class="number">2</span>),        <span class="comment">// 中心坐标</span></span><br><span class="line">        cv::<span class="built_in">Size</span>(w/<span class="number">4</span>, w/<span class="number">16</span>),        <span class="comment">// 长轴/短轴</span></span><br><span class="line">        angle,                      <span class="comment">// 旋转角度</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">360</span>,                     <span class="comment">// 起始/结束角度</span></span><br><span class="line">        cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>),      <span class="comment">// 蓝色椭圆</span></span><br><span class="line">        <span class="number">2</span>,                          <span class="comment">// 线宽</span></span><br><span class="line">        cv::LINE_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绘制实心圆">绘制实心圆</h4>
<p>通过 <code>cv::circle</code> 实现填充圆形：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFilledCircle</span><span class="params">(cv::Mat img, cv::Point center)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">circle</span>(img, </span><br><span class="line">        center,                     <span class="comment">// 圆心坐标</span></span><br><span class="line">        w/<span class="number">32</span>,                       <span class="comment">// 半径</span></span><br><span class="line">        cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),      <span class="comment">// 红色填充</span></span><br><span class="line">        cv::FILLED,                 <span class="comment">// 填充模式</span></span><br><span class="line">        cv::LINE_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绘制多边形">绘制多边形</h4>
<p>使用 <code>cv::fillPoly</code> 绘制自定义多边形：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPolygon</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line">    cv::Point rook_points[<span class="number">1</span>][<span class="number">20</span>] = &#123; <span class="comment">/* 顶点坐标定义 */</span> &#125;;</span><br><span class="line">    <span class="type">const</span> cv::Point* ppt[<span class="number">1</span>] = &#123; rook_points[<span class="number">0</span>] &#125;;</span><br><span class="line">    <span class="type">int</span> npt[] = &#123; <span class="number">20</span> &#125;;</span><br><span class="line">  </span><br><span class="line">    cv::<span class="built_in">fillPoly</span>(img, ppt, npt, <span class="number">1</span>, </span><br><span class="line">        cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>),  <span class="comment">// 白色填充</span></span><br><span class="line">        cv::LINE_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绘制矩形">绘制矩形</h4>
<p>直接调用 <code>cv::rectangle</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">rectangle</span>(rook_image,</span><br><span class="line">    cv::<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span>*w/<span class="number">8</span>),           <span class="comment">// 左上角坐标</span></span><br><span class="line">    cv::<span class="built_in">Point</span>(w, w),               <span class="comment">// 右下角坐标</span></span><br><span class="line">    cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),       <span class="comment">// 黄色填充</span></span><br><span class="line">    cv::FILLED,                    <span class="comment">// 填充模式</span></span><br><span class="line">    cv::LINE_8);</span><br></pre></td></tr></table></figure>
<h4 id="添加文本">添加文本</h4>
<p>文字标注需指定字体类型和左下角起点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">putText</span>(img,</span><br><span class="line">    <span class="string">&quot;OpenCV&quot;</span>,</span><br><span class="line">    cv::<span class="built_in">Point</span>(<span class="number">10</span>, <span class="number">500</span>),     <span class="comment">// 文字起点</span></span><br><span class="line">    cv::FONT_HERSHEY_SIMPLEX, <span class="comment">// 字体类型</span></span><br><span class="line">    <span class="number">4</span>,                      <span class="comment">// 字体缩放因子</span></span><br><span class="line">    cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), </span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    cv::LINE_AA);</span><br></pre></td></tr></table></figure>
<ul>
<li>字体优化：<code>cv::LINE_AA</code> 抗锯齿模式可提升文字显示质量</li>
</ul>
<h4 id="仿射变换">仿射变换</h4>
<p>数学描述 <span class="math display">\[
\begin{bmatrix}
x&#39; \\
y&#39;
\end{bmatrix} =
\begin{bmatrix}
a &amp; b \\
c &amp; d
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix} +
\begin{bmatrix}
k_1 \\
k_2
\end{bmatrix}\nonumber
\]</span> 通过 <code>cv::getAffineTransform</code> 和
<code>cv::warpAffine</code> 可实现图像的平移、旋转等操作</p>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w 400  <span class="comment">// 定义画布宽度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEllipse</span><span class="params">(Mat img, <span class="type">double</span> angle)</span></span>;         <span class="comment">// 声明绘制椭圆函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFilledCircle</span><span class="params">(Mat img, Point center)</span></span>;    <span class="comment">// 声明绘制实心圆函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPolygon</span><span class="params">(Mat img)</span></span>;                       <span class="comment">// 声明绘制多边形函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLine</span><span class="params">(Mat img, Point start, Point end)</span></span>;  <span class="comment">// 声明绘制直线函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> atom_window[] = <span class="string">&quot;Drawing 1: Atom&quot;</span>;  <span class="comment">// 定义原子图窗口名称</span></span><br><span class="line">    <span class="type">char</span> rook_window[] = <span class="string">&quot;Drawing 2: Rook&quot;</span>;  <span class="comment">// 定义城堡图窗口名称</span></span><br><span class="line"></span><br><span class="line">    Mat atom_image = Mat::<span class="built_in">zeros</span>(w, w, CV_8UC3);  <span class="comment">// 创建原子图，黑色背景</span></span><br><span class="line">    Mat rook_image = Mat::<span class="built_in">zeros</span>(w, w, CV_8UC3);  <span class="comment">// 创建城堡图，黑色背景</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyEllipse</span>(atom_image, <span class="number">90</span>);   <span class="comment">// 绘制旋转角度90°的椭圆</span></span><br><span class="line">    <span class="built_in">MyEllipse</span>(atom_image, <span class="number">0</span>);    <span class="comment">// 绘制旋转角度0°的椭圆</span></span><br><span class="line">    <span class="built_in">MyEllipse</span>(atom_image, <span class="number">45</span>);   <span class="comment">// 绘制旋转角度45°的椭圆</span></span><br><span class="line">    <span class="built_in">MyEllipse</span>(atom_image, <span class="number">-45</span>);  <span class="comment">// 绘制旋转角度-45°的椭圆</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyFilledCircle</span>(atom_image, <span class="built_in">Point</span>(w / <span class="number">2</span>, w / <span class="number">2</span>));  <span class="comment">// 绘制原子核实心圆</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyPolygon</span>(rook_image);  <span class="comment">// 绘制城堡主体多边形</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">rectangle</span>(rook_image,           <span class="comment">// 绘制城堡底座矩形</span></span><br><span class="line">              <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span> * w / <span class="number">8</span>),  <span class="comment">// 矩形左上角坐标</span></span><br><span class="line">              <span class="built_in">Point</span>(w, w),          <span class="comment">// 矩形右下角坐标</span></span><br><span class="line">              <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),  <span class="comment">// 矩形颜色（黄色）</span></span><br><span class="line">              FILLED,               <span class="comment">// 填充矩形</span></span><br><span class="line">              LINE_8);              <span class="comment">// 线型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLine</span>(rook_image, <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">15</span> * w / <span class="number">16</span>), <span class="built_in">Point</span>(w, <span class="number">15</span> * w / <span class="number">16</span>));      <span class="comment">// 绘制底部水平线</span></span><br><span class="line">    <span class="built_in">MyLine</span>(rook_image, <span class="built_in">Point</span>(w / <span class="number">4</span>, <span class="number">7</span> * w / <span class="number">8</span>), <span class="built_in">Point</span>(w / <span class="number">4</span>, w));          <span class="comment">// 绘制左侧竖线</span></span><br><span class="line">    <span class="built_in">MyLine</span>(rook_image, <span class="built_in">Point</span>(w / <span class="number">2</span>, <span class="number">7</span> * w / <span class="number">8</span>), <span class="built_in">Point</span>(w / <span class="number">2</span>, w));          <span class="comment">// 绘制中间竖线</span></span><br><span class="line">    <span class="built_in">MyLine</span>(rook_image, <span class="built_in">Point</span>(<span class="number">3</span> * w / <span class="number">4</span>, <span class="number">7</span> * w / <span class="number">8</span>), <span class="built_in">Point</span>(<span class="number">3</span> * w / <span class="number">4</span>, w));  <span class="comment">// 绘制右侧竖线</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(atom_window, atom_image);  <span class="comment">// 显示原子图</span></span><br><span class="line">    <span class="built_in">moveWindow</span>(atom_window, <span class="number">0</span>, <span class="number">200</span>);  <span class="comment">// 移动原子图窗口位置</span></span><br><span class="line">    <span class="built_in">imshow</span>(rook_window, rook_image);  <span class="comment">// 显示城堡图</span></span><br><span class="line">    <span class="built_in">moveWindow</span>(rook_window, w, <span class="number">200</span>);  <span class="comment">// 移动城堡图窗口位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);  <span class="comment">// 等待按键</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 程序结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEllipse</span><span class="params">(Mat img, <span class="type">double</span> angle)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> thickness = <span class="number">2</span>;  <span class="comment">// 线宽</span></span><br><span class="line">    <span class="type">int</span> lineType = <span class="number">8</span>;   <span class="comment">// 线型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ellipse</span>(img,                  <span class="comment">// 绘制椭圆</span></span><br><span class="line">            <span class="built_in">Point</span>(w / <span class="number">2</span>, w / <span class="number">2</span>),  <span class="comment">// 椭圆中心点</span></span><br><span class="line">            <span class="built_in">Size</span>(w / <span class="number">4</span>, w / <span class="number">16</span>),  <span class="comment">// 椭圆长轴和短轴</span></span><br><span class="line">            angle,                <span class="comment">// 椭圆旋转角度</span></span><br><span class="line">            <span class="number">0</span>,                    <span class="comment">// 起始角度</span></span><br><span class="line">            <span class="number">360</span>,                  <span class="comment">// 结束角度</span></span><br><span class="line">            <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>),    <span class="comment">// 颜色（蓝色）</span></span><br><span class="line">            thickness,            <span class="comment">// 线宽</span></span><br><span class="line">            lineType);            <span class="comment">// 线型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFilledCircle</span><span class="params">(Mat img, Point center)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">circle</span>(img,                <span class="comment">// 绘制实心圆</span></span><br><span class="line">           center,             <span class="comment">// 圆心坐标</span></span><br><span class="line">           w / <span class="number">32</span>,             <span class="comment">// 半径</span></span><br><span class="line">           <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),  <span class="comment">// 颜色（红色）</span></span><br><span class="line">           FILLED,             <span class="comment">// 填充圆形</span></span><br><span class="line">           LINE_8);            <span class="comment">// 线型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPolygon</span><span class="params">(Mat img)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lineType = LINE_8;  <span class="comment">// 线型</span></span><br><span class="line"></span><br><span class="line">    Point rook_points[<span class="number">1</span>][<span class="number">20</span>];  <span class="comment">// 定义一个多边形的20个顶点</span></span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">Point</span>(w / <span class="number">4</span>, <span class="number">7</span> * w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">Point</span>(<span class="number">3</span> * w / <span class="number">4</span>, <span class="number">7</span> * w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">2</span>] = <span class="built_in">Point</span>(<span class="number">3</span> * w / <span class="number">4</span>, <span class="number">13</span> * w / <span class="number">16</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">3</span>] = <span class="built_in">Point</span>(<span class="number">11</span> * w / <span class="number">16</span>, <span class="number">13</span> * w / <span class="number">16</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">4</span>] = <span class="built_in">Point</span>(<span class="number">19</span> * w / <span class="number">32</span>, <span class="number">3</span> * w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">5</span>] = <span class="built_in">Point</span>(<span class="number">3</span> * w / <span class="number">4</span>, <span class="number">3</span> * w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">6</span>] = <span class="built_in">Point</span>(<span class="number">3</span> * w / <span class="number">4</span>, w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">7</span>] = <span class="built_in">Point</span>(<span class="number">26</span> * w / <span class="number">40</span>, w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">8</span>] = <span class="built_in">Point</span>(<span class="number">26</span> * w / <span class="number">40</span>, w / <span class="number">4</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">9</span>] = <span class="built_in">Point</span>(<span class="number">22</span> * w / <span class="number">40</span>, w / <span class="number">4</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">10</span>] = <span class="built_in">Point</span>(<span class="number">22</span> * w / <span class="number">40</span>, w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">11</span>] = <span class="built_in">Point</span>(<span class="number">18</span> * w / <span class="number">40</span>, w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">12</span>] = <span class="built_in">Point</span>(<span class="number">18</span> * w / <span class="number">40</span>, w / <span class="number">4</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">13</span>] = <span class="built_in">Point</span>(<span class="number">14</span> * w / <span class="number">40</span>, w / <span class="number">4</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">14</span>] = <span class="built_in">Point</span>(<span class="number">14</span> * w / <span class="number">40</span>, w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">15</span>] = <span class="built_in">Point</span>(w / <span class="number">4</span>, w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">16</span>] = <span class="built_in">Point</span>(w / <span class="number">4</span>, <span class="number">3</span> * w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">17</span>] = <span class="built_in">Point</span>(<span class="number">13</span> * w / <span class="number">32</span>, <span class="number">3</span> * w / <span class="number">8</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">18</span>] = <span class="built_in">Point</span>(<span class="number">5</span> * w / <span class="number">16</span>, <span class="number">13</span> * w / <span class="number">16</span>);</span><br><span class="line">    rook_points[<span class="number">0</span>][<span class="number">19</span>] = <span class="built_in">Point</span>(w / <span class="number">4</span>, <span class="number">13</span> * w / <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Point* ppt[<span class="number">1</span>] = &#123;rook_points[<span class="number">0</span>]&#125;;  <span class="comment">// 多边形顶点指针数组</span></span><br><span class="line">    <span class="type">int</span> npt[] = &#123;<span class="number">20</span>&#125;;                        <span class="comment">// 多边形顶点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fillPoly</span>(img,                    <span class="comment">// 填充多边形</span></span><br><span class="line">             ppt,                    <span class="comment">// 顶点数组</span></span><br><span class="line">             npt,                    <span class="comment">// 每个多边形的顶点数</span></span><br><span class="line">             <span class="number">1</span>,                      <span class="comment">// 多边形数量</span></span><br><span class="line">             <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>),  <span class="comment">// 填充颜色（白色）</span></span><br><span class="line">             lineType);              <span class="comment">// 线型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLine</span><span class="params">(Mat img, Point start, Point end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> thickness = <span class="number">2</span>;      <span class="comment">// 线宽</span></span><br><span class="line">    <span class="type">int</span> lineType = LINE_8;  <span class="comment">// 线型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">line</span>(img,              <span class="comment">// 绘制直线</span></span><br><span class="line">         start,            <span class="comment">// 起点坐标</span></span><br><span class="line">         end,              <span class="comment">// 终点坐标</span></span><br><span class="line">         <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),  <span class="comment">// 直线颜色（黑色）</span></span><br><span class="line">         thickness,        <span class="comment">// 线宽</span></span><br><span class="line">         lineType);        <span class="comment">// 线型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码将生成两个窗口：</p>
<figure>
<img src="https://docs.opencv.org/4.x/Drawing_1_Tutorial_Result_0.png"
alt="图1. 左为原子结构，右为城堡结构" />
<figcaption aria-hidden="true">图1.
左为原子结构，右为城堡结构</figcaption>
</figure>
<hr />
<h2 id="随机数生成与文本绘制">随机数生成与文本绘制</h2>
<p>将通过OpenCV的随机数生成器 <code>cv::RNG</code>
和文本绘制功能，演示如何动态生成随机几何图形与文字效果</p>
<h3 id="随机数生成器">随机数生成器</h3>
<p>OpenCV提供 <code>cv::RNG</code>
类生成伪随机数。初始化时需指定种子值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::RNG <span class="title">rng</span><span class="params">(<span class="number">0xFFFFFFFF</span>)</span></span>;  <span class="comment">// 使用十六进制种子初始化</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>uniform(a, b)</code> 方法生成区间 <span
class="math inline">\([a, b)\)</span> 内的 <strong>均匀分布</strong>
随机 <strong>整数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> random_value = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">100</span>);  <span class="comment">// 随机数范围 [0, 100)</span></span><br></pre></td></tr></table></figure>
<p>若需要浮点数，可显式指定类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> random_float = rng.<span class="built_in">uniform</span>(<span class="number">0.0</span>, <span class="number">1.0</span>);  <span class="comment">// 生成 0.0 到 1.0 之间的浮点数</span></span><br></pre></td></tr></table></figure>
<h3 id="绘制随机几何图形">绘制随机几何图形</h3>
<p>以下示例演示如何生成随机线条：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Drawing_Random_Lines</span><span class="params">(cv::Mat image, <span class="type">const</span> std::string&amp; window_name, cv::RNG rng)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">100</span>;  <span class="comment">// 绘制 100 条随机线</span></span><br><span class="line">    <span class="type">int</span> lineType = cv::LINE_8;</span><br><span class="line">    cv::Point pt1, pt2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; i++) &#123;</span><br><span class="line">        pt<span class="number">1.</span>x = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols);  <span class="comment">// x 坐标随机</span></span><br><span class="line">        pt<span class="number">1.</span>y = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.rows);  <span class="comment">// y 坐标随机</span></span><br><span class="line">        pt<span class="number">2.</span>x = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols);</span><br><span class="line">        pt<span class="number">2.</span>y = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.rows);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机颜色生成函数</span></span><br><span class="line">        <span class="keyword">auto</span> randomColor = [&amp;](cv::RNG&amp; rng) &#123;</span><br><span class="line">            <span class="keyword">return</span> cv::<span class="built_in">Scalar</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">256</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">256</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">256</span>));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">line</span>(image, pt1, pt2, <span class="built_in">randomColor</span>(rng), rng.<span class="built_in">uniform</span>(<span class="number">1</span>, <span class="number">10</span>), lineType);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, image);</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">10</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 监听键盘 10ms </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似方法可扩展至其他图形（矩形、椭圆、多边形等），只需调整参数生成逻辑。</p>
<h3 id="动态文本绘制">动态文本绘制</h3>
<p>使用 <code>cv::putText</code> 在图像上添加随机文字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Displaying_Random_Text</span><span class="params">(cv::Mat image, <span class="type">const</span> std::string&amp; window_name, cv::RNG rng)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        cv::Point org;</span><br><span class="line">        org.x = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols - <span class="number">200</span>);  <span class="comment">// 避免文字越界</span></span><br><span class="line">        org.y = rng.<span class="built_in">uniform</span>(<span class="number">20</span>, image.rows);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机字体、大小、颜色和粗细</span></span><br><span class="line">        <span class="type">int</span> fontFace = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="type">double</span> fontScale = rng.<span class="built_in">uniform</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="function">cv::Scalar <span class="title">color</span><span class="params">(rng.uniform(<span class="number">0</span>, <span class="number">256</span>), rng.uniform(<span class="number">0</span>, <span class="number">256</span>), rng.uniform(<span class="number">0</span>, <span class="number">256</span>))</span></span>;</span><br><span class="line">        <span class="type">int</span> thickness = rng.<span class="built_in">uniform</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">putText</span>(image, <span class="string">&quot;OpenCV Tutorial&quot;</span>, org, fontFace, fontScale, color, thickness);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, image);</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">100</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态渐变文字效果">动态渐变文字效果</h3>
<p>以下代码实现文字颜色渐变与图像亮度变化的动画效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Displaying_Big_End</span><span class="params">(cv::Mat image, <span class="type">const</span> std::string&amp; window_name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cv::Size cv::getTextSize(const std::string&amp; text,  // 要测量的文本串</span></span><br><span class="line">    <span class="comment">//                          int fontFace,             // 字体类型</span></span><br><span class="line">    <span class="comment">//                          double fontScale,         // 字体的缩放因子</span></span><br><span class="line">    <span class="comment">//                          int thickness,            // 文本的线条宽度</span></span><br><span class="line">    <span class="comment">//                          int* baseline = 0);       // 计算文本的基线的位置</span></span><br><span class="line">    cv::Size textSize = cv::<span class="built_in">getTextSize</span>(<span class="string">&quot;OpenCV forever!&quot;</span>, cv::FONT_HERSHEY_COMPLEX, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="function">cv::Point <span class="title">org</span><span class="params">((image.cols - textSize.width) / <span class="number">2</span>, (image.rows + textSize.height) / <span class="number">2</span>)</span></span>;</span><br><span class="line">    cv::Mat image2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        image2 = image - cv::Scalar::<span class="built_in">all</span>(i);  <span class="comment">// 图像亮度递减</span></span><br><span class="line">        cv::<span class="built_in">putText</span>(image2, <span class="string">&quot;OpenCV forever!&quot;</span>, org, cv::FONT_HERSHEY_COMPLEX, <span class="number">3</span>, </span><br><span class="line">                   cv::<span class="built_in">Scalar</span>(i, i, <span class="number">255</span>), <span class="number">5</span>);  <span class="comment">// 文字颜色渐变</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, image2);</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">30</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例代码-1">示例代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机颜色生成函数</span></span><br><span class="line"><span class="function">cv::Scalar <span class="title">randomColor</span><span class="params">(cv::RNG&amp; rng)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cv::<span class="built_in">Scalar</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">256</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">256</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">256</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制随机线条</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Drawing_Random_Lines</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> std::string&amp; window_name, cv::RNG&amp; rng)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lineType = cv::LINE_8;</span><br><span class="line">    cv::Point pt1, pt2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; i++) &#123;</span><br><span class="line">        pt<span class="number">1.</span>x = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols);  <span class="comment">// x坐标随机</span></span><br><span class="line">        pt<span class="number">1.</span>y = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.rows);  <span class="comment">// y坐标随机</span></span><br><span class="line">        pt<span class="number">2.</span>x = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols);</span><br><span class="line">        pt<span class="number">2.</span>y = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.rows);</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">line</span>(image, pt1, pt2, <span class="built_in">randomColor</span>(rng), rng.<span class="built_in">uniform</span>(<span class="number">1</span>, <span class="number">10</span>), lineType);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, image);</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">10</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制随机矩形</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Drawing_Random_Rectangles</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> std::string&amp; window_name, cv::RNG&amp; rng)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lineType = cv::LINE_8;</span><br><span class="line">    cv::Point pt1, pt2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; i++) &#123;</span><br><span class="line">        pt<span class="number">1.</span>x = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols);</span><br><span class="line">        pt<span class="number">1.</span>y = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.rows);</span><br><span class="line">        pt<span class="number">2.</span>x = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols);</span><br><span class="line">        pt<span class="number">2.</span>y = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.rows);</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">rectangle</span>(image, pt1, pt2, <span class="built_in">randomColor</span>(rng), rng.<span class="built_in">uniform</span>(<span class="number">-1</span>, <span class="number">10</span>), lineType);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, image);</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">10</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制随机椭圆</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Drawing_Random_Ellipses</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> std::string&amp; window_name, cv::RNG&amp; rng)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lineType = cv::LINE_8;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; i++) &#123;</span><br><span class="line">        <span class="function">cv::Point <span class="title">center</span><span class="params">(rng.uniform(<span class="number">0</span>, image.cols), rng.uniform(<span class="number">0</span>, image.rows))</span></span>;</span><br><span class="line">        <span class="function">cv::Size <span class="title">axes</span><span class="params">(rng.uniform(<span class="number">0</span>, <span class="number">200</span>), rng.uniform(<span class="number">0</span>, <span class="number">200</span>))</span></span>;</span><br><span class="line">        <span class="type">double</span> angle = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">360</span>);</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">ellipse</span>(image, center, axes, angle, <span class="number">0</span>, <span class="number">360</span>, <span class="built_in">randomColor</span>(rng), rng.<span class="built_in">uniform</span>(<span class="number">-1</span>, <span class="number">10</span>), lineType);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, image);</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">10</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制随机多边形</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Drawing_Random_Polylines</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> std::string&amp; window_name, cv::RNG&amp; rng)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lineType = cv::LINE_8;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; i++) &#123;</span><br><span class="line">        cv::Point pts[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        pts[<span class="number">0</span>][<span class="number">0</span>] = cv::<span class="built_in">Point</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.rows));</span><br><span class="line">        pts[<span class="number">0</span>][<span class="number">1</span>] = cv::<span class="built_in">Point</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.rows));</span><br><span class="line">        pts[<span class="number">0</span>][<span class="number">2</span>] = cv::<span class="built_in">Point</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.rows));</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> cv::Point* ppt[<span class="number">1</span>] = &#123;pts[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="type">int</span> npt[] = &#123;<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">polylines</span>(image, ppt, npt, <span class="number">1</span>, <span class="literal">true</span>, <span class="built_in">randomColor</span>(rng), rng.<span class="built_in">uniform</span>(<span class="number">1</span>, <span class="number">10</span>), lineType);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, image);</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">10</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制随机文本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Displaying_Random_Text</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> std::string&amp; window_name, cv::RNG&amp; rng)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lineType = cv::LINE_8;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; i++) &#123;</span><br><span class="line">        cv::Point org;</span><br><span class="line">        org.x = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, image.cols - <span class="number">200</span>);  <span class="comment">// 避免文字越界</span></span><br><span class="line">        org.y = rng.<span class="built_in">uniform</span>(<span class="number">20</span>, image.rows);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fontFace = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">8</span>);      <span class="comment">// 随机字体</span></span><br><span class="line">        <span class="type">double</span> fontScale = rng.<span class="built_in">uniform</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 随机字体大小</span></span><br><span class="line">        <span class="type">int</span> thickness = rng.<span class="built_in">uniform</span>(<span class="number">1</span>, <span class="number">5</span>);     <span class="comment">// 随机粗细</span></span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">putText</span>(image, <span class="string">&quot;OpenCV Tutorial&quot;</span>, org, fontFace, fontScale, <span class="built_in">randomColor</span>(rng), thickness, lineType);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, image);</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">100</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态渐变文字效果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Displaying_Big_End</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> std::string&amp; window_name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cv::Size textSize = cv::<span class="built_in">getTextSize</span>(<span class="string">&quot;OpenCV forever!&quot;</span>, cv::FONT_HERSHEY_COMPLEX, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="function">cv::Point <span class="title">org</span><span class="params">((image.cols - textSize.width) / <span class="number">2</span>, (image.rows + textSize.height) / <span class="number">2</span>)</span></span>;</span><br><span class="line">    cv::Mat image2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        image2 = image - cv::Scalar::<span class="built_in">all</span>(i);  <span class="comment">// 图像亮度递减</span></span><br><span class="line">        cv::<span class="built_in">putText</span>(image2, <span class="string">&quot;OpenCV forever!&quot;</span>, org, cv::FONT_HERSHEY_COMPLEX, <span class="number">3</span>,</span><br><span class="line">                    cv::<span class="built_in">Scalar</span>(i, i, <span class="number">255</span>), <span class="number">5</span>);  <span class="comment">// 文字颜色渐变</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, image2);</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">30</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> window_width = <span class="number">800</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> window_height = <span class="number">600</span>;</span><br><span class="line">    <span class="type">const</span> std::string window_name = <span class="string">&quot;OpenCV Random Drawing&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化黑底画布</span></span><br><span class="line">    cv::Mat image = cv::Mat::<span class="built_in">zeros</span>(window_height, window_width, CV_8UC3);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(window_name, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化随机数生成器</span></span><br><span class="line">    <span class="function">cv::RNG <span class="title">rng</span><span class="params">(<span class="number">0xFFFFFFFF</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次调用绘图函数</span></span><br><span class="line">    <span class="built_in">Drawing_Random_Lines</span>(image, window_name, rng);</span><br><span class="line">    <span class="built_in">Drawing_Random_Rectangles</span>(image, window_name, rng);</span><br><span class="line">    <span class="built_in">Drawing_Random_Ellipses</span>(image, window_name, rng);</span><br><span class="line">    <span class="built_in">Drawing_Random_Polylines</span>(image, window_name, rng);</span><br><span class="line">    <span class="built_in">Displaying_Random_Text</span>(image, window_name, rng);</span><br><span class="line">    <span class="built_in">Displaying_Big_End</span>(image, window_name);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="图像平滑">图像平滑</h2>
<h3 id="目标">目标</h3>
<p>使用 OpenCV
实现图像平滑处理，涵盖四种常用线性滤波器：均值滤波、高斯滤波、中值滤波和双边滤波。掌握
<code>cv::blur()</code> 、 <code>cv::GaussianBlur()</code> 、
<code>cv::medianBlur()</code> 和 <code>cv::bilateralFilter()</code>
等函数的使用方法。</p>
<hr />
<h3 id="理论基础">理论基础</h3>
<h4 id="均值滤波normalized-box-filter">均值滤波（Normalized Box
Filter）</h4>
<p><strong>公式：</strong></p>
<p><span class="math display">\[
K = \frac{1}{K_{\text{width}} \cdot K_{\text{height}}}
\begin{bmatrix}
1 &amp; 1 &amp; \ldots &amp; 1 \\
1 &amp; 1 &amp; \ldots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \ldots &amp; 1
\end{bmatrix}\nonumber
\]</span></p>
<p><strong>参数说明：</strong></p>
<ul>
<li><p><strong><span class="math inline">\(K_{\text{width}}\)</span> 和
<span class="math inline">\(K_{\text{height}}\)</span> ：</strong><br />
表示滤波核的宽度和高度。通常选取奇数（如 3×3、5×5
等），以便确定一个明确的中心像素。</p></li>
<li><p><strong>归一化因子 <span
class="math inline">\(\frac{1}{K_{\text{width}} \cdot
K_{\text{height}}}\)</span> ：</strong><br />
保证滤波核内所有元素的权重之和为
1，从而在平滑图像时不改变整体亮度。</p></li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>均值滤波通过计算邻域内所有像素值的平均值来减少图像噪声，具有简单高效的特点。<br />
</li>
<li>但由于对所有邻域像素赋予相同的权重，它在平滑的同时可能会使边缘和细节变得模糊。</li>
</ul>
<hr />
<h4 id="高斯滤波gaussian-filter">高斯滤波（Gaussian Filter）</h4>
<p><strong>公式：</strong></p>
<p><span class="math display">\[
G_0(x, y) = A \exp\left(-\frac{(x - \mu_x)^2}{2\sigma_x^2} - \frac{(y -
\mu_y)^2}{2\sigma_y^2}\right)\nonumber
\]</span></p>
<p><strong>参数说明：</strong></p>
<ul>
<li><p><strong><span class="math inline">\(A\)</span> ：</strong><br />
归一化常数，用于确保整个滤波核的所有权重之和为1。</p></li>
<li><p><strong><span class="math inline">\(\mu_x\)</span> 和 <span
class="math inline">\(\mu_y\)</span> ：</strong><br />
分别为高斯函数在 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 方向的均值。通常选取核的中心点，即
<span class="math inline">\(\mu_x=0,\ \mu_y=0\)</span>
（若坐标以核中心为原点），或者直接设置为核的中心像素坐标。</p></li>
<li><p><strong><span class="math inline">\(\sigma_x\)</span> 和 <span
class="math inline">\(\sigma_y\)</span> ：</strong><br />
分别为高斯函数在 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>
方向的标准差，决定了权重分布的宽度。</p>
<ul>
<li>较大的 <span class="math inline">\(\sigma\)</span>
值使得核内权重分布更加平缓，平滑效果更强；<br />
</li>
<li>较小的 <span class="math inline">\(\sigma\)</span>
值使得权重更多集中在中心像素附近，从而在平滑的同时更好地保留局部细节。<br />
</li>
<li>当要求各向同性平滑时，可以令 <span class="math inline">\(\sigma_x =
\sigma_y = \sigma\)</span> 。</li>
</ul></li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>高斯滤波器能较好地平滑图像，同时在一定程度上保留边缘信息，相比于简单的均值滤波，它更能适应图像的局部特性。</li>
<li>由于权重随距离呈指数衰减，高斯滤波在邻域中心像素附近具有更高的权重，减少了远处像素对结果的影响。</li>
</ul>
<hr />
<h4 id="中值滤波median-filter">中值滤波（Median Filter）</h4>
<p><strong>公式：</strong></p>
<p><span class="math display">\[
g(i, j) = \text{median}\{f(i + k, j + l)\}\nonumber
\]</span></p>
<p>其中， <span class="math inline">\(k\)</span> 和 <span
class="math inline">\(l\)</span> 遍历选定的邻域（例如 3×3 或 5×5
窗口）。</p>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>窗口大小：</strong><br />
定义了计算中值时考虑的邻域范围。窗口越大，能够去除的噪声范围就越广，但也可能导致细节损失；窗口较小则保留更多细节，但可能对较大范围的噪声不够鲁棒。</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>中值滤波特别适用于去除“椒盐噪声”，因为中值运算能有效抑制孤立的异常值（极大或极小的噪声像素），而不受这些异常值的极端影响。</li>
<li>与均值滤波不同，中值滤波不会产生模糊边缘的现象，能够较好地保留边缘和细节信息。</li>
</ul>
<hr />
<h4 id="双边滤波bilateral-filter">双边滤波（Bilateral Filter）</h4>
<p><strong>公式：</strong></p>
<p><span class="math display">\[
g(i, j) = \frac{\sum_{k,l} f(i+k, j+l) \cdot w_{\text{space}}(k,l) \cdot
w_{\text{color}}(f(i,j), f(i+k, j+l))}{\sum_{k,l} w_{\text{space}}(k,l)
\cdot w_{\text{color}}(f(i,j), f(i+k, j+l))}\nonumber
\]</span></p>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong><span class="math inline">\(w_{\text{space}}(k,l)\)</span>
：</strong><br />
空间权重，通常采用高斯函数定义，用于衡量当前像素与邻域像素之间的空间距离影响。
<ul>
<li>一般形式为：<br />
<span class="math display">\[
w_{\text{space}}(k,l) =
\exp\left(-\frac{k^2+l^2}{2\sigma_s^2}\right)\nonumber
\]</span><br />
</li>
<li>其中， <span class="math inline">\(\sigma_s\)</span>
决定了空间距离的衰减速度，较大的 <span
class="math inline">\(\sigma_s\)</span>
意味着更广的空间范围内的像素会有较高的权重。</li>
</ul></li>
<li><strong><span class="math inline">\(w_{\text{color}}(f(i,j), f(i+k,
j+l))\)</span> ：</strong><br />
颜色（或灰度）权重，用于衡量中心像素与邻域像素在像素值（颜色或亮度）上的相似程度。
<ul>
<li>常用形式为：<br />
<span class="math display">\[
w_{\text{color}}(f(i,j), f(i+k, j+l)) =
\exp\left(-\frac{(f(i,j)-f(i+k,j+l))^2}{2\sigma_r^2}\right)\nonumber
\]</span><br />
</li>
<li>参数 <span class="math inline">\(\sigma_r\)</span> （也称为 <span
class="math inline">\(\sigma_c\)</span>
）控制了对像素值差异的敏感程度。较小的 <span
class="math inline">\(\sigma_r\)</span>
会使得仅有非常相近像素值的邻域才被赋予较大权重，从而有效保护边缘信息。</li>
</ul></li>
<li><strong>窗口大小：</strong><br />
决定了在空间上参与滤波的邻域范围。通常与 <span
class="math inline">\(\sigma_s\)</span>
相匹配，确保窗口足够大以包含主要的贡献区域。</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>双边滤波在平滑图像噪声的同时，通过结合空间和颜色信息，有效避免了跨边缘的像素混合，从而更好地保留图像的边缘和细节。</li>
<li>适用于需要在降噪的同时保持清晰边缘的图像处理场景，如人像美化和细节增强。</li>
</ul>
<p>参数说明：</p>
<ul>
<li><code>src</code>：输入图像</li>
<li><code>dst</code>：输出图像</li>
<li><code>Size(w, h)</code>：核大小（需为奇数）</li>
<li><code>Point(-1, -1)</code>：锚点位置（默认中心）</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<h4 id="均值滤波示例">均值滤波示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;lena.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">Mat dst;</span><br><span class="line">cv::<span class="built_in">blur</span>(src, dst, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), cv::<span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>src</code>：输入图像</li>
<li><code>dst</code>：输出图像</li>
<li><code>Size(w, h)</code>：核大小（需为奇数）</li>
<li><code>Point(-1, -1)</code>：锚点位置（默认中心）</li>
</ul>
<h4 id="高斯滤波示例">高斯滤波示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">GaussianBlur</span>(src, dst, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>参数 <code>0</code> 表示自动计算标准差。</p>
<h4 id="中值滤波示例">中值滤波示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">medianBlur</span>(src, dst, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>核大小必须为奇数。</p>
<h4 id="双边滤波示例">双边滤波示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">bilateralFilter</span>(src, dst, <span class="number">9</span>, <span class="number">75</span>, <span class="number">75</span>);</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>9</code>：邻域直径</li>
<li><code>75</code>：颜色空间和坐标空间的标准差</li>
</ul>
<h3 id="示例代码-2">示例代码</h3>
<p>通过循环逐步增大核尺寸，可观察不同滤波器的平滑效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgcodecs.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 读取图像</span></span><br><span class="line">     <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;cat.jpg&quot;</span>;</span><br><span class="line">     cv::Mat src = cv::<span class="built_in">imread</span>(cv::samples::<span class="built_in">findFile</span>(filename), cv::IMREAD_COLOR);</span><br><span class="line">     <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;Error opening image!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; [image_name -- default lena.jpg]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">          <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 显示原始图像</span></span><br><span class="line">     cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Original Image&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line">     cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 定义输出图像</span></span><br><span class="line">     cv::Mat dst;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 均值滤波</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">          cv::<span class="built_in">blur</span>(src, dst, cv::<span class="built_in">Size</span>(i, i), cv::<span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">          cv::<span class="built_in">imshow</span>(<span class="string">&quot;Homogeneous Blur&quot;</span>, dst);</span><br><span class="line">          cv::<span class="built_in">waitKey</span>(<span class="number">500</span>); <span class="comment">// 每500ms更新一次</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 高斯滤波</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">          cv::<span class="built_in">GaussianBlur</span>(src, dst, cv::<span class="built_in">Size</span>(i, i), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">          cv::<span class="built_in">imshow</span>(<span class="string">&quot;Gaussian Blur&quot;</span>, dst);</span><br><span class="line">          cv::<span class="built_in">waitKey</span>(<span class="number">500</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 中值滤波</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">          cv::<span class="built_in">medianBlur</span>(src, dst, i);</span><br><span class="line">          cv::<span class="built_in">imshow</span>(<span class="string">&quot;Median Blur&quot;</span>, dst);</span><br><span class="line">          cv::<span class="built_in">waitKey</span>(<span class="number">500</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 双边滤波</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">          cv::<span class="built_in">bilateralFilter</span>(src, dst, i, i * <span class="number">2</span>, i / <span class="number">2</span>);</span><br><span class="line">          cv::<span class="built_in">imshow</span>(<span class="string">&quot;Bilateral Blur&quot;</span>, dst);</span><br><span class="line">          cv::<span class="built_in">waitKey</span>(<span class="number">500</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 结束提示</span></span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Smoothing process completed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">     cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ul>
<li><strong>均值滤波</strong>：简单易实现，但容易模糊边缘。适用于噪声较低且对边缘要求不高的场景。</li>
<li><strong>高斯滤波</strong>：通过空间加权实现更自然的平滑效果，对细节保留较好。常用于预处理步骤中去除高频噪声。</li>
<li><strong>中值滤波</strong>：特别适合去除椒盐噪声，因其中值运算对异常值不敏感，能较好地保护边缘信息。</li>
<li><strong>双边滤波</strong>：结合空间和像素值信息，在降噪的同时能较好地保留边缘，适用于高质量图像处理。</li>
</ul>
<p>实际应用中需根据噪声类型和图像特点选择合适的滤波方法。通过调整核大小和参数，可灵活平衡平滑效果与细节保留。</p>
<hr />
<h2 id="形态学操作-morphological-operation">形态学操作 (morphological
operation)</h2>
<h3 id="腐蚀与膨胀-erosion-and-dilation">腐蚀与膨胀 (erosion and
dilation)</h3>
<p>形态学操作通过
<strong>结构元素（Kernel）</strong>对图像进行形状处理，常用于去噪、分离或连接图像元素。<br />
形态学中两种基础操作——<strong>腐蚀 (Erosion)</strong> 与 <strong>膨胀
(Dilation)</strong>。</p>
<ol type="1">
<li><strong>腐蚀</strong>：缩小图像中的亮区域，扩大暗区域。<br />
</li>
<li><strong>膨胀</strong>：扩大图像中的亮区域，缩小暗区域。</li>
</ol>
<p>数学表达式如下：</p>
<ul>
<li><strong>膨胀</strong>：</li>
</ul>
<p><span class="math display">\[
\text{dst}(x, y) = \max_{(x&#39;,y&#39;)} \text{src}(x + x&#39;, y +
y&#39;) \nonumber
\]</span></p>
<ul>
<li><strong>腐蚀</strong>：</li>
</ul>
<p><span class="math display">\[
\text{dst}(x, y) = \min_{(x&#39;,y&#39;)} \text{src}(x + x&#39;, y +
y&#39;) \nonumber
\]</span></p>
<p>膨胀和腐蚀和神经网络中的池化操作在操作上有相似之处。</p>
<h4 id="示例代码-3">示例代码</h4>
<p>OpenCV提供<code>cv::erode</code>和<code>cv::dilate</code>函数实现腐蚀与膨胀。以下代码演示如何通过滑动条动态调整结构元素类型和大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">cv::Mat src, erosion_dst, dilation_dst;</span><br><span class="line"><span class="type">int</span> erosion_elem = <span class="number">0</span>, dilation_elem = <span class="number">0</span>;       <span class="comment">// 结构元素类型 0: 矩形，1: 十字，2: 椭圆</span></span><br><span class="line"><span class="type">int</span> erosion_size = <span class="number">0</span>, dilation_size = <span class="number">0</span>;       <span class="comment">// 结构元素的大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_elem = <span class="number">2</span>, max_kernel_size = <span class="number">21</span>;  <span class="comment">// 最大结构元素类型和最大核尺寸</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Erosion</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dilation</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">cv::CommandLineParser <span class="title">parser</span><span class="params">(argc, argv, <span class="string">&quot;&#123;@input | cat.jpg | input image&#125;&quot;</span>)</span></span>;</span><br><span class="line">    src = cv::<span class="built_in">imread</span>(cv::samples::<span class="built_in">findFile</span>(parser.<span class="built_in">get</span>&lt;cv::String&gt;(<span class="string">&quot;@input&quot;</span>)), cv::IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法加载图像！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;腐蚀示例&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;膨胀示例&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line">    cv::<span class="built_in">moveWindow</span>(<span class="string">&quot;膨胀示例&quot;</span>, src.cols, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建滑动条</span></span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;结构元素&quot;</span>, <span class="string">&quot;腐蚀示例&quot;</span>, &amp;erosion_elem, max_elem, Erosion);       <span class="comment">// 结构元素类型 0: 矩形，1: 十字，2: 椭圆</span></span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;核大小&quot;</span>, <span class="string">&quot;腐蚀示例&quot;</span>, &amp;erosion_size, max_kernel_size, Erosion);  <span class="comment">// 核尺寸 2*n+1 确保为奇数</span></span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;结构元素&quot;</span>, <span class="string">&quot;膨胀示例&quot;</span>, &amp;dilation_elem, max_elem, Dilation);</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;核大小&quot;</span>, <span class="string">&quot;膨胀示例&quot;</span>, &amp;dilation_size, max_kernel_size, Dilation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始调用（更新显示效果）</span></span><br><span class="line">    <span class="built_in">Erosion</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Dilation</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Erosion</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据滑动条选择结构元素类型</span></span><br><span class="line">    <span class="type">int</span> erosion_type = cv::MORPH_RECT;  <span class="comment">// 默认矩形</span></span><br><span class="line">    <span class="keyword">if</span> (erosion_elem == <span class="number">1</span>)</span><br><span class="line">        erosion_type = cv::MORPH_CROSS;  <span class="comment">// 十字</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (erosion_elem == <span class="number">2</span>)</span><br><span class="line">        erosion_type = cv::MORPH_ELLIPSE;  <span class="comment">// 椭圆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结构元素（注意使用 cv::getStructuringElement）</span></span><br><span class="line">    cv::Mat element = cv::<span class="built_in">getStructuringElement</span>(erosion_type,</span><br><span class="line">                                                cv::<span class="built_in">Size</span>(<span class="number">2</span> * erosion_size + <span class="number">1</span>, <span class="number">2</span> * erosion_size + <span class="number">1</span>),</span><br><span class="line">                                                cv::<span class="built_in">Point</span>(erosion_size, erosion_size));</span><br><span class="line">    <span class="comment">// 执行腐蚀操作</span></span><br><span class="line">    cv::<span class="built_in">erode</span>(src, erosion_dst, element);</span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;腐蚀示例&quot;</span>, erosion_dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dilation</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dilation_type = cv::MORPH_RECT;</span><br><span class="line">    <span class="keyword">if</span> (dilation_elem == <span class="number">1</span>)</span><br><span class="line">        dilation_type = cv::MORPH_CROSS;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dilation_elem == <span class="number">2</span>)</span><br><span class="line">        dilation_type = cv::MORPH_ELLIPSE;</span><br><span class="line"></span><br><span class="line">    cv::Mat element = cv::<span class="built_in">getStructuringElement</span>(dilation_type,</span><br><span class="line">                                                cv::<span class="built_in">Size</span>(<span class="number">2</span> * dilation_size + <span class="number">1</span>, <span class="number">2</span> * dilation_size + <span class="number">1</span>),</span><br><span class="line">                                                cv::<span class="built_in">Point</span>(dilation_size, dilation_size));</span><br><span class="line">    <span class="comment">// 执行膨胀操作</span></span><br><span class="line">    cv::<span class="built_in">dilate</span>(src, dilation_dst, element);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;膨胀示例&quot;</span>, dilation_dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="note info"><summary><p>相关函数解释</p>
</summary>
<p><strong>1. <code>cv::getStructuringElement</code></strong></p>
<p><strong>功能</strong>：生成指定形状和大小的结构元素（Kernel），用于形态学操作。<br />
<strong>函数原型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">cv::getStructuringElement</span><span class="params">(<span class="type">int</span> shape, cv::Size ksize, cv::Point anchor = cv::Point(<span class="number">-1</span>,<span class="number">-1</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<ul>
<li><code>shape</code>：结构元素的形状，可选值：
<ul>
<li><code>cv::MORPH_RECT</code>：矩形<br />
</li>
<li><code>cv::MORPH_CROSS</code>：十字形<br />
</li>
<li><code>cv::MORPH_ELLIPSE</code>：椭圆形<br />
</li>
</ul></li>
<li><code>ksize</code>：结构元素的大小，通常为奇数（如<code>Size(3, 3)</code>）。<br />
</li>
<li><code>anchor</code>：锚点位置，默认为中心点<code>(-1, -1)</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat element = cv::<span class="built_in">getStructuringElement</span>(cv::MORPH_RECT, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p><strong>2. <code>cv::erode</code></strong></p>
<p><strong>功能</strong>：对图像进行腐蚀操作，缩小亮区域，扩大暗区域。<br />
<strong>函数原型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::erode</span><span class="params">(cv::InputArray src, cv::OutputArray dst, cv::InputArray kernel, </span></span></span><br><span class="line"><span class="params"><span class="function">               cv::Point anchor = cv::Point(<span class="number">-1</span>,<span class="number">-1</span>), <span class="type">int</span> iterations = <span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> borderType = cv::BORDER_CONSTANT, <span class="type">const</span> cv::Scalar&amp; borderValue = cv::morphologyDefaultBorderValue())</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<ul>
<li><code>src</code>：输入图像。<br />
</li>
<li><code>dst</code>：输出图像。<br />
</li>
<li><code>kernel</code>：结构元素，可通过<code>cv::getStructuringElement</code>生成。<br />
</li>
<li><code>anchor</code>：锚点位置，默认为中心点。<br />
</li>
<li><code>iterations</code>：腐蚀操作的迭代次数。<br />
</li>
<li><code>borderType</code>：边界填充类型。<br />
</li>
<li><code>borderValue</code>：边界填充值。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat eroded;</span><br><span class="line">cv::<span class="built_in">erode</span>(src, eroded, element);</span><br></pre></td></tr></table></figure>
<p><strong>3. <code>cv::dilate</code></strong></p>
<p><strong>功能</strong>：对图像进行膨胀操作，扩大亮区域，缩小暗区域。<br />
<strong>函数原型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::dilate</span><span class="params">(cv::InputArray src, cv::OutputArray dst, cv::InputArray kernel, </span></span></span><br><span class="line"><span class="params"><span class="function">                cv::Point anchor = cv::Point(<span class="number">-1</span>,<span class="number">-1</span>), <span class="type">int</span> iterations = <span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> borderType = cv::BORDER_CONSTANT, <span class="type">const</span> cv::Scalar&amp; borderValue = cv::morphologyDefaultBorderValue())</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<ul>
<li>参数与<code>cv::erode</code>相同。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat dilated;</span><br><span class="line">cv::<span class="built_in">dilate</span>(src, dilated, element);</span><br></pre></td></tr></table></figure>
<p><strong>4. 总结</strong></p>
<ul>
<li><code>cv::getStructuringElement</code>：生成结构元素，决定腐蚀或膨胀的形状和大小。<br />
</li>
<li><code>cv::erode</code>：腐蚀操作，缩小亮区域。<br />
</li>
<li><code>cv::dilate</code>：膨胀操作，扩大亮区域。</li>
</ul>
<p>通过组合这些函数，可以实现图像去噪、边缘检测等形态学操作。</p>

</details>
<hr />
<h3 id="高级形态学操作">高级形态学操作</h3>
<h4 id="开运算-opening">开运算 (Opening)</h4>
<ul>
<li><strong>定义</strong>：先对图像进行腐蚀，再进行膨胀。<br />
</li>
<li><strong>公式</strong>：<br />
<span class="math display">\[
\text{dst} = \text{dilate}(\text{erode}(\text{src}, \text{element}))
\nonumber
\]</span></li>
<li><strong>用途</strong>：用于消除图像中较小的亮区域（噪点），同时保留目标的整体形状。</li>
</ul>
<h4 id="闭运算-closing">闭运算 (Closing)</h4>
<ul>
<li><strong>定义</strong>：先对图像进行膨胀，再进行腐蚀。<br />
</li>
<li><strong>公式</strong>：<br />
<span class="math display">\[
\text{dst} = \text{erode}(\text{dilate}(\text{src}, \text{element}))
\nonumber
\]</span></li>
<li><strong>用途</strong>：可填补目标区域内部的小孔洞或暗区域，使整体形态更完整。</li>
</ul>
<h4 id="形态学梯度-morphological-gradient">形态学梯度 (Morphological
Gradient)</h4>
<ul>
<li><strong>定义</strong>：计算膨胀图像与腐蚀图像之间的差值。<br />
</li>
<li><strong>公式</strong>：<br />
<span class="math display">\[
\text{dst} = \text{dilate}(\text{src}, \text{element}) -
\text{erode}(\text{src}, \text{element}) \nonumber
\]</span></li>
<li><strong>用途</strong>：突出显示图像中物体的边缘信息，有助于轮廓提取。</li>
</ul>
<h4 id="顶帽-top-hat">顶帽 (Top Hat)</h4>
<ul>
<li><strong>定义</strong>：原始图像与其开运算结果之间的差值。<br />
</li>
<li><strong>公式</strong>：<br />
<span class="math display">\[
\text{dst} = \text{src} - \text{open}(\text{src}, \text{element})
\nonumber
\]</span></li>
<li><strong>用途</strong>：用于提取图像中比周围背景亮的小区域或细节特征。</li>
</ul>
<h4 id="黑帽-black-hat">黑帽 (Black Hat)</h4>
<ul>
<li><strong>定义</strong>：闭运算结果与原始图像之间的差值。<br />
</li>
<li><strong>公式</strong>：<br />
<span class="math display">\[
\text{dst} = \text{close}(\text{src}, \text{element}) - \text{src}
\nonumber
\]</span></li>
<li><strong>用途</strong>：可检测出图像中比背景暗的小区域或细微结构。</li>
</ul>
<h4 id="击中-不击中-hit-or-miss">击中-不击中 (Hit-or-Miss)</h4>
<ul>
<li><p><strong>定义</strong>：用于在<strong>二值图像</strong>（<code>CV_8UC1</code>）中定位特定像素模式。其核心是通过两个结构元素（Structuring
Elements）分别匹配前景和背景的邻域特征，最终通过逻辑与运算确定目标位置。<br />
</p></li>
<li><p><strong>公式</strong>：<br />
<span class="math display">\[
  A \circledast B = (A \ominus B_1) \cap (A^c \ominus B_2) \nonumber
  \]</span></p>
<p>其中：</p>
<ul>
<li><span class="math inline">\(\ominus\)</span>： 腐蚀操作</li>
<li><span
class="math inline">\(B_1\)</span>：定义前景像素必须匹配的模式<br />
</li>
<li><span
class="math inline">\(B_2\)</span>：定义背景像素必须匹配的模式<br />
</li>
<li><span class="math inline">\(A^c\)</span>：输入图像 <span
class="math inline">\(A\)</span> 的补集</li>
</ul></li>
<li><p><strong>操作步骤</strong>：</p>
<ol type="1">
<li>使用 <span class="math inline">\(B_1\)</span> 对原图 <span
class="math inline">\(A\)</span> 进行腐蚀操作<br />
</li>
<li>使用 <span class="math inline">\(B_2\)</span> 对补集 <span
class="math inline">\(A^c\)</span> 进行腐蚀操作<br />
</li>
<li>将两次腐蚀结果进行逻辑与（AND）</li>
</ol></li>
</ul>
<div class="note danger no-icon"><p>OpenCV 的 <code>MORPH_HITMISS</code>
操作只需要一个结构元素，它会自动将这个结构元素应用到公式中的两个腐蚀操作
<span class="math inline">\(B_1\)</span> 和 <span
class="math inline">\(B_2\)</span>，即假设 <span
class="math inline">\(B_1 = B_2\)</span>。</p>
</div>
<p><strong>用途</strong></p>
<ul>
<li><strong>形状检测</strong>：查找符合特定结构的图案，例如角点、交叉点、细线等。</li>
<li><strong>模式匹配</strong>：用于特定形状目标的<strong>存在性检测</strong>。</li>
<li><strong>噪声去除</strong>：过滤掉与目标形状不匹配的部分，仅保留符合模板的结构。</li>
</ul>
<h4 id="形态学操作对比总结">形态学操作对比总结</h4>
<table>
<thead>
<tr class="header">
<th>操作名称</th>
<th>计算方式</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>开运算（Opening）</strong></td>
<td>先腐蚀再膨胀</td>
<td>去除小亮噪点</td>
</tr>
<tr class="even">
<td><strong>闭运算（Closing）</strong></td>
<td>先膨胀再腐蚀</td>
<td>填充暗区域小孔洞</td>
</tr>
<tr class="odd">
<td><strong>梯度（Gradient）</strong></td>
<td>膨胀 - 腐蚀</td>
<td>提取物体边缘</td>
</tr>
<tr class="even">
<td><strong>顶帽（Top Hat）</strong></td>
<td>原图 - 开运算</td>
<td>亮细节增强</td>
</tr>
<tr class="odd">
<td><strong>黑帽（Black Hat）</strong></td>
<td>闭运算 - 原图</td>
<td>暗细节增强</td>
</tr>
<tr class="even">
<td><strong>击中-不击中（Hit-or-Miss）</strong></td>
<td>形态学模式匹配</td>
<td>目标形状检测</td>
</tr>
</tbody>
</table>
<h4 id="示例代码-4">示例代码</h4>
<h5 id="开运算闭运算梯度顶帽黑帽">开运算、闭运算、梯度、顶帽、黑帽</h5>
<p>下面的 C++ 示例代码演示了如何利用 OpenCV 实现上述形态学操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat src = cv::<span class="built_in">imread</span>(<span class="string">&quot;cat.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法读取图像！请检查路径。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义3×3的矩形结构元素</span></span><br><span class="line">    cv::Mat element = cv::<span class="built_in">getStructuringElement</span>(cv::MORPH_RECT, cv::<span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形态学操作结果</span></span><br><span class="line">    cv::Mat opened, closed, gradient, tophat, blackhat, hit_miss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开运算（去噪点）</span></span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(src, opened, cv::MORPH_OPEN, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭运算（填充小孔洞）</span></span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(src, closed, cv::MORPH_CLOSE, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形态学梯度（边缘提取）</span></span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(src, gradient, cv::MORPH_GRADIENT, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶帽（提取比背景亮的区域）</span></span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(src, tophat, cv::MORPH_TOPHAT, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 黑帽（提取比背景暗的区域）</span></span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(src, blackhat, cv::MORPH_BLACKHAT, element);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, src);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;开运算&quot;</span>, opened);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;闭运算&quot;</span>, closed);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;形态学梯度&quot;</span>, gradient);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;顶帽&quot;</span>, tophat);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;黑帽&quot;</span>, blackhat);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="hit-miss">hit-miss</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图像并转为灰度图</span></span><br><span class="line">    cv::Mat img = cv::<span class="built_in">imread</span>(<span class="string">&quot;leaf.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (img.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开图像!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二值化图像</span></span><br><span class="line">    cv::Mat binary_img;</span><br><span class="line">    cv::<span class="built_in">threshold</span>(img, binary_img, <span class="number">128</span>, <span class="number">255</span>, cv::THRESH_BINARY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边缘检测 kernel</span></span><br><span class="line">    cv::Mat kernel = (cv::<span class="built_in">Mat_</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; </span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用hit-miss操作（这里我们使用morphologyEx来模拟）</span></span><br><span class="line">    cv::Mat hitmiss_img;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(binary_img, hitmiss_img, cv::MORPH_HITMISS, kernel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可视化原始图像和结果</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Original Image&quot;</span>, cv::WINDOW_NORMAL);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Hit-Miss Result&quot;</span>, cv::WINDOW_NORMAL);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, binary_img);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Hit-Miss Result&quot;</span>, hitmiss_img);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);  <span class="comment">// 等待键盘事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="形态学操作提取水平与垂直线条">形态学操作提取水平与垂直线条</h2>
<p>在图像处理中，形态学操作是<strong>提取特定形状</strong>的重要工具。</p>
<p>这里通过从乐谱图像中分离水平线（五线谱）和垂直线（音符符干）并优化边缘效果的例子，对
OpenCV 形态学操作中的膨胀、腐蚀、结构元素等进一步深入了解。</p>
<h3 id="代码示例">代码示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_wait_destroy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* winname, cv::Mat img)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">CommandLineParser <span class="title">parser</span><span class="params">(argc, argv, <span class="string">&quot;&#123;@input | music.jpg | 输入图像&#125;&quot;</span>)</span></span>;</span><br><span class="line">    Mat src = <span class="built_in">imread</span>(samples::<span class="built_in">findFile</span>(parser.<span class="built_in">get</span>&lt;String&gt;(<span class="string">&quot;@input&quot;</span>)), IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法打开或找到图像！\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;用法: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;输入图像&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示原始图像</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;src&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果原始图像不是灰度图，则转换为灰度图</span></span><br><span class="line">    Mat gray;</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">channels</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">cvtColor</span>(src, gray, COLOR_BGR2GRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        gray = src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示灰度图像</span></span><br><span class="line">    <span class="built_in">show_wait_destroy</span>(<span class="string">&quot;gray&quot;</span>, gray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对取反后的灰度图像应用自适应阈值（注意 ~ 符号）</span></span><br><span class="line">    Mat bw;</span><br><span class="line">    <span class="built_in">adaptiveThreshold</span>(~gray, bw, <span class="number">255</span>, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, <span class="number">15</span>, <span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示二值图像</span></span><br><span class="line">    <span class="built_in">show_wait_destroy</span>(<span class="string">&quot;binary&quot;</span>, bw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用于提取水平和垂直线条的图像</span></span><br><span class="line">    Mat horizontal = bw.<span class="built_in">clone</span>();</span><br><span class="line">    Mat vertical = bw.<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定水平方向的尺寸</span></span><br><span class="line">    <span class="type">int</span> horizontal_size = horizontal.cols / <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用于形态学操作提取水平线的结构元素</span></span><br><span class="line">    Mat horizontalStructure = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(horizontal_size, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用形态学操作（腐蚀后膨胀）</span></span><br><span class="line">    <span class="built_in">erode</span>(horizontal, horizontal, horizontalStructure, <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">dilate</span>(horizontal, horizontal, horizontalStructure, <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示提取出的水平线</span></span><br><span class="line">    <span class="built_in">show_wait_destroy</span>(<span class="string">&quot;horizontal&quot;</span>, horizontal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定垂直方向的尺寸</span></span><br><span class="line">    <span class="type">int</span> vertical_size = vertical.rows / <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用于形态学操作提取垂直线的结构元素</span></span><br><span class="line">    Mat verticalStructure = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">1</span>, vertical_size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用形态学操作（腐蚀后膨胀）</span></span><br><span class="line">    <span class="built_in">erode</span>(vertical, vertical, verticalStructure, <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">dilate</span>(vertical, vertical, verticalStructure, <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示提取出的垂直线</span></span><br><span class="line">    <span class="built_in">show_wait_destroy</span>(<span class="string">&quot;vertical&quot;</span>, vertical);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对垂直图像进行反色操作</span></span><br><span class="line">    <span class="built_in">bitwise_not</span>(vertical, vertical);</span><br><span class="line">    <span class="built_in">show_wait_destroy</span>(<span class="string">&quot;vertical_bit&quot;</span>, vertical);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据逻辑提取边缘并平滑图像</span></span><br><span class="line">    <span class="comment">// 1. 提取边缘</span></span><br><span class="line">    <span class="comment">// 2. 膨胀边缘</span></span><br><span class="line">    <span class="comment">// 3. 将原图复制到平滑图像中</span></span><br><span class="line">    <span class="comment">// 4. 对平滑图像进行模糊处理</span></span><br><span class="line">    <span class="comment">// 5. 用平滑图像替换边缘区域的原图</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：提取边缘</span></span><br><span class="line">    Mat edges;</span><br><span class="line">    <span class="built_in">adaptiveThreshold</span>(vertical, edges, <span class="number">255</span>, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, <span class="number">3</span>, <span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">show_wait_destroy</span>(<span class="string">&quot;edges&quot;</span>, edges);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：膨胀边缘</span></span><br><span class="line">    Mat kernel = Mat::<span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">2</span>, CV_8UC1);</span><br><span class="line">    <span class="built_in">dilate</span>(edges, edges, kernel);</span><br><span class="line">    <span class="built_in">show_wait_destroy</span>(<span class="string">&quot;dilate&quot;</span>, edges);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：将原图复制到平滑图像中</span></span><br><span class="line">    Mat smooth;</span><br><span class="line">    vertical.<span class="built_in">copyTo</span>(smooth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：对平滑图像进行模糊处理</span></span><br><span class="line">    <span class="built_in">blur</span>(smooth, smooth, <span class="built_in">Size</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第五步：用平滑图像替换边缘区域的原图</span></span><br><span class="line">    smooth.<span class="built_in">copyTo</span>(vertical, edges);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示最终结果</span></span><br><span class="line">    <span class="built_in">show_wait_destroy</span>(<span class="string">&quot;smooth - final&quot;</span>, vertical);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_wait_destroy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* winname, cv::Mat img)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">imshow</span>(winname, img);</span><br><span class="line">    <span class="built_in">moveWindow</span>(winname, <span class="number">500</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyWindow</span>(winname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure>
<img src="music.png" alt="result" />
<figcaption aria-hidden="true">result</figcaption>
</figure>
<p><strong>结果分析</strong></p>
<ul>
<li><strong>水平线提取</strong>：五线谱的横线被完整保留，音符等小物体被移除；</li>
<li><strong>垂直线提取</strong>：音符符干和乐谱小节线被分离，经优化后边缘更平滑；</li>
<li><strong>应用场景</strong>：此方法可用于乐谱数字化、表格检测等需要分离规则结构的任务。</li>
</ul>
<h3 id="相关补充">相关补充</h3>
<h4 id="cvadaptivethreshold"><code>cv::adaptiveThreshold</code></h4>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::adaptiveThreshold</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray src,       <span class="comment">// 输入图像，必须是8位单通道图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray dst,      <span class="comment">// 输出图像，与输入图像大小相同</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> maxValue,      <span class="comment">// 当像素值满足条件时赋予的最大值（通常为255）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> adaptiveMethod,   <span class="comment">// 自适应方法</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> thresholdType,    <span class="comment">// 阈值类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> blockSize,        <span class="comment">// 邻域区域大小（必须为奇数），用来计算局部阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> C              <span class="comment">// 从计算出的局部阈值中减去的常数，用于微调</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数解释</strong></p>
<ul>
<li><strong>src</strong>：输入图像，要求是灰度图（8位单通道）。</li>
<li><strong>dst</strong>：输出图像，二值化后的图像，大小和输入图像相同。</li>
<li><strong>maxValue</strong>：当像素满足阈值条件时赋予的值，通常设置为255。</li>
<li><strong>adaptiveMethod</strong>：
<ul>
<li><code>ADAPTIVE_THRESH_MEAN_C</code>：使用邻域内像素的均值作为阈值。</li>
<li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：使用邻域内像素的高斯加权和作为阈值，这样会使得靠近中心的像素权重更大。</li>
</ul></li>
<li><strong>thresholdType</strong>：
<ul>
<li><code>THRESH_BINARY</code>：如果像素值大于局部阈值则赋值为
<code>maxValue</code>，否则赋值为0。</li>
<li><code>THRESH_BINARY_INV</code>：与 THRESH_BINARY
相反，即小于局部阈值赋值为 <code>maxValue</code>，大于则赋值为0。</li>
</ul></li>
<li><strong>blockSize</strong>：定义计算局部阈值时所考虑的邻域区域的尺寸（宽度和高度相同），必须为奇数（例如3、5、7...）。</li>
<li><strong>C</strong>：一个常数，会从计算出的局部阈值中减去，用于调整阈值的效果。正值会使阈值更低，负值则相反。</li>
</ul>
<h4 id="cvmatcopyto"><code>cv::Mat::copyTo</code></h4>
<p>在 OpenCV 中，<code>cv::Mat::copyTo</code>
有多个重载版本，其中一个带有掩码（mask）的版本，其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> cv::Mat::<span class="built_in">copyTo</span>(OutputArray dst, InputArray mask) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参数</strong>：
<ul>
<li><strong>OutputArray
dst</strong>：目标矩阵，用来存放复制后的结果。</li>
<li><strong>InputArray mask</strong>：掩码矩阵，通常是一个 8
位单通道（CV_8UC1）的图像。掩码中非零值的位置表示对应源图像中的像素会被复制到目标图像中；零值位置则不会发生复制操作。</li>
</ul></li>
</ul>
<hr />
<h2 id="图像金字塔">图像金字塔</h2>
<p>图像金字塔是计算机视觉中用于多尺度分析的重要工具，其核心思想是通过
<strong>下采样</strong> 与 <strong>上采样</strong>
生成不同分辨率的图像序列。OpenCV提供了高斯金字塔（Gaussian
Pyramid）和拉普拉斯金字塔（Laplacian Pyramid）两种实现方式。</p>
<h3 id="高斯金字塔">高斯金字塔</h3>
<p><strong>下采样（Downsampling）</strong><br />
i. 对图像进行高斯卷积核滤波，核矩阵为：<br />
<span class="math display">\[
\frac{1}{256}\begin{bmatrix}
1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \\
4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \\
6 &amp; 24 &amp; 36 &amp; 24 &amp; 6 \\
4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \\
1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \\
\end{bmatrix} \nonumber
\]</span><br />
ii. 去除偶数行和偶数列，得到尺寸为原图1/4的新图像。<br />
iii. 重复上述步骤生成金字塔各层。</p>
<p><strong>上采样（Upsampling）</strong><br />
i. 将图像尺寸扩大两倍，新增行列填充零。<br />
ii. 使用相同的高斯核（乘以4）进行卷积，近似补全缺失像素值。</p>
<h4 id="示例代码-5">示例代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* window_name = <span class="string">&quot;Pyramids Demo&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = argc &gt;=<span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">&quot;chicky_512.png&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载图像</span></span><br><span class="line">    cv::Mat src = cv::<span class="built_in">imread</span>(cv::samples::<span class="built_in">findFile</span>(filename));</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">printf</span>(<span class="string">&quot;Error opening image\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口并循环处理用户输入</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(window_name);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_name, src);</span><br><span class="line">        <span class="type">char</span> c = (<span class="type">char</span>)cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">27</span>) &#123; <span class="comment">// ESC键退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;i&#x27;</span>) &#123; <span class="comment">// 上采样</span></span><br><span class="line">            <span class="comment">// 多次上采样会导致图像模糊，因插值过程无法恢复原始高频信息</span></span><br><span class="line">            cv::<span class="built_in">pyrUp</span>(src, src, cv::<span class="built_in">Size</span>(src.cols*<span class="number">2</span>, src.rows*<span class="number">2</span>));</span><br><span class="line">            std::<span class="built_in">printf</span>(<span class="string">&quot;** Zoom In: Image x2 \n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;o&#x27;</span>) &#123; <span class="comment">// 下采样</span></span><br><span class="line">            cv::<span class="built_in">pyrDown</span>(src, src, cv::<span class="built_in">Size</span>(src.cols/<span class="number">2</span>, src.rows/<span class="number">2</span>));</span><br><span class="line">            std::<span class="built_in">printf</span>(<span class="string">&quot;** Zoom Out: Image /2 \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<ul>
<li><strong>下采样示例</strong>：对 512×512 图像连续两次下采样，得到
128×128 图像，细节信息逐步丢失。<br />
</li>
<li><strong>上采样示例</strong>：对下采样后的图像上采样，分辨率恢复但清晰度下降，体现金字塔重建的局限性。</li>
</ul>
<h3 id="拉普拉斯金字塔">拉普拉斯金字塔</h3>
<p>拉普拉斯金字塔（Laplacian
Pyramid）是高斯金字塔的补充，用于<strong>保存图像在不同尺度下的细节信息</strong>，从而实现高精度的图像重建。其核心思想是：通过高斯金字塔的下采样与上采样过程，计算相邻层之间的差异，从而捕捉高频细节。</p>
<h4 id="与高斯金字塔的对应关系">与高斯金字塔的对应关系</h4>
<ol type="1">
<li><strong>生成方式</strong>
<ul>
<li><strong>高斯金字塔</strong>：通过逐层下采样生成低分辨率图像序列。<br />
</li>
<li><strong>拉普拉斯金字塔</strong>：通过以下步骤生成：
<ul>
<li>对高斯金字塔的某一层 <span class="math inline">\(G_{i+1}\)</span>
进行上采样（使用 <code>cv::pyrUp</code>），得到近似的高分辨率图像 <span
class="math inline">\(\tilde{G}_i\)</span>。<br />
</li>
<li>计算高斯金字塔原层 <span class="math inline">\(G_i\)</span>
与上采样后的近似层 <span class="math inline">\(\tilde{G}_i\)</span>
的差值：<span class="math inline">\(L_i = G_i -
\tilde{G}_i\)</span></li>
<li>$ L_i $
即为拉普拉斯金字塔的当前层，保存了下采样过程中丢失的高频细节。</li>
</ul></li>
</ul></li>
<li><strong>数学意义</strong>
<ul>
<li>拉普拉斯金字塔的每一层 <span class="math inline">\(L_i\)</span>
记录了高斯金字塔相邻层之间的残差信息。<br />
</li>
<li>通过拉普拉斯金字塔，可以从最低分辨率的高斯层 <span
class="math inline">\(G_n\)</span> 逐步向上恢复原始图像：<span
class="math inline">\(G_{i} = \tilde{G}_i + L_i\)</span>.</li>
<li>这一特性在图像融合、压缩和超分辨率重建中至关重要。</li>
</ul></li>
</ol>
<p>用一张图来说明图像金字塔 <img src="图像金字塔.svg"
alt="图像金字塔" /></p>
<p>图中拉普拉斯金字塔中的图像实际上对比度很低，所以这里通过
<a href="#Gamma">Gamma 校正</a>
使得对比度提高了一些，看的时候方便一些。</p>
<h4 id="示例代码-6">示例代码</h4>
<p>以下代码展示了上图的产生过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">saveGammaImg</span><span class="params">(cv::String name, cv::Mat&amp; img)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat src = cv::<span class="built_in">imread</span>(<span class="string">&quot;oiiai.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Could not load image!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat down1, down2, down3, down4, up1, up2, up3, up4;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">pyrDown</span>(src, down1, cv::<span class="built_in">Size</span>(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>));</span><br><span class="line">    cv::<span class="built_in">pyrUp</span>(down1, up1, src.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">pyrDown</span>(down1, down2, cv::<span class="built_in">Size</span>(down<span class="number">1.</span>cols / <span class="number">2</span>, down<span class="number">1.</span>rows / <span class="number">2</span>));</span><br><span class="line">    cv::<span class="built_in">pyrUp</span>(down2, up2, down<span class="number">1.</span><span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">pyrDown</span>(down2, down3, cv::<span class="built_in">Size</span>(down<span class="number">2.</span>cols / <span class="number">2</span>, down<span class="number">2.</span>rows / <span class="number">2</span>));</span><br><span class="line">    cv::<span class="built_in">pyrUp</span>(down3, up3, down<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">pyrDown</span>(down3, down4, cv::<span class="built_in">Size</span>(down<span class="number">3.</span>cols / <span class="number">2</span>, down<span class="number">3.</span>rows / <span class="number">2</span>));</span><br><span class="line">    cv::<span class="built_in">pyrUp</span>(down4, up4, down<span class="number">3.</span><span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cv::Mat L1 = src - up1;</span><br><span class="line">    cv::Mat L2 = down1 - up2;</span><br><span class="line">    cv::Mat L3 = down2 - up3;</span><br><span class="line">    cv::Mat L4 = down3 - up4;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/down1.jpg&quot;</span>, down1);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/up1.jpg&quot;</span>, up1);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/L1.jpg&quot;</span>, L1);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/down2.jpg&quot;</span>, down2);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/up2.jpg&quot;</span>, up2);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/L2.jpg&quot;</span>, L2);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/down3.jpg&quot;</span>, down3);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/up3.jpg&quot;</span>, up3);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/L3.jpg&quot;</span>, L3);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/down4.jpg&quot;</span>, down4);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/up4.jpg&quot;</span>, up4);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;oiiai/L4.jpg&quot;</span>, L4);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::String&gt; stringSeed = &#123;<span class="string">&quot;oiiai/L1&quot;</span>, <span class="string">&quot;oiiai/L2&quot;</span>, <span class="string">&quot;oiiai/L3&quot;</span>, <span class="string">&quot;oiiai/L4&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; name : stringSeed) &#123;</span><br><span class="line">        cv::Mat img = cv::<span class="built_in">imread</span>(name + <span class="string">&quot;.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">        <span class="keyword">if</span> (img.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error: Could not load image &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;.jpg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">saveGammaImg</span>(name, img);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">saveGammaImg</span><span class="params">(cv::String name, cv::Mat&amp; img)</span> </span>&#123;</span><br><span class="line">    cv::Mat gamma_corrected;</span><br><span class="line">    img.<span class="built_in">convertTo</span>(gamma_corrected, CV_32F, <span class="number">1.0</span> / <span class="number">255.0</span>);</span><br><span class="line">    cv::<span class="built_in">pow</span>(gamma_corrected, <span class="number">0.5</span>, gamma_corrected);</span><br><span class="line">    gamma_corrected *= <span class="number">255</span>;</span><br><span class="line">    gamma_corrected.<span class="built_in">convertTo</span>(gamma_corrected, CV_8U);</span><br><span class="line"></span><br><span class="line">    name += <span class="string">&quot;_gamma.jpg&quot;</span>;</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(name, gamma_corrected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>高斯下采样</strong>：使用 <code>cv::pyrDown</code>
对原始图像下采样，得到低分辨率的高斯层。<br />
<strong>高斯上采样</strong>：对下采样后的高斯层使用
<code>cv::pyrUp</code> 上采样至原图尺寸。<br />
<strong>残差计算</strong>：将上采样后的图像与原图相减，得到拉普拉斯金字塔层。<br />
<strong>结果分析</strong>：拉普拉斯层中亮区域表示高频细节（如边缘、纹理），暗区域表示低频信息已被高斯金字塔保留。</p>
<h4 id="应用场景">应用场景</h4>
<ol type="1">
<li><strong>图像融合</strong>
<ul>
<li>在融合不同曝光的图像时，拉普拉斯金字塔可分别保留各层细节，融合后重建出高质量图像。<br />
</li>
<li>例如：将两张图像的拉普拉斯金字塔逐层融合，再通过逆过程重建结果。</li>
</ul></li>
<li><strong>图像压缩</strong>
<ul>
<li>存储拉普拉斯金字塔的残差信息（稀疏矩阵）比直接存储原图更高效。<br />
</li>
<li>结合量化技术，可实现高压缩率且保留关键细节。</li>
</ul></li>
<li><strong>图像增强</strong>
<ul>
<li>通过增强拉普拉斯层的高频分量（如边缘锐化），再重建图像以提升清晰度。</li>
</ul></li>
</ol>
<h3 id="总结-1">总结</h3>
<p>拉普拉斯金字塔与高斯金字塔共同构成了多尺度图像分析的基础。前者通过残差捕捉细节，后者通过下采样简化结构。在
OpenCV 中，虽然未直接提供拉普拉斯金字塔的函数，但通过组合
<code>cv::pyrUp</code>、<code>cv::pyrDown</code>
和矩阵运算即可实现其功能。理解二者的协同作用，将为图像处理任务（如超分辨率、图像融合）提供重要的技术支撑。</p>
<hr />
<h2 id="基本阈值操作">基本阈值操作</h2>
<h3 id="阈值处理基础">阈值处理基础</h3>
<p>阈值处理是图像分割中最简单的方法之一，其核心思想是通过比较像素强度与阈值来区分目标区域与背景。OpenCV
提供的 <code>cv::threshold</code>
s函数支持五种阈值操作类型，可将图像转换为二值化或特定处理后的形式。</p>
<h3 id="基本阈值操作类型">基本阈值操作类型</h3>
<h4 id="二值化阈值binary-threshold">二值化阈值（Binary Threshold）</h4>
<p><span class="math display">\[
dst(x, y) =
\begin{cases}
\max{Val} &amp; \text{if } src(x, y) &gt; \text{thresh} \\
0 &amp; \text{otherwise}
\end{cases} \nonumber
\]</span> 当像素强度超过阈值时设为最大值（如255），否则设为0。</p>
<h4 id="反向二值化阈值binary-inverted">反向二值化阈值（Binary
Inverted）</h4>
<p><span class="math display">\[
dst(x,y) =
\begin{cases}
0 &amp; \text{if } src(x,y) &gt; \text{thresh} \\
\max{Val} &amp; \text{otherwise}
\end{cases} \nonumber
\]</span> 与二值化阈值相反，超过阈值的像素设为0，其余设为最大值。</p>
<h4 id="截断阈值truncate">截断阈值（Truncate）</h4>
<p><span class="math display">\[
dst(x,y) =
\begin{cases}
\text{thresh} &amp; \text{if } src(x,y) &gt; \text{thresh} \\
src(x,y) &amp; \text{otherwise}
\end{cases} \nonumber
\]</span> 超过阈值的像素被截断为阈值，其余保持不变。</p>
<h4 id="零阈值threshold-to-zero">零阈值（Threshold to Zero）</h4>
<p><span class="math display">\[
dst(x,y) =
\begin{cases}
src(x,y) &amp; \text{if } src(x,y) &gt; \text{thresh} \\
0 &amp; \text{otherwise}
\end{cases} \nonumber
\]</span> 低于阈值的像素设为0，其余保留原值。</p>
<h4 id="反向零阈值threshold-to-zero-inverted">反向零阈值（Threshold to
Zero Inverted）</h4>
<p><span class="math display">\[
dst(x,y) =
\begin{cases}
0 &amp; \text{if } src(x,y) &gt; \text{thresh} \\
src(x,y) &amp; \text{otherwise}
\end{cases} \nonumber
\]</span> 超过阈值的像素设为0，其余保留原值。</p>
<hr />
<h3 id="代码实现与解析">代码实现与解析</h3>
<p>以下是一个完整的阈值处理示例代码，支持通过滑动条动态调整参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgcodecs.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> threshold_value = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> threshold_type = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_value = <span class="number">255</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_type = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_binary_value = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">Mat src, src_gray, dst;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* window_name = <span class="string">&quot;Threshold Demo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动条回调函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Threshold_Demo</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">threshold</span>(src_gray, dst, threshold_value, max_binary_value, threshold_type);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(window_name, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">imageName</span><span class="params">(<span class="string">&quot;iamge.png&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) imageName = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取并转换图像为灰度图</span></span><br><span class="line">    src = cv::<span class="built_in">imread</span>(cv::samples::<span class="built_in">findFile</span>(imageName), cv::IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法读取图像: &quot;</span> &lt;&lt; imageName &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(src, src_gray, cv::COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口和滑动条</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(window_name, cv::WINDOW_AUTOSIZE);</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;type&quot;</span>, window_name, &amp;threshold_type, max_type, Threshold_Demo);</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;size&quot;</span>, window_name, &amp;threshold_value, max_value, Threshold_Demo);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Threshold_Demo</span>(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 初始化</span></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2">总结</h3>
<p>阈值处理是OpenCV中基础的图像分割技术，适用于目标检测、背景分离等场景。通过灵活选择阈值类型和参数，开发者可以快速实现不同需求的分割效果。</p>
<hr />
<h2 id="hsv-通道的阈值操作">HSV 通道的阈值操作</h2>
<h3 id="理论基础-1">理论基础</h3>
<p>与传统的<code>cv::threshold</code>函数不同，<code>cv::inRange</code>允许通过设定像素值的上下限范围来提取目标区域。HSV（Hue,
Saturation,
Value）颜色空间因其色相（Hue）通道能独立表示颜色类型，常用于基于颜色的图像分割任务：</p>
<ul>
<li><strong>Hue（色相）</strong>：表示颜色类型，范围为0-180（OpenCV中常将0-360度映射到此范围）。<br />
</li>
<li><strong>Saturation（饱和度）</strong>：从灰度（低饱和度）到纯色（高饱和度）。<br />
</li>
<li><strong>Value（明度）</strong>：表示颜色亮度。</li>
</ul>
<p>颜色空间转换公式（RGB 到 HSV）可通过 <code>cv::cvtColor</code>
实现，具体计算遵循标准转换规则： <span class="math display">\[
\begin{align*}
H &amp;= \text{arctan2}(\sqrt{3}(G - B), 2R - G - B) \\\\
S &amp;= \frac{\max(R, G, B) - \min(R, G, B)}{\max(R, G, B)} \\\\
V &amp;= \max(R, G, B)\\
\end{align*}
\]</span></p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="RGB Space.png" alt="RGB Space" width="80" height="80" loading="lazy"/></div><div class="group-picture-column"><img src="HSV Space.png" alt="HSV Space" width="80" height="80" loading="lazy"/></div></div></div>
<h3 id="代码实现-1">代码实现</h3>
<p>以下示例演示如何通过实时视频流进行阈值分割：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/videoio.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_value_H = <span class="number">180</span>;  <span class="comment">// Hue范围映射为0-180</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_value = <span class="number">255</span>;</span><br><span class="line"><span class="type">const</span> String window_capture_name = <span class="string">&quot;Video Capture&quot;</span>;</span><br><span class="line"><span class="type">const</span> String window_detection_name = <span class="string">&quot;Object Detection&quot;</span>;</span><br><span class="line"><span class="type">int</span> low_H = <span class="number">0</span>, low_S = <span class="number">0</span>, low_V = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> high_H = max_value_H, high_S = max_value, high_V = max_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trackbar回调函数，确保阈值范围合法</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on_low_H_thresh_trackbar</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    low_H = std::<span class="built_in">min</span>(high_H - <span class="number">1</span>, low_H);</span><br><span class="line">    cv::<span class="built_in">setTrackbarPos</span>(<span class="string">&quot;Low H&quot;</span>, window_detection_name, low_H);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on_high_H_thresh_trackbar</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    high_H = std::<span class="built_in">max</span>(high_H, low_H + <span class="number">1</span>);</span><br><span class="line">    cv::<span class="built_in">setTrackbarPos</span>(<span class="string">&quot;High H&quot;</span>, window_detection_name, high_H);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on_low_S_thresh_trackbar</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    low_S = std::<span class="built_in">min</span>(high_S - <span class="number">1</span>, low_S);</span><br><span class="line">    cv::<span class="built_in">setTrackbarPos</span>(<span class="string">&quot;Low S&quot;</span>, window_detection_name, low_S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on_high_S_thresh_trackbar</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    high_S = std::<span class="built_in">max</span>(high_S, low_S + <span class="number">1</span>);</span><br><span class="line">    cv::<span class="built_in">setTrackbarPos</span>(<span class="string">&quot;High S&quot;</span>, window_detection_name, high_S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on_low_V_thresh_trackbar</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    low_V = std::<span class="built_in">min</span>(high_V - <span class="number">1</span>, low_V);</span><br><span class="line">    cv::<span class="built_in">setTrackbarPos</span>(<span class="string">&quot;Low V&quot;</span>, window_detection_name, low_V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on_high_V_thresh_trackbar</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    high_V = std::<span class="built_in">max</span>(high_V, low_V + <span class="number">1</span>);</span><br><span class="line">    cv::<span class="built_in">setTrackbarPos</span>(<span class="string">&quot;High V&quot;</span>, window_detection_name, high_V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 捕获摄像头画面 或 视频文件</span></span><br><span class="line">    cv::VideoCapture cap;</span><br><span class="line">    cap.<span class="built_in">open</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!cap.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Unable to open video capture!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建显示窗口</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(window_capture_name);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(window_detection_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建HSV阈值调节Trackbar</span></span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;Low H&quot;</span>, window_detection_name, &amp;low_H, max_value_H, on_low_H_thresh_trackbar);</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;High H&quot;</span>, window_detection_name, &amp;high_H, max_value_H, on_high_H_thresh_trackbar);</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;Low S&quot;</span>, window_detection_name, &amp;low_S, max_value, on_low_S_thresh_trackbar);</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;High S&quot;</span>, window_detection_name, &amp;high_S, max_value, on_high_S_thresh_trackbar);</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;Low V&quot;</span>, window_detection_name, &amp;low_V, max_value, on_low_V_thresh_trackbar);</span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;High V&quot;</span>, window_detection_name, &amp;high_V, max_value, on_high_V_thresh_trackbar);</span><br><span class="line"></span><br><span class="line">    cv::Mat frame, frame_HSV, frame_threshold;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 捕获视频帧</span></span><br><span class="line">        cap &gt;&gt; frame;</span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error: Captured frame is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换到HSV颜色空间</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(frame, frame_HSV, cv::COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用阈值分割</span></span><br><span class="line">        cv::<span class="built_in">inRange</span>(frame_HSV, cv::<span class="built_in">Scalar</span>(low_H, low_S, low_V), cv::<span class="built_in">Scalar</span>(high_H, high_S, high_V), frame_threshold);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示结果</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_capture_name, frame);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(window_detection_name, frame_threshold);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按&#x27;q&#x27;或&#x27;ESC&#x27;键退出</span></span><br><span class="line">        <span class="type">char</span> key = (<span class="type">char</span>)cv::<span class="built_in">waitKey</span>(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="string">&#x27;q&#x27;</span> || key == <span class="number">27</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="低hlow-h"><strong>1. 低H（Low H）</strong></h4>
<ul>
<li><strong>作用</strong>：设置 <strong>色相（Hue）</strong> 的
<strong>最低阈值</strong>。</li>
<li><strong>范围</strong>：0-180（OpenCV中Hue范围为0-180，而非0-360）。</li>
<li><strong>功能</strong>：<br />
通过滑动条调整，选择目标颜色的起始色相值。例如，若要检测红色（Hue约0-10或160-180），可将
<code>Low H</code> 设为0或160。</li>
</ul>
<h4 id="高hhigh-h"><strong>2. 高H（High H）</strong></h4>
<ul>
<li><strong>作用</strong>：设置 <strong>色相（Hue）</strong> 的
<strong>最高阈值</strong>。</li>
<li><strong>范围</strong>：0-180。</li>
<li><strong>功能</strong>：<br />
定义目标颜色的终止色相值。例如，检测红色时，若
<code>Low H=160</code>，则 <code>High H=180</code>
可覆盖红色的色相范围。</li>
</ul>
<h4 id="低slow-s"><strong>3. 低S（Low S）</strong></h4>
<ul>
<li><strong>作用</strong>：设置 <strong>饱和度（Saturation）</strong> 的
<strong>最低阈值</strong>。</li>
<li><strong>范围</strong>：0-255。</li>
<li><strong>功能</strong>：<br />
饱和度表示颜色的纯度。低饱和度接近灰色，高饱和度接近纯色。<br />
通过提高 <code>Low S</code>，可过滤掉灰度区域（如阴影或白色背景）。</li>
</ul>
<h4 id="高shigh-s"><strong>4. 高S（High S）</strong></h4>
<ul>
<li><strong>作用</strong>：设置 <strong>饱和度（Saturation）</strong> 的
<strong>最高阈值</strong>。</li>
<li><strong>范围</strong>：0-255。</li>
<li><strong>功能</strong>：<br />
限制颜色的最大饱和度。通常保持
<code>High S=255</code>，表示允许所有高饱和度颜色参与检测。</li>
</ul>
<h4 id="低vlow-v"><strong>5. 低V（Low V）</strong></h4>
<ul>
<li><strong>作用</strong>：设置 <strong>明度（Value）</strong> 的
<strong>最低阈值</strong>。</li>
<li><strong>范围</strong>：0-255。</li>
<li><strong>功能</strong>：<br />
明度表示颜色亮度。通过调整
<code>Low V</code>，可过滤掉过暗区域。例如，<code>Low V=50</code>
会排除亮度低于50的像素。</li>
</ul>
<h4 id="高vhigh-v"><strong>6. 高V（High V）</strong></h4>
<ul>
<li><strong>作用</strong>：设置 <strong>明度（Value）</strong> 的
<strong>最高阈值</strong>。</li>
<li><strong>范围</strong>：0-255。</li>
<li><strong>功能</strong>：<br />
限制颜色的最大亮度。通常保持
<code>High V=255</code>，允许所有亮度区域参与检测。</li>
</ul>
<h3 id="运行结果">运行结果</h3>
<p>程序运行后，两个窗口分别显示原始视频和阈值处理后的二值图像。通过调节滑动条可实时观察不同阈值范围对检测效果的影响，适用于动态环境下的颜色目标跟踪。</p>
<hr />
<h2 id="参考资料">参考资料</h2>
<p><strong>[1]</strong> <a
href="https://docs.opencv.org/4.x/d7/da8/tutorial_table_of_content_imgproc.html">OpenCV
官方文档</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV入门学习-核心功能（二）</title>
    <url>/2025/01/27/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<a href="/2025/01/24/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/" title="OpenCV入门学习-核心功能（一）">OpenCV入门学习-核心功能（一）</a>
<hr />
<h2 id="调整图像的对比度和亮度">1. 调整图像的对比度和亮度</h2>
<p>OpenCV
是计算机视觉领域的重要工具，本节将介绍如何使用像素变换调整图像的亮度和对比度，并通过
Gamma 校正优化图像质量。</p>
<h3 id="理论基础">1.1. 理论基础</h3>
<p>图像处理中的<strong>像素变换</strong>指输出像素仅依赖输入像素值的操作。调整亮度与对比度的公式为：<br />
<span class="math display">\[\nonumber g(i,j) = \alpha \cdot f(i,j) +
\beta\]</span></p>
<ul>
<li><strong>α（增益）</strong>：控制对比度（建议范围：<span
class="math inline">\(1.0-3.0\)</span>）。<br />
</li>
<li><strong>β（偏置）</strong>：控制亮度（建议范围：<span
class="math inline">\(0-100\)</span>）。</li>
</ul>
<p>通过 <code>cv::saturate_cast&lt;uchar&gt;</code> 确保计算结果在 <span
class="math inline">\(0-255\)</span> 范围内，避免数值溢出。</p>
<h3 id="代码实现">1.2. 代码实现</h3>
<h4 id="核心代码示例">1.2.1. 核心代码示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;lena.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load image!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化输出图像</span></span><br><span class="line">    cv::Mat new_image = cv::Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> alpha = <span class="number">1.0</span>; <span class="comment">// 对比度参数</span></span><br><span class="line">    <span class="type">int</span> beta = <span class="number">0</span>;       <span class="comment">// 亮度参数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter double alpha [1.0-3.0]: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; alpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter int beta [0-100]: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; beta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每个像素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; image.rows; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; image.cols; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; image.<span class="built_in">channels</span>(); c++) &#123;</span><br><span class="line">                new_image.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(y, x)[c] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(</span><br><span class="line">                    alpha * image.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(y, x)[c] + beta</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Adjusted&quot;</span>, new_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码说明">1.2.2. 代码说明</h4>
<ol type="1">
<li><p><strong>像素遍历</strong>：通过三重循环访问每个像素的 BGR
通道。<br />
</p></li>
<li><p><strong>数值饱和处理</strong>：<code>cv::saturate_cast&lt;uchar&gt;</code>
确保结果在合理范围内。<br />
</p></li>
<li><p><strong>高效替代方案</strong>：可使用
<code>cv::Mat::convertTo</code> 替代循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">image.<span class="built_in">convertTo</span>(new_image, <span class="number">-1</span>, alpha, beta);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="实际应用示例">1.3. 实际应用示例</h3>
<p>调整 <code>α=2.2</code> 和 <code>β=50</code>
可显著提升暗图像的亮度，但可能导致高光区域过曝（如云层细节丢失）。此时可结合
Gamma 校正优化。</p>
<h3 id="gamma-校正">1.4. Gamma 校正 <span id="Gamma"></span></h3>
<p>Gamma 校正通过非线性变换调整亮度：<br />
<span class="math display">\[\nonumber O = \left( \frac{I}{255}
\right)^\gamma \times 255\]</span></p>
<ul>
<li><strong>γ &lt; 1</strong>：提升暗部亮度。<br />
</li>
<li><strong>γ &gt; 1</strong>：增强亮部对比度。</li>
</ul>
<span id="fig1"></span>
<figure>
<img src="io_gamma.svg" alt="io_gamma" loading="lazy"/>
<figcaption>
图1.不同 <span class="math inline">\(\gamma\)</span> 值对应的图像
</figcaption>
</figure>
<h4 id="实现代码">1.4.1. 实现代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建查找表</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">lookupTable</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line">uchar* p = lookupTable.<span class="built_in">ptr</span>();</span><br><span class="line"><span class="type">double</span> gamma = <span class="number">0.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 四舍五入，饱和时截断</span></span><br><span class="line">    p[i] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(<span class="built_in">pow</span>(i / <span class="number">255.0</span>, gamma) * <span class="number">255.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 Gamma 校正</span></span><br><span class="line">cv::Mat corrected;</span><br><span class="line">cv::<span class="built_in">LUT</span>(image, lookupTable, corrected);</span><br></pre></td></tr></table></figure>
<p><a href="/2025/01/24/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/#ch2">查找表 LUT</a></p>
<h3 id="性能优化提示">1.5. 性能优化提示</h3>
<ul>
<li><strong>避免逐像素操作</strong>：优先使用内置函数（如
<code>cv::convertTo</code> 和 <code>cv::LUT</code> ）。<br />
</li>
<li><strong>预计算查找表</strong>：减少重复计算，提升 Gamma
校正效率。</li>
</ul>
<p>通过调整 <span class="math inline">\(\alpha\)</span>、<span
class="math inline">\(\beta\)</span> 和 <span
class="math inline">\(\gamma\)</span>
值，可灵活控制图像效果。这些方法虽基础，但能为复杂图像处理任务奠定基础。</p>
<hr />
<h2 id="离散傅里叶变换">2. 离散傅里叶变换</h2>
<h3 id="什么是离散傅里叶变换">2.1. 什么是离散傅里叶变换？</h3>
<p>离散傅里叶变换（DFT）是一种将图像从空间域转换到频率域的数学工具。通过分解图像的正弦和余弦分量，DFT
可以帮助我们分析图像中的几何结构特征。其数学表达式为：<br />
<span class="math display">\[
F(k, l) = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1}
f(i,j)e^{-i2\pi\left(\frac{jk}{N}+\frac{ik}{N}\right)} \nonumber  
\]</span> 其中，复数结果可表示为：<br />
<span class="math display">\[  
e^{ix} = \cos x + i\sin x \nonumber  
\]</span></p>
<h3 id="opencv-实现-dft-的关键步骤">2.2. OpenCV 实现 DFT 的关键步骤</h3>
<h4 id="扩展图像至最佳尺寸">2.2.1. 扩展图像至最佳尺寸</h4>
<p>DFT 的计算效率与图像尺寸相关，最佳尺寸通常是 2、3、5 的倍数。通过
<code>cv::getOptimalDFTSize()</code> 获取最优尺寸，并用
<code>cv::copyMakeBorder()</code> 填充图像边界：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat padded;  </span><br><span class="line"><span class="type">int</span> rows_pad = cv::<span class="built_in">getOptimalDFTSize</span>(I.rows);  </span><br><span class="line"><span class="type">int</span> cols_pad = cv::<span class="built_in">getOptimalDFTSize</span>(I.cols);  </span><br><span class="line">cv::<span class="built_in">copyMakeBorder</span>(I, padded, <span class="number">0</span>, rows_pad - I.rows, <span class="number">0</span>, cols_pad - I.cols,  </span><br><span class="line">                   cv::BORDER_CONSTANT, cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));  </span><br></pre></td></tr></table></figure>
<h4 id="创建复数矩阵">2.2.2. 创建复数矩阵</h4>
<p>DFT 结果为复数，需将图像转换为浮点类型并合并实部与虚部：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat planes[] = &#123;  </span><br><span class="line">    cv::<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(padded),  </span><br><span class="line">    cv::Mat::<span class="built_in">zeros</span>(padded.<span class="built_in">size</span>(), CV_32F)  </span><br><span class="line">&#125;;  </span><br><span class="line">cv::Mat complexI;  </span><br><span class="line">cv::<span class="built_in">merge</span>(planes, <span class="number">2</span>, complexI);  </span><br></pre></td></tr></table></figure>
<h4 id="执行-dft-变换">2.2.3. 执行 DFT 变换</h4>
<p>使用<code>cv::dft()</code>进行傅里叶变换，支持原地计算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">dft</span>(complexI, complexI);  </span><br></pre></td></tr></table></figure>
<h4 id="计算幅度谱">2.2.4. 计算幅度谱</h4>
<p>将复数结果分解为实部和虚部，计算幅度并转为对数尺度：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">split</span>(complexI, planes);  </span><br><span class="line">cv::<span class="built_in">magnitude</span>(planes[<span class="number">0</span>], planes[<span class="number">1</span>], planes[<span class="number">0</span>]);  </span><br><span class="line">cv::Mat magI = planes[<span class="number">0</span>];  </span><br><span class="line">magI += cv::Scalar::<span class="built_in">all</span>(<span class="number">1</span>);  </span><br><span class="line">cv::<span class="built_in">log</span>(magI, magI);  </span><br></pre></td></tr></table></figure>
<h4 id="频谱中心化与归一化">2.2.5. 频谱中心化与归一化</h4>
<p>交换频谱象限使低频分量居中，并进行归一化以便显示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">magI = <span class="built_in">magI</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, magI.cols &amp; <span class="number">-2</span>, magI.rows &amp; <span class="number">-2</span>));  </span><br><span class="line"><span class="type">int</span> cx = magI.cols / <span class="number">2</span>, cy = magI.rows / <span class="number">2</span>;  </span><br><span class="line"><span class="comment">// 交换四个象限  </span></span><br><span class="line"><span class="function">cv::Mat <span class="title">q0</span><span class="params">(magI, cv::Rect(<span class="number">0</span>, <span class="number">0</span>, cx, cy))</span></span>;  </span><br><span class="line"><span class="function">cv::Mat <span class="title">q1</span><span class="params">(magI, cv::Rect(cx, <span class="number">0</span>, cx, cy))</span></span>;  </span><br><span class="line"><span class="function">cv::Mat <span class="title">q2</span><span class="params">(magI, cv::Rect(<span class="number">0</span>, cy, cx, cy))</span></span>;  </span><br><span class="line"><span class="function">cv::Mat <span class="title">q3</span><span class="params">(magI, cv::Rect(cx, cy, cx, cy))</span></span>;  </span><br><span class="line">q<span class="number">0.</span><span class="built_in">copyTo</span>(tmp); q<span class="number">3.</span><span class="built_in">copyTo</span>(q0); tmp.<span class="built_in">copyTo</span>(q3);  </span><br><span class="line">q<span class="number">1.</span><span class="built_in">copyTo</span>(tmp); q<span class="number">2.</span><span class="built_in">copyTo</span>(q1); tmp.<span class="built_in">copyTo</span>(q2);  </span><br><span class="line"><span class="comment">// 归一化到[0,1]范围  </span></span><br><span class="line">cv::<span class="built_in">normalize</span>(magI, magI, <span class="number">0</span>, <span class="number">1</span>, cv::NORM_MINMAX);  </span><br></pre></td></tr></table></figure>
<h3 id="应用场景示例">2.3. 应用场景示例</h3>
<p>通过分析频谱的亮度分布，可以检测图像中的几何方向特征。例如：</p>
<ul>
<li><strong>水平文本</strong>：频谱中会出现垂直方向的高亮线，对应文本的横向排列。<br />
</li>
<li><strong>旋转文本</strong>：高亮点会随文本旋转方向偏移，通过此偏移可计算校正角度。</li>
</ul>
<h3 id="完整代码示例">2.4. 完整代码示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取灰度图像</span></span><br><span class="line">    cv::Mat I = cv::<span class="built_in">imread</span>(<span class="string">&quot;dog.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (I.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Could not load image&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1：扩展图像至最佳DFT尺寸</span></span><br><span class="line">    cv::Mat padded;</span><br><span class="line">    <span class="type">int</span> rows_opt = cv::<span class="built_in">getOptimalDFTSize</span>(I.rows);</span><br><span class="line">    <span class="type">int</span> cols_opt = cv::<span class="built_in">getOptimalDFTSize</span>(I.cols);</span><br><span class="line">    cv::<span class="built_in">copyMakeBorder</span>(I, padded,</span><br><span class="line">        <span class="number">0</span>, rows_opt - I.rows,</span><br><span class="line">        <span class="number">0</span>, cols_opt - I.cols,</span><br><span class="line">        cv::BORDER_CONSTANT, cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：创建复数矩阵（实部+虚部）</span></span><br><span class="line">    cv::Mat planes[] = &#123;</span><br><span class="line">        cv::<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(padded),</span><br><span class="line">        cv::Mat::<span class="built_in">zeros</span>(padded.<span class="built_in">size</span>(), CV_32F)</span><br><span class="line">    &#125;;</span><br><span class="line">    cv::Mat complexI;</span><br><span class="line">    cv::<span class="built_in">merge</span>(planes, <span class="number">2</span>, complexI);  <span class="comment">// 合并为双通道矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：执行离散傅里叶变换</span></span><br><span class="line">    cv::<span class="built_in">dft</span>(complexI, complexI);  <span class="comment">// 原地计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤4：计算幅度谱</span></span><br><span class="line">    cv::<span class="built_in">split</span>(complexI, planes);  <span class="comment">// planes[0] = Re, planes[1] = Im</span></span><br><span class="line">    cv::<span class="built_in">magnitude</span>(planes[<span class="number">0</span>], planes[<span class="number">1</span>], planes[<span class="number">0</span>]);</span><br><span class="line">    cv::Mat magI = planes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤5：对数尺度转换</span></span><br><span class="line">    magI += cv::Scalar::<span class="built_in">all</span>(<span class="number">1</span>);</span><br><span class="line">    cv::<span class="built_in">log</span>(magI, magI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤6：裁剪为偶数尺寸</span></span><br><span class="line">    magI = <span class="built_in">magI</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, magI.cols &amp; <span class="number">-2</span>, magI.rows &amp; <span class="number">-2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤7：频谱中心化（交换象限）</span></span><br><span class="line">    <span class="type">int</span> cx = magI.cols / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> cy = magI.rows / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">q0</span><span class="params">(magI, cv::Rect(<span class="number">0</span>, <span class="number">0</span>, cx, cy))</span></span>;   <span class="comment">// 左上</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">q1</span><span class="params">(magI, cv::Rect(cx, <span class="number">0</span>, cx, cy))</span></span>;  <span class="comment">// 右上</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">q2</span><span class="params">(magI, cv::Rect(<span class="number">0</span>, cy, cx, cy))</span></span>;  <span class="comment">// 左下</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">q3</span><span class="params">(magI, cv::Rect(cx, cy, cx, cy))</span></span>; <span class="comment">// 右下</span></span><br><span class="line"></span><br><span class="line">    cv::Mat tmp;</span><br><span class="line">    <span class="comment">// 交换左上与右下</span></span><br><span class="line">    q<span class="number">0.</span><span class="built_in">copyTo</span>(tmp);</span><br><span class="line">    q<span class="number">3.</span><span class="built_in">copyTo</span>(q0);</span><br><span class="line">    tmp.<span class="built_in">copyTo</span>(q3);</span><br><span class="line">    <span class="comment">// 交换右上与左下</span></span><br><span class="line">    q<span class="number">1.</span><span class="built_in">copyTo</span>(tmp);</span><br><span class="line">    q<span class="number">2.</span><span class="built_in">copyTo</span>(q1);</span><br><span class="line">    tmp.<span class="built_in">copyTo</span>(q2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤8：归一化显示范围</span></span><br><span class="line">    cv::<span class="built_in">normalize</span>(magI, magI, <span class="number">0</span>, <span class="number">1</span>, cv::NORM_MINMAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, I);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Spectrum Magnitude&quot;</span>, magI);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述步骤，OpenCV
实现了从空间域到频率域的高效转换，为图像分析与增强提供了重要基础。</p>
<hr />
<h2 id="opencv-文件输入输出">3. OpenCV 文件输入输出</h2>
<p>在 OpenCV 中，文件输入输出（IO）是实现数据持久化的重要功能。通过
XML、YAML 和 JSON
格式，开发者可以方便地存储和读取配置参数、矩阵数据甚至自定义数据结构。本文将详细介绍如何利用
OpenCV 的 <code>cv::FileStorage</code> 类实现这些操作。</p>
<h3 id="文件操作基础">3.1. 文件操作基础</h3>
<p>使用 OpenCV 进行文件 IO 需借助 <code>cv::FileStorage</code>
类。其核心步骤包括<strong>打开文件</strong>、<strong>读写数据</strong>和<strong>关闭文件</strong>。以下示例展示了文件的基本操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::FileStorage <span class="title">fs</span><span class="params">(<span class="string">&quot;output.yml&quot;</span>, cv::FileStorage::WRITE)</span></span>; <span class="comment">// 打开文件（写模式）</span></span><br><span class="line"><span class="comment">// 操作代码...</span></span><br><span class="line">fs.<span class="built_in">release</span>(); <span class="comment">// 显式关闭文件</span></span><br></pre></td></tr></table></figure>
<p>文件扩展名决定输出格式（如 <code>.xml</code> 、 <code>.yml</code> 、
<code>.json</code>），还支持压缩（如 <code>.xml.gz</code>
）。读写模式包括 <code>WRITE</code> 、<code>READ</code> 和
<code>APPEND</code>。</p>
<h3 id="基本数据类型与-opencv-结构的读写">3.2. 基本数据类型与 OpenCV
结构的读写</h3>
<h4 id="文本与数字">3.2.1. 文本与数字</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入</span></span><br><span class="line">fs &lt;&lt; <span class="string">&quot;iterationNr&quot;</span> &lt;&lt; <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="type">int</span> itNr;</span><br><span class="line">fs[<span class="string">&quot;iterationNr&quot;</span>] &gt;&gt; itNr;</span><br></pre></td></tr></table></figure>
<h4 id="opencv矩阵cvmat">3.2.2. OpenCV矩阵（<code>cv::Mat</code>）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat R = cv::Mat_&lt;uchar&gt;::<span class="built_in">eye</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">cv::Mat T = cv::Mat_&lt;<span class="type">double</span>&gt;::<span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">fs &lt;&lt; <span class="string">&quot;R&quot;</span> &lt;&lt; R &lt;&lt; <span class="string">&quot;T&quot;</span> &lt;&lt; T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">fs[<span class="string">&quot;R&quot;</span>] &gt;&gt; R;</span><br><span class="line">fs[<span class="string">&quot;T&quot;</span>] &gt;&gt; T;</span><br></pre></td></tr></table></figure>
<h3 id="序列与映射的读写">3.3. 序列与映射的读写</h3>
<h4 id="序列数组">3.3.1. 序列（数组）</h4>
<p>序列用<code>[ ]</code>包裹：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入字符串序列</span></span><br><span class="line">fs &lt;&lt; <span class="string">&quot;strings&quot;</span> &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;image1.jpg&quot;</span> &lt;&lt; <span class="string">&quot;Awesomeness&quot;</span> &lt;&lt; <span class="string">&quot;../data/baboon.jpg&quot;</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">cv::FileNode node = fs[<span class="string">&quot;strings&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (node.<span class="built_in">type</span>() == cv::FileNode::SEQ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (cv::FileNodeIterator it = node.<span class="built_in">begin</span>(); it != node.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::string value = (std::string)*it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="映射字典">3.3.2. 映射（字典）</h4>
<p>映射用 <code>&#123; &#125;</code> 包裹：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入键值对</span></span><br><span class="line">fs &lt;&lt; <span class="string">&quot;Mapping&quot;</span> &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;One&quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;Two&quot;</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">cv::FileNode mapping = fs[<span class="string">&quot;Mapping&quot;</span>];</span><br><span class="line"><span class="type">int</span> one = (<span class="type">int</span>)mapping[<span class="string">&quot;One&quot;</span>];</span><br><span class="line"><span class="type">int</span> two = (<span class="type">int</span>)mapping[<span class="string">&quot;Two&quot;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="自定义数据结构的序列化">3.4. 自定义数据结构的序列化</h3>
<p>要为自定义类实现序列化，需定义 <code>write</code> 和
<code>read</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> A;</span><br><span class="line">    <span class="type">double</span> X;</span><br><span class="line">    std::string id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(cv::FileStorage&amp; fs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;&#123;&quot;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; A</span><br><span class="line">           &lt;&lt; <span class="string">&quot;X&quot;</span> &lt;&lt; X</span><br><span class="line">           &lt;&lt; <span class="string">&quot;id&quot;</span> &lt;&lt; id</span><br><span class="line">           &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">const</span> cv::FileNode&amp; node)</span> </span>&#123;</span><br><span class="line">        A = (<span class="type">int</span>)node[<span class="string">&quot;A&quot;</span>];</span><br><span class="line">        X = (<span class="type">double</span>)node[<span class="string">&quot;X&quot;</span>];</span><br><span class="line">        id = (std::string)node[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数（必须添加）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">(cv::FileStorage&amp; fs, <span class="type">const</span> std::string&amp;, <span class="type">const</span> MyData&amp; x)</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">write</span>(fs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">const</span> cv::FileNode&amp; node, MyData&amp; x, <span class="type">const</span> MyData&amp; default_value = MyData())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="built_in">empty</span>()) x = default_value;</span><br><span class="line">    <span class="keyword">else</span> x.<span class="built_in">read</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyData data;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;MyData&quot;</span> &lt;&lt; data;  <span class="comment">// 写入</span></span><br><span class="line">fs[<span class="string">&quot;MyData&quot;</span>] &gt;&gt; data;    <span class="comment">// 读取</span></span><br></pre></td></tr></table></figure>
<h3 id="示例代码与输出结果">3.5. 示例代码与输出结果</h3>
<h4 id="示例代码">3.5.1. 示例代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyData</span>() : <span class="built_in">A</span>(<span class="number">0</span>), <span class="built_in">X</span>(<span class="number">0.0</span>), <span class="built_in">id</span>(<span class="string">&quot;default&quot;</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyData</span><span class="params">(<span class="type">int</span> val)</span> : A(val), X(<span class="number">3.14159</span>), id(<span class="string">&quot;mydata_&quot;</span> + std::to_string(val)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化写入函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(cv::FileStorage&amp; fs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;&#123;&quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; A</span><br><span class="line">            &lt;&lt; <span class="string">&quot;X&quot;</span> &lt;&lt; X</span><br><span class="line">            &lt;&lt; <span class="string">&quot;id&quot;</span> &lt;&lt; id</span><br><span class="line">            &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化读取函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">const</span> cv::FileNode&amp; node)</span> </span>&#123;</span><br><span class="line">        A = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(node[<span class="string">&quot;A&quot;</span>]);</span><br><span class="line">        X = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(node[<span class="string">&quot;X&quot;</span>]);</span><br><span class="line">        id = <span class="built_in">static_cast</span>&lt;std::string&gt;(node[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> A;</span><br><span class="line">    <span class="type">double</span> X;</span><br><span class="line">    std::string id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局读写函数（必须定义）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">(cv::FileStorage&amp; fs, <span class="type">const</span> std::string&amp;, <span class="type">const</span> MyData&amp; x)</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">write</span>(fs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">const</span> cv::FileNode&amp; node, MyData&amp; x, <span class="type">const</span> MyData&amp; default_val = MyData())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="built_in">empty</span>()) x = default_val;</span><br><span class="line">    <span class="keyword">else</span> x.<span class="built_in">read</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string filename = <span class="string">&quot;data.yml&quot;</span>;  <span class="comment">// 支持.xml, .json等扩展名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 写入数据 ---</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">cv::FileStorage <span class="title">fs</span><span class="params">(filename, cv::FileStorage::WRITE)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基本类型</span></span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;iteration&quot;</span> &lt;&lt; <span class="number">100</span>;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;timestamp&quot;</span> &lt;&lt; <span class="string">&quot;2025-02-04&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// OpenCV矩阵</span></span><br><span class="line">        cv::Mat R = cv::Mat_&lt;uchar&gt;::<span class="built_in">eye</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        cv::Mat T = cv::Mat_&lt;<span class="type">double</span>&gt;::<span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;RotationMatrix&quot;</span> &lt;&lt; R;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;TranslationVector&quot;</span> &lt;&lt; T;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列（数组）</span></span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;images&quot;</span> &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;img1.jpg&quot;</span> &lt;&lt; <span class="string">&quot;img2.png&quot;</span> &lt;&lt; <span class="string">&quot;img3.bmp&quot;</span>;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 映射（字典）</span></span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;parameters&quot;</span> &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;threshold&quot;</span> &lt;&lt; <span class="number">0.75</span> &lt;&lt; <span class="string">&quot;max_iter&quot;</span> &lt;&lt; <span class="number">500</span>;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义对象</span></span><br><span class="line">        <span class="function">MyData <span class="title">data</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;custom_data&quot;</span> &lt;&lt; data;</span><br><span class="line"></span><br><span class="line">        fs.<span class="built_in">release</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数据写入完成: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 读取数据 ---</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">cv::FileStorage <span class="title">fs</span><span class="params">(filename, cv::FileStorage::READ)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!fs.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;文件打开失败!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取基本类型</span></span><br><span class="line">        <span class="type">int</span> iteration;</span><br><span class="line">        std::string timestamp;</span><br><span class="line">        fs[<span class="string">&quot;iteration&quot;</span>] &gt;&gt; iteration;</span><br><span class="line">        fs[<span class="string">&quot;timestamp&quot;</span>] &gt;&gt; timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取矩阵</span></span><br><span class="line">        cv::Mat R, T;</span><br><span class="line">        fs[<span class="string">&quot;RotationMatrix&quot;</span>] &gt;&gt; R;</span><br><span class="line">        fs[<span class="string">&quot;TranslationVector&quot;</span>] &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取序列</span></span><br><span class="line">        cv::FileNode images = fs[<span class="string">&quot;images&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (images.<span class="built_in">type</span>() == cv::FileNode::SEQ) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\n图像列表: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (cv::FileNodeIterator it = images.<span class="built_in">begin</span>(); it != images.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="built_in">static_cast</span>&lt;std::string&gt;(*it) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取映射</span></span><br><span class="line">        cv::FileNode params = fs[<span class="string">&quot;parameters&quot;</span>];</span><br><span class="line">        <span class="type">double</span> threshold = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(params[<span class="string">&quot;threshold&quot;</span>]);</span><br><span class="line">        <span class="type">int</span> max_iter = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(params[<span class="string">&quot;max_iter&quot;</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取自定义对象</span></span><br><span class="line">        MyData loaded_data;</span><br><span class="line">        fs[<span class="string">&quot;custom_data&quot;</span>] &gt;&gt; loaded_data;</span><br><span class="line"></span><br><span class="line">        fs.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出验证</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n\n读取结果:&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n迭代次数: &quot;</span> &lt;&lt; iteration</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n时间戳: &quot;</span> &lt;&lt; timestamp</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n阈值: &quot;</span> &lt;&lt; threshold</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n最大迭代: &quot;</span> &lt;&lt; max_iter</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n自定义数据: A=&quot;</span> &lt;&lt; loaded_data.A</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, X=&quot;</span> &lt;&lt; loaded_data.X</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, id=&quot;</span> &lt;&lt; loaded_data.id</span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件输出yml">3.5.2. 文件输出（YML）</h4>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">%YAML:1.0</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">iteration:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">timestamp:</span> <span class="string">&quot;2025-02-04&quot;</span></span><br><span class="line"><span class="attr">RotationMatrix:</span> <span class="type">!!opencv</span><span class="string">-matrix</span></span><br><span class="line">   <span class="attr">rows:</span> <span class="number">3</span></span><br><span class="line">   <span class="attr">cols:</span> <span class="number">3</span></span><br><span class="line">   <span class="attr">dt:</span> <span class="string">u</span></span><br><span class="line">   <span class="attr">data:</span> [ <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> ]</span><br><span class="line"><span class="attr">TranslationVector:</span> <span class="type">!!opencv</span><span class="string">-matrix</span></span><br><span class="line">   <span class="attr">rows:</span> <span class="number">3</span></span><br><span class="line">   <span class="attr">cols:</span> <span class="number">1</span></span><br><span class="line">   <span class="attr">dt:</span> <span class="string">d</span></span><br><span class="line">   <span class="attr">data:</span> [ <span class="number">0</span><span class="string">.</span>, <span class="number">0</span><span class="string">.</span>, <span class="number">0</span><span class="string">.</span> ]</span><br><span class="line"><span class="attr">images:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;img1.jpg&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;img2.png&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;img3.bmp&quot;</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">   <span class="attr">threshold:</span> <span class="number">7.5000000000000000e-01</span></span><br><span class="line">   <span class="attr">max_iter:</span> <span class="number">500</span></span><br><span class="line"><span class="attr">custom_data:</span></span><br><span class="line">   <span class="attr">A:</span> <span class="number">42</span></span><br><span class="line">   <span class="attr">X:</span> <span class="number">3.1415899999999999e+00</span></span><br><span class="line">   <span class="attr">id:</span> <span class="string">mydata_42</span></span><br></pre></td></tr></table></figure>
<h4 id="控制台输出">3.5.3. 控制台输出</h4>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">数据写入完成: data.yml</span><br><span class="line"></span><br><span class="line">图像列表: img1.jpg img2.png img3.bmp</span><br><span class="line"></span><br><span class="line">读取结果:</span><br><span class="line">迭代次数: 100</span><br><span class="line">时间戳: 2025-02-04</span><br><span class="line">阈值: 0.75</span><br><span class="line">最大迭代: 500</span><br><span class="line">自定义数据: A=42, X=3.14159, id=mydata_42</span><br></pre></td></tr></table></figure>
<h3 id="注意事项">3.6. 注意事项</h3>
<ol type="1">
<li><p><strong>节点不存在时的处理</strong>：读取时若节点不存在，可返回默认值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyData defaultData;</span><br><span class="line">fs[<span class="string">&quot;NonExisting&quot;</span>] &gt;&gt; defaultData;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>文件格式兼容性</strong>：JSON 文件需 OpenCV 3.0
及以上版本支持。</p></li>
<li><p><strong>压缩文件</strong>：使用<code>.gz</code>扩展名可自动压缩文件，如<code>output.xml.gz</code>。</p></li>
</ol>
<p>通过灵活运用 OpenCV
的序列化功能，开发者可以高效管理复杂数据结构，为计算机视觉项目提供可靠的数据存储方案。</p>
<hr />
<h2 id="并行化卷积运算">4. 并行化卷积运算</h2>
<h3 id="目标">4.1. 目标</h3>
<p>演示如何利用 OpenCV 的 <code>cv::parallel_for_</code>
框架轻松实现代码并行化。以图像卷积运算为例，对比分析顺序执行与并行执行的性能差异。</p>
<h3 id="前提条件">4.2. 前提条件</h3>
<ol type="1">
<li><strong>并行框架支持</strong> OpenCV
需在编译时启用并行框架支持。OpenCV 4.5 支持的并行框架按优先级排序如下：
<ul>
<li>Intel TBB（需显式启用）</li>
<li>OpenMP（需显式启用）</li>
<li>APPLE GCD（自动调用）</li>
<li>Windows 并发库（自动调用）</li>
<li>Pthreads</li>
</ul></li>
<li><strong>竞态条件管理</strong>
卷积运算属于<strong>单线程写多线程读</strong>场景，不存在竞态条件。而多线程共同修改同一内存区域时（如特征检测），需采用同步机制。</li>
</ol>
<h3 id="卷积理论基础">4.3. 卷积理论基础</h3>
<p>卷积通过滑动内核矩阵计算像素加权和，公式表示为： <span
class="math display">\[
\text{output}(i, j) = \sum_{k=-\frac{n}{2}}^{\frac{n}{2}}
\sum_{l=-\frac{n}{2}}^{\frac{n}{2}} \text{kernel}(k, l) \cdot
\text{src}(i + k, j + l) \nonumber
\]</span> 其中，内核尺寸需为奇数以确保中心锚点存在。</p>
<p>卷积层输出尺寸计算公式，参考 <code>PyTorch</code> <a
href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d">官方文档</a></p>
<p><span class="math display">\[
\begin{align*}
H_{\text{out}} = \left\lfloor \frac{H_{\text{in}} + 2\times
\text{padding}[0] - \text{dilation}[0]\times\bigl(\text{kernel_
size}[0]-1\bigr)-1}{\text{stride}[0]} + 1 \right\rfloor \\ \\
W_{\text{out}} = \left\lfloor \frac{H_{\text{in}} + 2\times
\text{padding}[1] - \text{dilation}[1]\times\bigl(\text{kernel_
size}[1]-1\bigr)-1}{\text{stride}[1]} + 1 \right\rfloor
\end{align*}
\]</span></p>
<p>卷积计算的两种模式：</p>
<ul>
<li><strong>Same
模式</strong>：通过在输入周围填充零（或其他元素），使得输出尺寸与输入尺寸相同（步幅为
1 时），即保持尺寸不变。</li>
<li><strong>Valid
模式</strong>：不进行任何填充，只有完全覆盖的区域才进行卷积计算，因此输出尺寸会比输入尺寸小。</li>
</ul>
<p>下文均使用 Same 模式。</p>
<h3 id="顺序卷积实现">4.4. 顺序卷积实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conv_seq</span><span class="params">(cv::Mat src, cv::Mat &amp;dst, cv::Mat kernel)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line">    dst = cv::<span class="built_in">Mat</span>(rows, cols, src.<span class="built_in">type</span>());</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> sz = kernel.rows / <span class="number">2</span>;</span><br><span class="line">    cv::<span class="built_in">copyMakeBorder</span>(src, src, sz, sz, sz, sz, cv::BORDER_REPLICATE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        uchar *dptr = dst.<span class="built_in">ptr</span>&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = -sz; k &lt;= sz; k++) &#123;</span><br><span class="line">                uchar *sptr = src.<span class="built_in">ptr</span>&lt;uchar&gt;(i + sz + k);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = -sz; l &lt;= sz; l++) &#123;</span><br><span class="line">                    value += kernel.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(k + sz, l + sz) * sptr[j + sz + l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dptr[j] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="note info"><summary><p><code>cv::copyMakeBorder</code></p>
</summary>
<p><code>cv::copyMakeBorder</code> 是 OpenCV
提供的一个函数，用于扩展图像的边界，也可以称为“边缘填充”或“镜像填充”。它常用于在图像处理和计算机视觉任务中，为图像增加额外的像素边界，以满足后续处理（例如卷积、滤波、图像拼接等）的尺寸要求或避免边缘效应。</p>
<p><strong>主要功能</strong></p>
<ul>
<li><strong>边界扩展</strong>：在图像的四周添加指定数量的像素行和列。</li>
<li><strong>多种填充模式</strong>：支持常数填充、复制边缘像素、镜像反射等不同的边界填充方式。</li>
</ul>
<p><strong>函数原型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::copyMakeBorder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray src,       <span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray dst,      <span class="comment">// 输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> top,              <span class="comment">// 顶部扩展像素数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> bottom,           <span class="comment">// 底部扩展像素数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> left,             <span class="comment">// 左侧扩展像素数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> right,            <span class="comment">// 右侧扩展像素数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> borderType,       <span class="comment">// 边界扩展的模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Scalar&amp; value = Scalar() <span class="comment">// 当使用常数填充时使用的数值（默认为0）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<ul>
<li><strong>src</strong>：输入图像，可以是灰度图像、彩色图像或多通道图像。</li>
<li><strong>dst</strong>：输出图像，即添加了边界扩展后的结果图像。</li>
<li><strong>top、bottom、left、right</strong>：分别表示在输入图像的上、下、左、右方向扩展的像素数量。比如，如果
<code>top = 10</code>，则会在图像上方添加 10 行像素。</li>
<li><strong>borderType</strong>：定义边界扩展的模式。常用的模式包括：
<ul>
<li><code>BORDER_CONSTANT</code>：使用常数填充扩展区域（常常与参数
<code>value</code> 一起使用）。</li>
<li><code>BORDER_REPLICATE</code>：复制边缘像素，例如左侧填充就是复制图像最左侧的像素。</li>
<li><code>BORDER_REFLECT</code>：镜像填充，填充部分是输入图像的镜像（不包括边缘的重复）。</li>
<li><code>BORDER_REFLECT_101</code> 或 <code>BORDER_DEFAULT</code>：与
<code>BORDER_REFLECT</code> 类似，不过镜像时边缘像素不会重复。</li>
<li><code>BORDER_WRAP</code>：将图像看作周期性的，将另一侧的像素填充到边缘。</li>
</ul></li>
<li><strong>value</strong>：当 <code>borderType</code> 设为
<code>BORDER_CONSTANT</code>
时，用来指定填充区域的像素值（对于多通道图像，可以传入
<code>Scalar(b, g, r)</code>）。</li>
</ul>

</details>
<h3 id="并行卷积实现">4.5. 并行卷积实现</h3>
<h4 id="自定义并行循环体">4.5.1. 自定义并行循环体</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParallelConvolution</span> : <span class="keyword">public</span> cv::ParallelLoopBody &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    cv::Mat m_src, &amp;m_dst;</span><br><span class="line">    cv::Mat m_kernel;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ParallelConvolution</span>(cv::Mat src, cv::Mat &amp;dst, cv::Mat kernel)</span><br><span class="line">        : <span class="built_in">m_src</span>(src), <span class="built_in">m_dst</span>(dst), <span class="built_in">m_kernel</span>(kernel) &#123;</span><br><span class="line">        sz = kernel.rows / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> cv::Range &amp;range)</span> <span class="type">const</span> CV_OVERRIDE </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = range.start; r &lt; range.end; r++) &#123;</span><br><span class="line">            <span class="type">int</span> i = r / m_src.cols, j = r % m_src.cols;</span><br><span class="line">            <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = -sz; k &lt;= sz; k++) &#123;</span><br><span class="line">                uchar *sptr = m_src.<span class="built_in">ptr</span>&lt;uchar&gt;(i + sz + k);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = -sz; l &lt;= sz; l++) &#123;</span><br><span class="line">                    value += m_kernel.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(k + sz, l + sz) * sptr[j + sz + l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m_dst.<span class="built_in">ptr</span>&lt;uchar&gt;(i)[j] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="function">ParallelConvolution <span class="title">obj</span><span class="params">(src, dst, kernel)</span></span>;</span><br><span class="line">cv::<span class="built_in">parallel_for_</span>(cv::<span class="built_in">Range</span>(<span class="number">0</span>, rows * cols), obj);</span><br></pre></td></tr></table></figure>
<h4 id="使用-lambda-表达式c11-以上">4.5.2. 使用 Lambda 表达式（C++11
以上）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">parallel_for_</span>(cv::<span class="built_in">Range</span>(<span class="number">0</span>, rows * cols), [&amp;](<span class="type">const</span> cv::Range &amp;range) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = range.start; r &lt; range.end; r++) &#123;</span><br><span class="line">        <span class="type">int</span> i = r / cols, j = r % cols;</span><br><span class="line">        <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = -sz; k &lt;= sz; k++) &#123;</span><br><span class="line">            uchar *sptr = src.<span class="built_in">ptr</span>&lt;uchar&gt;(i + sz + k);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l = -sz; l &lt;= sz; l++) &#123;</span><br><span class="line">                value += kernel.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(k + sz, l + sz) * sptr[j + sz + l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dst.<span class="built_in">ptr</span>&lt;uchar&gt;(i)[j] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<details class="note info"><summary><p>继承 <code>cv::ParallelLoopBody</code> 类</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConvolutionTask</span> : <span class="keyword">public</span> cv::ParallelLoopBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> cv::Mat&amp; src;</span><br><span class="line">    cv::Mat&amp; dst;</span><br><span class="line">    <span class="type">const</span> cv::Mat&amp; kernel;</span><br><span class="line">    <span class="type">int</span> sz, cols;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ConvolutionTask</span>(<span class="type">const</span> cv::Mat&amp; _src, cv::Mat&amp; _dst, <span class="type">const</span> cv::Mat&amp; _kernel, <span class="type">int</span> _sz, <span class="type">int</span> _cols)</span><br><span class="line">        : <span class="built_in">src</span>(_src), <span class="built_in">dst</span>(_dst), <span class="built_in">kernel</span>(_kernel), <span class="built_in">sz</span>(_sz), <span class="built_in">cols</span>(_cols) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> cv::Range&amp; range)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = range.start; r &lt; range.end; r++) &#123;</span><br><span class="line">            <span class="type">int</span> i = r / cols, j = r % cols;</span><br><span class="line">            <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = -sz; k &lt;= sz; k++) &#123;</span><br><span class="line">                uchar* sptr = src.<span class="built_in">ptr</span>&lt;uchar&gt;(i + sz + k);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = -sz; l &lt;= sz; l++) &#123;</span><br><span class="line">                    value += kernel.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(k + sz, l + sz) * sptr[j + sz + l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dst.<span class="built_in">ptr</span>&lt;uchar&gt;(i)[j] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 `cv::parallel_for_`</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">applyConvolution</span><span class="params">(<span class="type">const</span> cv::Mat&amp; src, cv::Mat&amp; dst, <span class="type">const</span> cv::Mat&amp; kernel, <span class="type">int</span> sz)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line">    cv::<span class="built_in">parallel_for_</span>(cv::<span class="built_in">Range</span>(<span class="number">0</span>, rows * cols), <span class="built_in">ConvolutionTask</span>(src, dst, kernel, sz, cols));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="性能对比">4.6. 性能对比</h3>
<p>对 <span class="math inline">\(512 \times 512\)</span>
图像使用不同内核尺寸测试得到以下结果：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">实现方式</th>
<th style="text-align: center;">5×5 内核时间 (s)</th>
<th style="text-align: center;">3×3 内核时间 (s)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">顺序执行</td>
<td style="text-align: center;">0.0954</td>
<td style="text-align: center;">0.0301</td>
</tr>
<tr class="even">
<td style="text-align: center;">全图分块并行</td>
<td style="text-align: center;">0.0247</td>
<td style="text-align: center;">0.0117</td>
</tr>
<tr class="odd">
<td style="text-align: center;">按行分块并行</td>
<td style="text-align: center;">0.0249</td>
<td style="text-align: center;">0.0118</td>
</tr>
</tbody>
</table>
<p>并行实现通常可获得 <strong>4-7倍加速比</strong>，实际性能取决于 CPU
核心数与任务调度策略。</p>
<p>表格中 "全图分块并行" 和 "按行分块并行" 的对比，实际是以下两种
<code>cv::Range</code> 定义的对比：</p>
<ul>
<li><code>cv::Range(0, rows * cols)</code> → 全图分块</li>
<li><code>cv::Range(0, rows)</code> → 按行分块</li>
</ul>
<h3 id="总结">4.7. 总结</h3>
<ol type="1">
<li>OpenCV <code>cv::parallel_for_</code>
自动划分计算任务，极大简化并行代码开发。</li>
<li>通过继承 <code>cv::ParallelLoopBody</code> 或使用 Lambda
表达式，均可实现高效并行。</li>
<li>线程数可通过 <code>cv::setNumThreads()</code> 调整，任务划分粒度由
<code>nstripes</code> 参数控制。</li>
</ol>
<p>通过合理使用并行框架，可显著提升图像处理算法的运行时效率。</p>
<hr />
<h2 id="代码向量化">5. 代码向量化</h2>
<h3 id="目标-1">5.1. 目标</h3>
<p>本教程介绍如何利用 OpenCV 的 <strong>Universal Intrinsics</strong>
特性对 C++ 代码进行向量化优化，利用现代处理器的 SIMD
指令实现运行时加速。内容涵盖 SIMD
基础概念、寄存器操作及实际卷积算法向量化实现。</p>
<h3 id="simd-与-universal-intrinsics-基础">5.2. SIMD 与 Universal
Intrinsics 基础</h3>
<h4 id="simd-技术原理">5.2.1. SIMD 技术原理</h4>
<p>SIMD（单指令多数据）允许处理器使用宽寄存器同时对多个数据元素执行相同操作。例如：</p>
<ul>
<li>128位寄存器可同时处理4个32位浮点数</li>
<li>256位寄存器可处理8个32位整数</li>
</ul>
<h4 id="通用内联函数特性">5.2.2. 通用内联函数特性</h4>
<p>OpenCV Universal Intrinsics 提供跨平台 SIMD
抽象层，支持多种指令集：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持SSE/AVX/NEON等指令集</span></span><br><span class="line">cv::v_uint8  <span class="comment">// 8位无符号整数寄存器</span></span><br><span class="line">cv::v_float32 <span class="comment">// 32位浮点数寄存器</span></span><br></pre></td></tr></table></figure>
<h4 id="寄存器类型">5.2.3. 寄存器类型</h4>
<ol type="1">
<li><p><strong>变长寄存器</strong>：自动适配硬件最大位宽</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::v_float32 reg;</span><br><span class="line"><span class="type">int</span> n = reg.nlanes; <span class="comment">// 根据硬件返回可容纳元素数量</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>定长寄存器</strong>：明确指定位宽</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::v_float32x4 reg; <span class="comment">// 明确使用128位寄存器（4元素）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="核心操作实践">5.3. 核心操作实践</h3>
<h4 id="数据加载与存储">5.3.1. 数据加载与存储</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载未对齐数据</span></span><br><span class="line"><span class="type">float</span> src[<span class="number">8</span>];</span><br><span class="line">cv::v_float32x4 reg = cv::<span class="built_in">v_load</span>(src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储到对齐内存</span></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">float</span> dst[<span class="number">4</span>];</span><br><span class="line">cv::<span class="built_in">v_store</span>(dst, reg);</span><br></pre></td></tr></table></figure>
<h4 id="向量运算">5.3.2. 向量运算</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::v_float32 a = cv::<span class="built_in">v_load</span>(ptr_a);</span><br><span class="line">cv::v_float32 b = cv::<span class="built_in">v_load</span>(ptr_b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量加减乘除</span></span><br><span class="line">cv::v_float32 sum = a + b;</span><br><span class="line">cv::v_float32 prod = a * b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较运算生成掩码</span></span><br><span class="line">cv::v_float32 cmp_mask = (a &gt; b);</span><br></pre></td></tr></table></figure>
<h4 id="规约与掩码操作">5.3.3. 规约与掩码操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求最大值</span></span><br><span class="line"><span class="type">float</span> max_val = cv::<span class="built_in">v_reduce_max</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件选择</span></span><br><span class="line">cv::v_float32 result = cv::<span class="built_in">v_select</span>(cmp_mask, a, b);</span><br></pre></td></tr></table></figure>
<h3 id="卷积算法向量化实战">5.4. 卷积算法向量化实战</h3>
<h4 id="原始标量实现">5.4.1. 原始标量实现</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scalar_conv1d</span><span class="params">(cv::Mat src, cv::Mat &amp;dst, cv::Mat kernel)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sz = kernel.cols/<span class="number">2</span>;</span><br><span class="line">    cv::<span class="built_in">copyMakeBorder</span>(src, src, <span class="number">0</span>, <span class="number">0</span>, sz, sz, cv::BORDER_REPLICATE);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.cols; ++i)&#123;</span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=-sz; k&lt;=sz; ++k)&#123;</span><br><span class="line">            sum += src.<span class="built_in">at</span>&lt;uchar&gt;(i+k+sz) * kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(k+sz);</span><br><span class="line">        &#125;</span><br><span class="line">        dst.<span class="built_in">at</span>&lt;uchar&gt;(i) = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="simd-向量化改造">5.4.2. SIMD 向量化改造</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vectorized_conv1d</span><span class="params">(cv::Mat src, cv::Mat kernel, <span class="type">float</span>* ans)</span> </span>&#123;</span><br><span class="line">    cv::Mat src_32;</span><br><span class="line">    src.<span class="built_in">convertTo</span>(src_32, CV_32F);</span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> step = cv::v_float32x4::nlanes;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;kernel.cols; ++k)&#123;</span><br><span class="line">        cv::v_float32x4 kernel_wide = cv::<span class="built_in">v_setall_f32</span>(kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(k));</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 主向量处理循环</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i+step &lt; src.cols; i+=step)&#123;</span><br><span class="line">            cv::v_float32x4 window = cv::<span class="built_in">v_load</span>(&amp;src_<span class="number">32.</span><span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i+k));</span><br><span class="line">            cv::v_float32x4 sum = cv::<span class="built_in">v_load</span>(ans+i) + window * kernel_wide;</span><br><span class="line">            cv::<span class="built_in">v_store</span>(ans+i, sum);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 尾部数据处理</span></span><br><span class="line">        <span class="keyword">for</span>(; i&lt;src.cols; ++i)&#123;</span><br><span class="line">            ans[i] += src_<span class="number">32.</span><span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i+k) * kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维卷积扩展">5.5. 二维卷积扩展</h3>
<p>通过水平 + 垂直方向的一维卷积组合实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">convolute_2d</span><span class="params">(cv::Mat src, cv::Mat &amp;dst, cv::Mat kernel)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ksize = kernel.rows/<span class="number">2</span>;</span><br><span class="line">    cv::<span class="built_in">copyMakeBorder</span>(src, src, ksize, ksize, <span class="number">0</span>, <span class="number">0</span>, cv::BORDER_REPLICATE);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; src.rows; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;kernel.rows; ++k)&#123;</span><br><span class="line">            <span class="type">float</span> tmp[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">vectorized_conv1d</span>(src.<span class="built_in">row</span>(i+k), kernel.<span class="built_in">row</span>(k), tmp);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 累加多行结果</span></span><br><span class="line">            <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j<span class="number">+4</span>&lt;src.cols; j+=<span class="number">4</span>)&#123;</span><br><span class="line">                cv::v_float32x4 sum = cv::<span class="built_in">v_load</span>(&amp;dst.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,j)) </span><br><span class="line">                                    + cv::<span class="built_in">v_load</span>(&amp;tmp[j]);</span><br><span class="line">                cv::<span class="built_in">v_store</span>(&amp;dst.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,j), sum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; j&lt;src.cols; ++j)&#123;</span><br><span class="line">                dst.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,j) += tmp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能对比与建议">5.6. 性能对比与建议</h3>
<ul>
<li>测试显示向量化版本相比标量实现可获得2-5倍加速</li>
<li>实际性能取决于：
<ul>
<li>CPU 支持的 SIMD 指令集（SSE4/AVX2/AVX512）</li>
<li>数据对齐情况</li>
<li>算法内存访问模式</li>
</ul></li>
</ul>
<p><strong>优化建议</strong>：</p>
<ol type="1">
<li>优先处理连续内存块</li>
<li>尽量使用 <code>vx_load_aligned</code> 访问对齐数据</li>
<li>利用 <code>v_reduce</code> 系列函数代替标量累计</li>
<li>通过 <code>v_select</code> 实现条件分支消除</li>
</ol>
<p>通过合理使用 Universal
Intrinsics，开发者可以在不损失代码可移植性的前提下，充分利用现代处理器的并行计算能力。建议结合性能分析工具，针对热点代码进行定向优化。</p>
<hr />
<h2 id="参考资料">6. 参考资料</h2>
<p><strong>[1]</strong> <a
href="https://docs.opencv.org/4.x/de/d7a/tutorial_table_of_content_core.html">OpenCV
官方文档</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV入门学习-核心功能（一）</title>
    <url>/2025/01/24/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<p>环境：</p>
<ul>
<li>win11 x64</li>
<li>OpenCV 4.9.0</li>
<li>VS 2022 (v143)</li>
<li>C++ (ISO C++ 14 标准)</li>
</ul>
<hr />
<h2 id="mat-类">1. <code>Mat</code> 类</h2>
<h3 id="数据结构与内存管理">1.1. 数据结构与内存管理</h3>
<p><code>Mat</code>
是OpenCV的核心图像容器类，采用<strong>自动内存管理</strong>机制，无需手动分配/释放内存。其结构分为两部分：</p>
<ul>
<li><strong>矩阵头(Header)</strong><br />
固定大小（约数十字节），存储元信息：
<ul>
<li>矩阵维度（rows, cols, channels）</li>
<li>数据类型（如 <code>CV_8UC3</code> ）</li>
<li>存储布局（step：每行的字节数）</li>
<li>引用计数器</li>
<li>数据指针地址</li>
</ul></li>
<li><strong>数据块(Data)</strong><br />
动态内存区域，存储实际像素值，采用<strong>引用计数机制</strong>管理：
<ul>
<li>浅拷贝时多个 <code>Mat</code> 对象共享数据块</li>
<li>最后一个引用对象销毁时自动释放内存</li>
</ul></li>
</ul>
<h3 id="深浅拷贝对比">1.2. 深浅拷贝对比</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat A = cv::<span class="built_in">imread</span>(<span class="string">&quot;dog.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">cv::Mat B = A;         <span class="comment">// 浅拷贝（仅复制Header）</span></span><br><span class="line">cv::Mat C = A.<span class="built_in">clone</span>(); <span class="comment">// 深拷贝（完整数据副本）</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>操作类型</th>
<th>内存开销</th>
<th>数据独立性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>浅拷贝</td>
<td>极小</td>
<td>共享数据</td>
<td>快速创建视图/ROI</td>
</tr>
<tr class="even">
<td>深拷贝</td>
<td>大</td>
<td>完全独立</td>
<td>需独立修改像素的场景</td>
</tr>
</tbody>
</table>
<blockquote>
<p>📌 <strong>关键机制</strong></p>
<ul>
<li>修改浅拷贝对象的像素会直接影响原对象</li>
<li>使用 <code>clone()</code> 或 <code>copyTo()</code>
进行<strong>显式深拷贝</strong></li>
</ul>
</blockquote>
<h3 id="色彩空间与存储布局">1.3. 色彩空间与存储布局</h3>
<ul>
<li><strong>默认色彩空间</strong>：BGR（非 RGB
），与图像显示系统兼容</li>
<li><strong>通道顺序</strong>：对于3通道矩阵，像素按 <code>B-G-R</code>
顺序存储</li>
<li><strong>内存布局</strong>：连续存储（可通过
<code>isContinuous()</code> 判断），行优先存储</li>
</ul>
<h3 id="构造函数全解析">1.4. 构造函数全解析</h3>
<h4 id="默认构造函数延迟初始化">1.4.1. 默认构造函数（延迟初始化）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat matEmpty; <span class="comment">// 创建空矩阵（Header无数据指针）</span></span><br><span class="line">matEmpty = cv::<span class="built_in">imread</span>(<span class="string">&quot;image.jpg&quot;</span>); <span class="comment">// 延迟加载时分配内存</span></span><br></pre></td></tr></table></figure>
<h4 id="指定尺寸与类型">1.4.2. 指定尺寸与类型</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建480x640的3通道图像（BGR格式）</span></span><br><span class="line"><span class="comment">// Mat(int rows, int cols, int type);</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">mat</span><span class="params">(<span class="number">480</span>, <span class="number">640</span>, CV_8UC3)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="初始化值构造函数">1.4.3. 初始化值构造函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建3x3蓝色矩阵（B=255, G=0, R=0）</span></span><br><span class="line"><span class="comment">// Mat(int rows, int cols, int type, const cv::Scalar&amp; s);</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">matInit</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, CV_8UC3, cv::Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="外部数据共享">1.4.4. 外部数据共享</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> externalData[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">cv::Mat <span class="title">matExt</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>, CV_32FC1, externalData)</span></span>; <span class="comment">// 共享内存</span></span><br></pre></td></tr></table></figure>
<h4 id="roi构造函数">1.4.5. ROI构造函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Rect <span class="title">roiArea</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>)</span></span>; <span class="comment">// (x,y,width,height)</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">roi</span><span class="params">(img, roiArea)</span></span>; <span class="comment">// 浅拷贝原图的ROI区域</span></span><br></pre></td></tr></table></figure>
<h4 id="特殊矩阵生成">1.4.6. 特殊矩阵生成</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat zeros = cv::Mat::<span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">3</span>, CV_32F); <span class="comment">// 3x3浮点零矩阵</span></span><br><span class="line">cv::Mat eye = cv::Mat::<span class="built_in">eye</span>(<span class="number">3</span>, <span class="number">3</span>, CV_8UC1);    <span class="comment">// 3x3单位矩阵</span></span><br></pre></td></tr></table></figure>
<h3 id="数据访问与输出">1.5. 数据访问与输出</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确输出矩阵内容（需指定格式）</span></span><br><span class="line">cv::Mat intMatrix = (cv::<span class="built_in">Mat_</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">2</span>) &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Matrix:\n&quot;</span> &lt;&lt; cv::format(intMatrix, cv::Formatter::FMT_C) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// [1, 2;</span></span><br><span class="line"><span class="comment">//  3, 4]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ <strong>注意事项</strong></p>
<ul>
<li>使用 <code>at&lt;T&gt;(row,col)</code> 访问元素时需确保类型匹配（如
<code>CV_8UC3</code> 对应 <code>cv::Vec3b</code> ）</li>
<li>多通道矩阵的 cv::Scalar 初始化顺序为 <code>(B,G,R)</code></li>
<li>外部数据构造的 cv::Mat 对象不管理原数据内存，需手动维护生命周期</li>
</ul>
</blockquote>
<h3 id="其他操作">1.6. 其他操作</h3>
<ol type="1">
<li><p><strong>多维矩阵支持</strong><br />
<code>cv::Mat</code> 可处理N维数据，通过 <code>dims</code>
参数指定维度：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mat(int ndims, const int* sizes, int type, const cv::Scalar&amp; s);</span></span><br><span class="line"><span class="type">int</span> sizes[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 3维：3x4x5</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">ndMat</span><span class="params">(<span class="number">3</span>, sizes, CV_8UC1, cv::Scalar::all(<span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>内存连续性优化</strong><br />
使用 <code>create()</code> 方法重新分配连续内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mat.<span class="built_in">create</span>(rows, cols, type); <span class="comment">// 重置矩阵尺寸/类型</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>表达式计算优化</strong><br />
OpenCV重载了矩阵运算符（ <code>+</code> , <code>*</code>
等），自动避免中间变量拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat C = A.<span class="built_in">mul</span>(B) + <span class="number">0.5</span>; <span class="comment">// 对应元素相乘再加 0.5</span></span><br><span class="line"><span class="comment">// ps: 矩阵乘法时直接用 *</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="补充-cv_-数据类型">1.7. 补充 <code>CV_</code> 数据类型</h3>
<p>OpenCV 中的 <code>CV_</code>
数据结构（数据类型）是通过预定义宏（<code>CV_&lt;位数&gt;&lt;类型&gt;C&lt;通道数&gt;</code>）表示的矩阵数据类型，主要用于定义
<code>cv::Mat</code> 或图像的数据类型。常见类型如下：</p>
<h4 id="命名规则">1.7.1. 命名规则</h4>
<p>格式：<strong><code>CV_&lt;bit_depth&gt;(S|U|F)C&lt;通道数&gt;</code></strong></p>
<ul>
<li><strong><code>bit_depth</code></strong>：数据位数（如 8, 16, 32,
64）。</li>
<li><strong><code>S|U|F</code></strong>：
<ul>
<li><code>U</code>：无符号整数（Unsigned，如 <code>uchar</code>）。</li>
<li><code>S</code>：有符号整数（Signed，如 <code>int</code>）。</li>
<li><code>F</code>：浮点数（Float，如 <code>float</code> 或
<code>double</code>）。</li>
</ul></li>
<li><strong><code>C&lt;通道数&gt;</code></strong>：通道数（1-4，更高通道数需要自定义类型）。</li>
</ul>
<h4 id="常见数据类型">1.7.2. 常见数据类型</h4>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 33%" />
<col style="width: 24%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>数据类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>C++ 类型等效</strong></th>
<th><strong>典型用途</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>CV_8UC1</code></td>
<td>8 位无符号单通道</td>
<td><code>uchar</code></td>
<td>灰度图像</td>
</tr>
<tr class="even">
<td><code>CV_8UC3</code></td>
<td>8 位无符号三通道</td>
<td><code>cv::Vec3b</code></td>
<td>BGR 彩色图像（默认格式）</td>
</tr>
<tr class="odd">
<td><code>CV_8UC4</code></td>
<td>8 位无符号四通道</td>
<td><code>cv::Vec4b</code></td>
<td>带透明度（BGRA）的图像</td>
</tr>
<tr class="even">
<td><code>CV_16UC1</code></td>
<td>16 位无符号单通道</td>
<td><code>ushort</code></td>
<td>深度图像（如深度传感器）</td>
</tr>
<tr class="odd">
<td><code>CV_16SC1</code></td>
<td>16 位有符号单通道</td>
<td><code>short</code></td>
<td>特定算法的中间结果</td>
</tr>
<tr class="even">
<td><code>CV_32SC1</code></td>
<td>32 位有符号单通道</td>
<td><code>int</code></td>
<td>像素索引或整数计算</td>
</tr>
<tr class="odd">
<td><code>CV_32FC1</code></td>
<td>32 位浮点单通道</td>
<td><code>float</code></td>
<td>图像处理中间结果（如边缘检测）</td>
</tr>
<tr class="even">
<td><code>CV_32FC3</code></td>
<td>32 位浮点三通道</td>
<td><code>cv::Vec3f</code></td>
<td>浮点彩色数据（如 HDR）</td>
</tr>
<tr class="odd">
<td><code>CV_64FC1</code></td>
<td>64 位双精度浮点单通道</td>
<td><code>double</code></td>
<td>高精度计算（如几何变换）</td>
</tr>
</tbody>
</table>
<h4 id="特殊类型与限制">1.7.3. 特殊类型与限制</h4>
<ul>
<li><p><strong>通道数限制</strong>： 默认支持 1~4 通道。超过 4
通道需自定义，如通过 <code>CV_MAKETYPE</code> 宏创建：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CV_8UC(n) CV_MAKETYPE(CV_8U, n)  <span class="comment">// 例如 CV_8UC(5) 表示 5 通道</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>默认图像类型</strong>： OpenCV 读取图像的默认格式为
<code>CV_8UC3</code>（BGR 三通道彩色）。</p></li>
<li><p><strong>浮点图像范围</strong>： <code>CV_32F</code> 或
<code>CV_64F</code> 类型的数据范围通常为 <code>[0.0, 1.0]</code> 或
<code>[0, 255]</code>，需根据算法做归一化。</p></li>
</ul>
<h4 id="类型转换与创建">1.7.4. 类型转换与创建</h4>
<ul>
<li><p><strong>创建指定类型的 <code>cv::Mat</code> 矩阵</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">img_float</span><span class="params">(<span class="number">480</span>, <span class="number">640</span>, CV_32FC3)</span></span>;  <span class="comment">// 创建一个 32 位浮点三通道矩阵</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">img_gray</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>, CV_8UC1, cv::Scalar(<span class="number">0</span>))</span></span>; <span class="comment">// 创建单通道灰度图</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>类型转换</strong>： 使用
<code>cv::Mat::convertTo()</code> 或 <code>cv::cvtColor()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat img_uint8;</span><br><span class="line">img_float.<span class="built_in">convertTo</span>(img_uint8, CV_8UC3, <span class="number">255.0</span>); <span class="comment">// 将浮点图像转为 8UC3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="示例">1.7.5. 示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 3 通道 8UC3 的红色图像</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">red_image</span><span class="params">(<span class="number">300</span>, <span class="number">300</span>, CV_8UC3, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建一个单通道 32 位浮点矩阵</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">float_mat</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>, CV_32FC1, cv::Scalar(<span class="number">0.5f</span>))</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结">1.7.6. 总结</h4>
<p><code>CV_</code>
数据类型定义了矩阵中元素的存储格式，选择时需考虑以下因素：</p>
<ol type="1">
<li>数据范围（如 8 位足够表示 0-255 的像素）。</li>
<li>是否需要浮点运算（如几何变换需要高精度）。</li>
<li>通道数需求（如彩色图像需 3 通道）。</li>
</ol>
<hr />
<h2 id="图像扫描查找表与性能优化">2. 图像扫描、查找表与性能优化 <span
id="ch2"></span></h2>
<p>通过一个实际的<strong>颜色空间缩减</strong>示例，快速掌握 OpenCV
中图像处理的三大核心技能：<strong>图像扫描方法</strong>、<strong>查找表（LUT）的应用</strong>以及<strong>算法性能测量</strong>。</p>
<h3 id="图像矩阵的内存存储">2.1. 图像矩阵的内存存储</h3>
<p>在 OpenCV 中，图像数据以 <code>Mat</code>
对象存储，其内存布局与颜色通道紧密相关：</p>
<ol type="1">
<li><strong>灰度图像</strong>：每个像素对应一个 <code>uchar</code>
值（0-255），按行连续存储。</li>
<li><strong>彩色图像（BGR）</strong>：每个像素包含3个通道（蓝、绿、红），每个通道一个
<code>uchar</code> 值。<br />
<strong>注意</strong>：OpenCV 默认使用 BGR 顺序而非 RGB ！</li>
</ol>
<p>内存中的存储方式</p>
<ul>
<li><strong>按行连续存储</strong>：像素按行优先顺序排列，每行（row）称为一个
“高度”维度。</li>
<li><strong>多通道数据</strong>：每个像素的通道值连续存储。
<ul>
<li>例如，BGR 图像的像素存储顺序为
<code>[B0, G0, R0, B1, G1, R1, ...]</code> 。</li>
</ul></li>
<li>可能的填充字节 (Padding)
<ul>
<li>某些情况下，每行末尾可能有对齐填充（用 <code>step</code>
属性表示实际每行的字节数）。</li>
</ul></li>
</ul>
<p>通过 <code>Mat::isContinuous()</code>
可判断矩阵是否连续存储。若连续，可将图像视为一维数组处理，提升遍历效率。</p>
<h3 id="颜色空间缩减示例">2.2. 颜色空间缩减示例</h3>
<p>假设我们需要将图像颜色值从 256 级缩减到更少的级别（例如每 10
个值合并为一个）。直接计算公式为：<br />
<span class="math display">\[\nonumber
I_{\text{new}} = \lfloor \frac{I_{\text{old}}}{10} \rfloor \times 10
\]</span></p>
<p>但频繁的除法和乘法会拖慢性能。此时，<strong>查找表（Lookup Table,
LUT）</strong>可预先计算所有可能的输入值对应的输出值，后续直接替换，大幅提升效率。</p>
<h4 id="查找表生成代码">2.2.1. 查找表生成代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> divideWith = <span class="number">10</span>;</span><br><span class="line">uchar table[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">    table[i] = (uchar)(divideWith * (i/divideWith));    <span class="comment">// 自动向下取整</span></span><br></pre></td></tr></table></figure>
<h3 id="图像扫描方法对比">2.3. 图像扫描方法对比</h3>
<h4 id="高效方法指针访问">2.3.1. 高效方法：指针访问</h4>
<p>通过指针直接操作内存，适合连续存储的图像。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat&amp; <span class="title">ScanImageWithPointer</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> uchar* table)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CV_Assert</span>(image.<span class="built_in">depth</span>() == CV_8U);  <span class="comment">// 仅处理8位图像</span></span><br><span class="line">    <span class="type">int</span> channels = image.<span class="built_in">channels</span>();</span><br><span class="line">    <span class="type">int</span> rows = image.rows;</span><br><span class="line">    <span class="type">int</span> cols = image.cols * channels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">isContinuous</span>()) &#123;</span><br><span class="line">        cols *= rows;</span><br><span class="line">        rows = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        uchar* p = image.<span class="built_in">ptr</span>&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">            p[j] = table[p[j]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="安全方法迭代器">2.3.2. 安全方法：迭代器</h4>
<p>使用 OpenCV 迭代器自动处理行间隙，代码更安全。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat&amp; <span class="title">ScanImageWithIterator</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> uchar* table)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CV_Assert</span>(image.<span class="built_in">depth</span>() == CV_8U);</span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">channels</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        cv::MatIterator_&lt;uchar&gt; it = image.<span class="built_in">begin</span>&lt;uchar&gt;();</span><br><span class="line">        cv::MatIterator_&lt;uchar&gt; end = image.<span class="built_in">end</span>&lt;uchar&gt;();</span><br><span class="line">        <span class="keyword">for</span> (; it != end; ++it)</span><br><span class="line">            *it = table[*it];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">channels</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">        cv::MatIterator_&lt;cv::Vec3b&gt; it = image.<span class="built_in">begin</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">        cv::MatIterator_&lt;cv::Vec3b&gt; end = image.<span class="built_in">end</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">        <span class="keyword">for</span> (; it != end; ++it) &#123;</span><br><span class="line">            (*it)[<span class="number">0</span>] = table[(*it)[<span class="number">0</span>]];  <span class="comment">// B通道</span></span><br><span class="line">            (*it)[<span class="number">1</span>] = table[(*it)[<span class="number">1</span>]];  <span class="comment">// G通道</span></span><br><span class="line">            (*it)[<span class="number">2</span>] = table[(*it)[<span class="number">2</span>]];  <span class="comment">// R通道</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态地址计算at-方法">2.3.3. 动态地址计算：<code>at</code>
方法</h4>
<p>适用于随机访问，但全图扫描时性能较差。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat&amp; <span class="title">ScanImageWithAt</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> uchar* table)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CV_Assert</span>(image.<span class="built_in">depth</span>() == CV_8U);</span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">channels</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image.rows; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image.cols; ++j)</span><br><span class="line">                image.<span class="built_in">at</span>&lt;uchar&gt;(i, j) = table[image.<span class="built_in">at</span>&lt;uchar&gt;(i, j)];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">channels</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">        cv::Mat_&lt;cv::Vec3b&gt; _I = image;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image.rows; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image.cols; ++j) &#123;</span><br><span class="line">                _I(i, j)[<span class="number">0</span>] = table[_I(i, j)[<span class="number">0</span>]];  <span class="comment">// B通道</span></span><br><span class="line">                _I(i, j)[<span class="number">1</span>] = table[_I(i, j)[<span class="number">1</span>]];  <span class="comment">// G通道</span></span><br><span class="line">                _I(i, j)[<span class="number">2</span>] = table[_I(i, j)[<span class="number">2</span>]];  <span class="comment">// R通道</span></span><br><span class="line">            &#125;</span><br><span class="line">        image = _I;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="终极优化opencv-内置-lut-函数">2.4. 终极优化：OpenCV 内置 LUT
函数</h3>
<p>使用 <code>cv::LUT()</code> 函数，底层优化更高效，支持多线程。</p>
<p><code>void cv::LUT (InputArray src, InputArray lut, OutputArray  dst)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">ApplyLUT</span><span class="params">(cv::Mat&amp; image, <span class="type">const</span> uchar* table)</span> </span>&#123;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">lookupTable</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line">    uchar* p = lookupTable.<span class="built_in">ptr</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) p[i] = table[i];</span><br><span class="line">    </span><br><span class="line">    cv::Mat result;</span><br><span class="line">    cv::<span class="built_in">LUT</span>(image, lookupTable, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能对比">2.5. 性能对比</h3>
<p>通过 <code>cv::getTickCount()</code> 和
<code>cv::getTickFrequency()</code> 测量时间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> t = (<span class="type">double</span>)cv::<span class="built_in">getTickCount</span>();</span><br><span class="line"><span class="comment">// 执行扫描操作</span></span><br><span class="line">t = ((<span class="type">double</span>)cv::<span class="built_in">getTickCount</span>() - t) / cv::<span class="built_in">getTickFrequency</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;耗时（秒）: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">方法</th>
<th style="text-align: left;">平均耗时（毫秒）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">指针访问</td>
<td style="text-align: left;">79.47</td>
</tr>
<tr class="even">
<td style="text-align: left;">迭代器</td>
<td style="text-align: left;">83.72</td>
</tr>
<tr class="odd">
<td style="text-align: left;">动态地址计算（at）</td>
<td style="text-align: left;">93.78</td>
</tr>
<tr class="even">
<td style="text-align: left;">LUT函数</td>
<td style="text-align: left;"><strong>32.58</strong></td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>：</p>
<ol type="1">
<li><strong>优先使用 OpenCV 内置函数</strong>（如
<code>LUT()</code>），性能最佳。</li>
<li>需要自定义遍历时，<strong>指针访问</strong>最快，<strong>迭代器</strong>更安全。</li>
<li>避免在循环中使用 <code>at</code> 方法进行全图扫描。</li>
</ol>
<h3 id="实战建议">2.6. 实战建议</h3>
<ul>
<li><strong>连续存储优化</strong>：若图像连续（<code>isContinuous() == true</code>），可将其视为一维数组处理。</li>
<li><strong>多通道处理</strong>：注意 BGR
顺序，遍历时需分别操作每个通道。</li>
<li><strong>调试技巧</strong>：在 Debug模 式下，<code>at</code>
方法会检查越界访问，适合快速定位错误。</li>
</ul>
<hr />
<h2 id="图像处理中的掩膜操作">3. 图像处理中的掩膜操作</h2>
<p>图像处理是计算机视觉的核心技术之一，而 OpenCV
作为最流行的开源库，为开发者提供了丰富的工具。本节将介绍 OpenCV
中的<strong>掩膜操作</strong>（Mask
Operations），以图像对比度增强为例，理解其原理与实现。</p>
<h3 id="什么是掩膜操作">3.1. 什么是掩膜操作？</h3>
<p>掩膜操作通过一个称为 <strong>内核（Kernel）</strong> 或
<strong>掩膜（Mask）</strong>
的小矩阵，对图像中的每个像素进行加权计算，从而调整其值。这种操作本质上是将当前像素及其邻域像素的值按权重相加，常用于图像滤波、边缘检测、锐化等任务。</p>
<p>例如，对比度增强的公式为：<br />
<span class="math display">\[ \nonumber I(i,j) = 5 \cdot I(i,j) -
[I(i-1,j) + I(i+1,j) + I(i,j-1) + I(i,j+1)] \]</span></p>
<p>对应的内核矩阵为：<br />
<span class="math display">\[ \nonumber
M = \begin{bmatrix}
0 &amp; -1 &amp; 0 \\
-1 &amp; 5 &amp; -1 \\
0 &amp; -1 &amp; 0
\end{bmatrix}
\]</span><br />
中心像素权重为 5，上下左右像素权重为 -1，其余为 0
。通过该内核，可以突出中心像素，增强图像细节。</p>
<h3 id="手动实现掩膜操作">3.2. 手动实现掩膜操作</h3>
<h4 id="关键步骤">3.2.1. 关键步骤</h4>
<ol type="1">
<li><strong>边界处理</strong>：图像边缘的像素缺少邻域，通常直接设为0。</li>
<li><strong>遍历像素</strong>：使用指针逐行访问像素，避免直接修改原图。</li>
<li><strong>加权计算</strong>：根据内核公式重新计算每个像素的值。</li>
</ol>
<h4 id="代码示例简化版">3.2.2. 代码示例（简化版）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sharpen</span><span class="params">(<span class="type">const</span> cv::Mat&amp; input, cv::Mat&amp; output)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CV_Assert</span>(input.<span class="built_in">depth</span>() == CV_8U);  <span class="comment">// 确保输入图像为8位图像</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channels = input.<span class="built_in">channels</span>();</span><br><span class="line">    output.<span class="built_in">create</span>(input.<span class="built_in">size</span>(), input.<span class="built_in">type</span>());  <span class="comment">// 创建与输入图像大小和类型相同的输出图像</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">1</span>; row &lt; input.rows - <span class="number">1</span>; row++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> uchar* prev = input.<span class="built_in">ptr</span>&lt;uchar&gt;(row - <span class="number">1</span>);  <span class="comment">// 获取上一行的指针</span></span><br><span class="line">        <span class="type">const</span> uchar* curr = input.<span class="built_in">ptr</span>&lt;uchar&gt;(row);  <span class="comment">// 获取当前行的指针</span></span><br><span class="line">        <span class="type">const</span> uchar* next = input.<span class="built_in">ptr</span>&lt;uchar&gt;(row + <span class="number">1</span>);  <span class="comment">// 获取下一行的指针</span></span><br><span class="line">        uchar* out = output.<span class="built_in">ptr</span>&lt;uchar&gt;(row);    <span class="comment">// 获取输出图像当前行的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = channels; col &lt; channels * (input.cols - <span class="number">1</span>); col++) &#123;</span><br><span class="line">            <span class="comment">// 应用公式：5*当前像素 - 上下左右像素</span></span><br><span class="line">            out[col] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(</span><br><span class="line">                <span class="number">5</span> * curr[col] - (curr[col - channels] + curr[col + channels] + prev[col] + next[col])</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界置0</span></span><br><span class="line">    output.<span class="built_in">row</span>(<span class="number">0</span>).<span class="built_in">setTo</span>(cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    output.<span class="built_in">row</span>(output.rows - <span class="number">1</span>).<span class="built_in">setTo</span>(cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    output.<span class="built_in">col</span>(<span class="number">0</span>).<span class="built_in">setTo</span>(cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    output.<span class="built_in">col</span>(output.cols - <span class="number">1</span>).<span class="built_in">setTo</span>(cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="note info"><summary><p><code>cv::saturate_cast</code></p>
</summary>
<p>在图像处理方面，无论是加是减，乘除，都可能会超出一个像素灰度值的范围（0～255），<code>saturate_cast</code>
函数的作用即是：当运算完之后，结果为负，则转为 0，结果超出 255，则为
255。</p>

</details>
<h3 id="使用opencv内置函数-filter2d">3.3. 使用OpenCV内置函数
<code>filter2D</code></h3>
<p>手动实现掩膜操作虽然直观，但代码冗长且效率较低。OpenCV 提供了
<code>filter2D</code>
函数，可直接应用内核矩阵，代码更简洁且性能更优。</p>
<h4 id="代码示例">3.3.1. 代码示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat kernel = (cv::<span class="built_in">Mat_</span>&lt;<span class="type">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; </span><br><span class="line">    <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">);</span><br><span class="line">cv::Mat result;</span><br><span class="line"><span class="comment">// void filter2D( InputArray src, OutputArray dst, int ddepth,</span></span><br><span class="line"><span class="comment">//              InputArray kernel, Point anchor = Point(-1,-1), double delta = 0,</span></span><br><span class="line"><span class="comment">//              int borderType = BORDER_DEFAULT );</span></span><br><span class="line">cv::<span class="built_in">filter2D</span>(input, result, input.<span class="built_in">depth</span>(), kernel);</span><br></pre></td></tr></table></figure>
<h4 id="优势">3.3.2. 优势</h4>
<ul>
<li><strong>高效性</strong>：内置函数经过优化，速度更快（测试中手动实现需
31ms，<code>filter2D</code> 仅需 13ms）。</li>
<li><strong>灵活性</strong>：支持自定义内核中心、边界处理模式（如填充、镜像等）。</li>
</ul>
<h3 id="性能对比与适用场景">3.4. 性能对比与适用场景</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">方法</th>
<th style="text-align: center;">优点</th>
<th style="text-align: center;">缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">手动实现</td>
<td style="text-align: center;">理解底层原理，灵活调试</td>
<td style="text-align: center;">代码复杂，性能较低</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>filter2D</code></td>
<td style="text-align: center;">简洁高效，支持高级功能</td>
<td style="text-align: center;">需熟悉内核矩阵的构建</td>
</tr>
</tbody>
</table>
<p><strong>推荐场景</strong>：</p>
<ul>
<li>学习阶段：建议手动实现，深入理解像素操作原理。<br />
</li>
<li>实际项目：优先使用 <code>filter2D</code>
，提升效率并减少代码量。</li>
</ul>
<h3 id="总结-1">3.5. 总结</h3>
<p>掩膜操作是图像处理的基础技术，OpenCV
提供了灵活的实现方式。通过对比手动实现与内置函数，开发者可以根据需求选择最佳方案。掌握这一技术后，可进一步探索高斯模糊、边缘检测（如
Sobel 算子）等进阶应用。</p>
<p><strong>动手尝试</strong>：</p>
<ol type="1">
<li>修改内核矩阵，观察图像变化（例如锐化、模糊）。<br />
</li>
<li>对比不同边界处理模式的效果（如 <code>BORDER_REFLECT</code> 或
<code>BORDER_CONSTANT</code> ）。</li>
</ol>
<hr />
<h2 id="图像基础操作">4. 图像基础操作</h2>
<p>介绍图像处理的基础操作，涵盖图像加载、像素操作、内存管理及可视化等核心内容。</p>
<h3 id="图像输入输出">4.1. 图像输入输出</h3>
<h4 id="加载图像">4.1.1. 加载图像</h4>
<p>使用 <code>cv::imread</code> 加载图像时，默认读取为 BGR
三通道格式。若需灰度图，需显式指定参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat img = cv::<span class="built_in">imread</span>(<span class="string">&quot;image.jpg&quot;</span>); <span class="comment">// 三通道BGR图像</span></span><br><span class="line">cv::Mat gray_img = cv::<span class="built_in">imread</span>(<span class="string">&quot;image.jpg&quot;</span>, cv::IMREAD_GRAYSCALE); <span class="comment">// 单通道灰度图</span></span><br></pre></td></tr></table></figure>
<h4 id="保存图像">4.1.2. 保存图像</h4>
<p>图像保存格式由文件扩展名决定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">imwrite</span>(<span class="string">&quot;output.png&quot;</span>, img); <span class="comment">// 保存为PNG格式</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：若需从内存读写图像，使用
<code>cv::imdecode</code> 和 <code>cv::imencode</code>。</p>
</blockquote>
<h3 id="像素操作">4.2. 像素操作</h3>
<h4 id="访问像素值">4.2.1. 访问像素值</h4>
<ul>
<li><p><strong>单通道灰度图</strong>（8UC1）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uchar intensity = img.<span class="built_in">at</span>&lt;uchar&gt;(y, x); <span class="comment">// 注意坐标顺序为(y, x)</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>三通道 BGR 图像</strong>（8UC3）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Vec3b bgr_pixel = img.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(y, x);</span><br><span class="line">uchar blue = bgr_pixel[<span class="number">0</span>];  <span class="comment">// B通道</span></span><br><span class="line">uchar green = bgr_pixel[<span class="number">1</span>]; <span class="comment">// G通道</span></span><br><span class="line">uchar red = bgr_pixel[<span class="number">2</span>];   <span class="comment">// R通道</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="修改像素值">4.2.2. 修改像素值</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">img.<span class="built_in">at</span>&lt;uchar&gt;(y, x) = <span class="number">128</span>; <span class="comment">// 将灰度图像素设为128</span></span><br><span class="line">img.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(y, x) = cv::<span class="built_in">Vec3b</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 设为蓝色</span></span><br></pre></td></tr></table></figure>
<h3 id="内存管理与引用计数">4.3. 内存管理与引用计数</h3>
<h4 id="数据共享机制">4.3.1. 数据共享机制</h4>
<p><code>cv::Mat</code>
通过引用计数管理内存，多个实例可共享同一数据块：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;cv::Point3f&gt; points;</span><br><span class="line"><span class="comment">// ...填充数据</span></span><br><span class="line">cv::Mat points_mat = cv::<span class="built_in">Mat</span>(points).<span class="built_in">reshape</span>(<span class="number">1</span>); <span class="comment">// 共享数据，不复制</span></span><br></pre></td></tr></table></figure>
<h4 id="显式复制数据">4.3.2. 显式复制数据</h4>
<p>需独立操作数据时，使用 <code>clone()</code> 或
<code>copyTo()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat img_clone = img.<span class="built_in">clone</span>(); <span class="comment">// 深拷贝</span></span><br><span class="line">cv::Mat img_copy;</span><br><span class="line">img.<span class="built_in">copyTo</span>(img_copy); <span class="comment">// 深拷贝（目标为空矩阵时）</span></span><br></pre></td></tr></table></figure>
<h3 id="基本图像操作">4.4. 基本图像操作</h3>
<h4 id="图像置黑">4.4.1. 图像置黑</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">img = cv::<span class="built_in">Scalar</span>(<span class="number">0</span>); <span class="comment">// 所有像素设为0（黑色）</span></span><br></pre></td></tr></table></figure>
<h4 id="选择感兴趣区域roi">4.4.2. 选择感兴趣区域（ROI）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Rect <span class="title">roi</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>)</span></span>; <span class="comment">// (x, y, width, height)</span></span><br><span class="line">cv::Mat small_img = <span class="built_in">img</span>(roi);   <span class="comment">// 提取ROI</span></span><br></pre></td></tr></table></figure>
<h4 id="颜色空间转换">4.4.3. 颜色空间转换</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat gray;</span><br><span class="line">cv::<span class="built_in">cvtColor</span>(img, gray, cv::COLOR_BGR2GRAY); <span class="comment">// BGR转灰度</span></span><br></pre></td></tr></table></figure>
<h4 id="图像类型转换">4.4.4. 图像类型转换</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat src_32f;</span><br><span class="line">src.<span class="built_in">convertTo</span>(src_32f, CV_32F); <span class="comment">// 8UC1转32FC1</span></span><br></pre></td></tr></table></figure>
<h3 id="图像可视化">4.5. 图像可视化</h3>
<h4 id="显示-8-位图像">4.5.1. 显示 8 位图像</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Display&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line">cv::<span class="built_in">imshow</span>(<span class="string">&quot;Display&quot;</span>, img);</span><br><span class="line">cv::<span class="built_in">waitKey</span>(<span class="number">0</span>); <span class="comment">// 等待按键</span></span><br></pre></td></tr></table></figure>
<h4 id="显示浮点图像">4.5.2. 显示浮点图像</h4>
<p>需将 32F 类型归一化到 0~255 范围：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat sobelx;</span><br><span class="line">cv::<span class="built_in">Sobel</span>(gray, sobelx, CV_32F, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 计算Sobel梯度</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> min_val, max_val;</span><br><span class="line">cv::<span class="built_in">minMaxLoc</span>(sobelx, &amp;min_val, &amp;max_val); <span class="comment">// 获取极值</span></span><br><span class="line"></span><br><span class="line">cv::Mat draw;</span><br><span class="line">sobelx.<span class="built_in">convertTo</span>(draw, CV_8U, <span class="number">255.0</span>/(max_val - min_val), -min_val*<span class="number">255.0</span>/(max_val - min_val));</span><br><span class="line">cv::<span class="built_in">imshow</span>(<span class="string">&quot;Sobel&quot;</span>, draw);</span><br><span class="line">cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">cv::<span class="built_in">destroyWindow</span>(<span class="string">&quot;Sobel&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="总结-2">4.6. 总结</h3>
<p>介绍了 OpenCV
中图像处理的基础操作，包括加载/保存、像素访问、内存管理和可视化。可以进一步结合官方文档探索高级功能（如滤波、特征检测等）。</p>
<hr />
<h2 id="使用cvaddweighted实现图像线性混合">5.
使用cv::addWeighted实现图像线性混合</h2>
<p>在计算机视觉中，图像混合是一项基础且实用的技术。通过调整权重参数，可以实现两张图片的平滑过渡效果，例如幻灯片切换或视频转场。本节介绍如何使用
<code>cv::addWeighted</code> 函数实现图像的线性混合。</p>
<h3 id="理论背景">5.1. 理论背景</h3>
<p>线性混合的数学表达式为：<br />
<span class="math display">\[\nonumber
g(x) = (1 - \alpha) \cdot f_0(x) + \alpha \cdot f_1(x)
\]</span><br />
其中，<span class="math inline">\(\alpha\)</span> 的取值范围为 <span
class="math inline">\([0, 1]\)</span>。当 <span
class="math inline">\(\alpha\)</span> 从 0 逐渐增加到 1 时，输出图像会从
<span class="math inline">\(f_0\)</span> 平滑过渡到 <span
class="math inline">\(f_1\)</span>。</p>
<h3 id="代码实现">5.2. 代码实现</h3>
<p>以下是使用 C++ 和 OpenCV 实现图像混合的完整代码：</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;opencv2/opencv.hpp&gt;</span><span class="pp">  </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span><span class="pp">  </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">&#123;</span>  </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> alpha <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span>  </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> beta<span class="op">,</span> user_input<span class="op">;</span>  </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 读取两张图片  </span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    cv<span class="op">::</span>Mat src1 <span class="op">=</span> cv<span class="op">::</span>imread<span class="op">(</span>cv<span class="op">::</span>samples<span class="op">::</span>findFile<span class="op">(</span><span class="st">&quot;LinuxLogo.jpg&quot;</span><span class="op">));</span>  </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    cv<span class="op">::</span>Mat src2 <span class="op">=</span> cv<span class="op">::</span>imread<span class="op">(</span>cv<span class="op">::</span>samples<span class="op">::</span>findFile<span class="op">(</span><span class="st">&quot;WindowsLogo.jpg&quot;</span><span class="op">));</span>  </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 检查图片是否加载成功  </span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>src1<span class="op">.</span>empty<span class="op">())</span> <span class="op">&#123;</span>  </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;错误：无法加载src1&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span>  </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span>  </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>src2<span class="op">.</span>empty<span class="op">())</span> <span class="op">&#123;</span>  </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;错误：无法加载src2&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span>  </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span>  </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span>  </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 获取用户输入的alpha值  </span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;请输入alpha值（0.0-1.0）: &quot;</span><span class="op">;</span>  </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> user_input<span class="op">;</span>  </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>user_input <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> user_input <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">&#123;</span>  </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> user_input<span class="op">;</span>  </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span>  </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> alpha<span class="op">;</span>  </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    cv<span class="op">::</span>Mat dst<span class="op">;</span>  </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 执行线性混合</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// void addWeighted(InputArray src1, double alpha, InputArray src2,</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                  double beta, double gamma, OutputArray dst,</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                  int //dtype = -1);</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    cv<span class="op">::</span>addWeighted<span class="op">(</span>src1<span class="op">,</span> alpha<span class="op">,</span> src2<span class="op">,</span> beta<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> dst<span class="op">);</span>  </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 显示结果  </span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    cv<span class="op">::</span>imshow<span class="op">(</span><span class="st">&quot;混合结果&quot;</span><span class="op">,</span> dst<span class="op">);</span>  </span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    cv<span class="op">::</span>waitKey<span class="op">(</span><span class="dv">0</span><span class="op">);</span>  </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>  </span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span>  </span></code></pre></div>
<h3 id="关键代码解析">5.3. 关键代码解析</h3>
<ol type="1">
<li><strong>加载图片</strong>
<ul>
<li>使用 <code>cv::imread</code> 读取图片，并通过
<code>cv::samples::findFile</code> 确保路径正确。<br />
</li>
</ul></li>
<li><strong>输入验证</strong>
<ul>
<li>用户输入的 <span class="math inline">\(\alpha\)</span> 值通过
<code>std::cin</code> 获取，并限制在 <code>[0, 1]</code> 范围内。<br />
</li>
</ul></li>
<li><strong>混合计算</strong>
<ul>
<li><code>cv::addWeighted</code> 函数的参数依次为：
<ul>
<li><code>src1</code>：第一张输入图像。<br />
</li>
<li><code>alpha</code>：第一张图像的权重。<br />
</li>
<li><code>src2</code>：第二张输入图像。<br />
</li>
<li><code>beta</code>：第二张图像的权重（通常为 <code>1 - alpha</code>
）。<br />
</li>
<li><code>gamma</code>：标量偏移量（此处设为0）。<br />
</li>
<li><code>dst</code>：输出图像。</li>
</ul></li>
</ul></li>
</ol>
<h3 id="注意事项">5.4. 注意事项</h3>
<ol type="1">
<li><strong>图片尺寸与类型</strong>
<ul>
<li>输入的两张图像必须具有相同的尺寸（宽度和高度）和数据类型，否则会导致运行时错误。<br />
</li>
</ul></li>
<li><strong>扩展应用</strong>
<ul>
<li>此技术可用于创建动态效果，如视频淡入淡出、AR 场景叠加等。</li>
</ul></li>
</ol>
<h3 id="总结-3">5.5. 总结</h3>
<p>通过 <code>cv::addWeighted</code> 函数，OpenCV
为图像混合提供了一种简洁高效的实现方式。掌握这一技术后，可以进一步探索更复杂的图像处理任务，如图像融合、遮罩处理等。</p>
<a href="/2025/01/27/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/" title="OpenCV入门学习-核心功能（二）">OpenCV入门学习-核心功能（二）</a>
<hr />
<h2 id="参考资料">6. 参考资料</h2>
<p><strong>[1]</strong> <a
href="https://docs.opencv.org/4.x/de/d7a/tutorial_table_of_content_core.html">OpenCV
官方文档</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>C/C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>主成分分析-PCA</title>
    <url>/2025/01/20/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-PCA/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="概要">1. 概要</h2>
<p>主成分分析 (principal component analysis,PCA)</p>
<ul>
<li>无监督学习方法</li>
<li><strong>线性</strong>降维</li>
<li>数据压缩</li>
</ul>
<h2 id="推导">2. 推导</h2>
<h3 id="符号说明">2.1. 符号说明</h3>
<ul>
<li>数据 <span class="math inline">\(X\in \mathbb{R}^{n\times
p}\)</span>，<span class="math inline">\(n\)</span> 是样本个数，<span
class="math inline">\(p\)</span> 是特征个数
<ul>
<li>数据需要<strong>预处理</strong>：<strong>去中心化</strong>，每个样本减去均值即可</li>
</ul></li>
<li>投影矩阵 <span class="math inline">\(W \in \mathbb{R}^{p\times
k}\)</span>，<span class="math inline">\(p\)</span> 同上，<span
class="math inline">\(k\)</span> 是降维后特征个数</li>
<li>矩阵 <span class="math inline">\(A\)</span> 的 <span
class="math inline">\(F\)</span> 范数 <span
class="math display">\[\|A\|_{F} =
\sqrt{\sum_{i}\sum_j|a_{ij}|^2}=\sqrt{\mathrm{Tr}(A^TA)}\nonumber\]</span></li>
</ul>
<h3 id="最小重构误差">2.2. 最小重构误差</h3>
<p>重投影的数据和原始数据之间的误差最小，从而丢失的信息少。<br />
数学描述： <span class="math display">\[
\begin{array}{c}
\underset{W}{\min }\ \|X-XWW^T\|_{F}^{2}\\
\text{s.t.}\quad W^TW=I_k
\end{array}
\]</span></p>
<h3 id="最大可分性">2.3. 最大可分性</h3>
<p>数据经过投影矩阵变换到超平面上之后的数据尽可能分开，即投影后数据的方差尽可能的大，从而保留的信息多。<br />
数学描述： <span class="math display">\[
\begin{array}{c}
\underset{W}{\max }\ \|XW\|_{F}^{2}\\
\text{s.t.}\quad W^TW=I_k
\end{array}
\]</span></p>
<h3 id="最小重构和最大可分等价">2.4. 最小重构和最大可分等价</h3>
<p><span class="math display">\[\label{优化}
\begin{aligned}
\underset{W}{\min }\|X-XWW^T\|_{F}^{2}
&amp;=\underset{W}{\min } \
\mathrm{Tr}\left(\left(X-XWW^T\right)^T\left(X-XWW^T\right)\right)\\
&amp;={\small \underset{W}{\min } \
\mathrm{Tr}\left(X^TX-X^TXWW^T-WW^TX^TX+WW^TX^TXWW^T \right)}\\
&amp;=\underset{W}{\min } \ \mathrm{Tr}\left(-2W^TX^TXW
+W^TX^TXWW^TW\right)\\
&amp;=\underset{W}{\min } \ \mathrm{Tr}\left(-W^TX^TXW\right)\\
&amp;=\underset{W}{\max } \ \mathrm{Tr}\left(W^TX^TXW\right)\\
&amp;=\underset{W}{\max } \
\mathrm{Tr}\left(\left(XW\right)^TXW\right)\\
&amp;=\underset{W}{\max } \|XW\|_{F}^{2}
\end{aligned}
\]</span></p>
<h2 id="求解">3. 求解</h2>
<p>由 <span class="math inline">\(\eqref{优化}\)</span> 可知，目标函数为
<span class="math display">\[\label{目标函数}
\begin{array}{c}
\underset{W}{\min }\ -\mathrm{Tr}\left(W^TX^TXW\right)=\underset{W}{\max
} \ \mathrm{Tr}\left(W^TX^TXW\right) \\
\text{s.t.}\quad W^TW=I_k
\end{array}
\]</span></p>
<p>可以用<strong>拉格朗日乘子法</strong>求解带约束的优化问题。</p>
<p>拉格朗日函数 <span class="math display">\[
\mathcal{L}\left(W,\Lambda\right)=-\mathrm{Tr}\left(W^TX^TXW\right)+\mathrm{Tr}\left(\Lambda^T
\left(W^TW-I_k\right)\right)
\]</span> 其中 <span class="math inline">\(\Lambda =
diag(\lambda_1,\lambda_2,\dots,\lambda_{k})\in \mathbb{R}^{k\times
k}\)</span></p>
<p>求解 <span class="math display">\[
\begin{aligned}
    \frac{\partial \mathcal{L}}{\partial W}&amp;= -2X^TXW +
2W\Lambda=0\\
    \frac{\partial \mathcal{L}}{\partial \Lambda}&amp;=W^TW-I_k=0 \\
\end{aligned}
\]</span></p>
<p>则有 <span class="math display">\[\label{显式解}
X^TXW=W\Lambda
\]</span></p>
<p>将 <span class="math inline">\(W,\Lambda\)</span> 展开 <span
class="math display">\[
\begin{aligned}\nonumber
W &amp;=
[\boldsymbol{w}_1,\boldsymbol{w}_2,\dots,\boldsymbol{w}_k]\in\mathbb{R}^{p\times
k} ,\quad \boldsymbol{w}_i\in\mathbb{R}^{p\times 1}\\
\Lambda &amp;= diag(\lambda_1,\lambda_2,\dots,\lambda_{k})\in
\mathbb{R}^{k\times k},\quad \lambda_i \in \mathbb{R}
\end{aligned}
\]</span> 注意到 <span class="math display">\[\label{约束}
\boldsymbol{w}_i^T\boldsymbol{w}_i=1 ,\quad
\boldsymbol{w}_i^T\boldsymbol{w}_j=0\ \left(i\neq j\right)
\]</span> 则有 <span class="math display">\[\label{特征解}
X^T X \boldsymbol{w}_i = \lambda_i \boldsymbol{w}_i \ ,\quad
i=1,2,\dots,k
\]</span> 显然，此式为矩阵特征值和特征向量的定义式，其中 <span
class="math inline">\(\lambda_i,w_i\)</span> 分别表示矩阵 <span
class="math inline">\(X^TX\)</span> 的特征值和单位特征向量。</p>
<p>因为 <span class="math inline">\(X^TX\)</span>
为实对称阵，而实对称阵不同特征值对应的特征向量之间是相互正交的，同一特征值的不同特征向量可以通过施密特正交化使其正交，所以通过
<span class="math inline">\(\eqref{特征解}\)</span> 求的 <span
class="math inline">\(\boldsymbol{w}_i\)</span> 满足约束 <span
class="math inline">\(\eqref{约束}\)</span>。<br />
根据拉格朗日乘子法的原理可知，此时求得的结果仅是最优解的必要条件，而且
<span class="math inline">\(X^TX\)</span> 有 <span
class="math inline">\(p\)</span>
个相互正交的单位特征向量，所以还需要从这 <span
class="math inline">\(p\)</span> 个特征向量里找出 <span
class="math inline">\(k\)</span>
个能使得目标函数达到最优值的特征向量作为最优解。</p>
<p>将 <span class="math inline">\(\eqref{显式解}\)</span> 带入目标函数
<span class="math inline">\(\eqref{目标函数}\)</span> <span
class="math display">\[
\begin{aligned}
\underset{W}{\max }\ \mathrm{Tr}\left(W^TX^TXW\right)
&amp;=\underset{W}{\max }\ \mathrm{Tr}\left(W^T W\Lambda\right)\\
&amp;=\underset{W}{\max }\ \mathrm{Tr}\left(\Lambda\right)\\
&amp;=\underset{W}{\max }\ \sum_{i=1}^{k}\lambda_i
\end{aligned}
\]</span> 显然此时只需要令 <span
class="math inline">\(\lambda_1,\lambda_2,\dots,\lambda_k\)</span> 和
<span
class="math inline">\(\boldsymbol{w}_1,\boldsymbol{w}_2,\dots,\boldsymbol{w}_k\)</span>
分别为矩阵 <span class="math inline">\(X^TX\)</span> 的前 <span
class="math inline">\(k\)</span>
大特征值及其对应的特征向量即可使目标函数达到最大值。</p>
<h2 id="算法流程">4. 算法流程</h2>
<p><span class="math display">\[
\begin{array}{r l}
\textbf{PCA 算法}\\
\hline
\textbf{输入：}
&amp;\text{1. 样本数据 } X\in\mathbb{R}^{n\times p},n \text{
是样本个数},p \text{ 是样本特征个数；}\\
&amp;\text{2. 降维维度 }k \\
\textbf{过程：}
&amp;\text{1. 数据预处理，所有样本去中心化；}\\
&amp;\text{2. 计算 }X^T X \text{，并对其特征分解；}\\
&amp;\text{3. 取前 } k \text{ 大个特征值所对应的特征向量 }
w_1,w_2,\dots,w_k \text{ ；}\\
\textbf{输出：}
&amp;\text{投影矩阵 } W=[w_1,w_2,\dots,w_k] \in \mathbb{R}^{p\times k}\\
\hline
\end{array}
\]</span></p>
<p>过程 2、3 也可以使用 SVD 分解，取前 <span
class="math inline">\(k\)</span> 个右奇异向量即可。</p>
<h2 id="方差贡献率">5. 方差贡献率</h2>
<p>第 <span class="math inline">\(i\)</span> 个主成分的方差贡献率 <span
class="math display">\[
\eta_i = \frac{\lambda_i}{\sum_{j=1}^{p}\lambda_j}
\]</span></p>
<p>前 <span class="math inline">\(k\)</span> 个主成分的方差贡献率 <span
class="math display">\[
\eta = \frac{\sum_{i=1}^{k}\lambda_i}{\sum_{j=1}^{p}\lambda_j}
\]</span></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>PCA</tag>
        <tag>机器学习</tag>
        <tag>降维</tag>
      </tags>
  </entry>
  <entry>
    <title>单像空间后方交会</title>
    <url>/2025/01/18/%E5%8D%95%E5%83%8F%E7%A9%BA%E9%97%B4%E5%90%8E%E6%96%B9%E4%BA%A4%E4%BC%9A/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="概要">1. 概要</h2>
<p>单像后方交会的基本思想是<strong>至少</strong>利用三个已知地面控制点的坐标
<span class="math inline">\(A(X_A,Y_A,Z_A)\)</span>，<span
class="math inline">\(B(X_B,Y_B,Z_B)\)</span>，<span
class="math inline">\(C(X_C,Y_C,Z_C)\)</span>
，与影像上对应的三个像点的影像坐标 <span
class="math inline">\(a(x_a,y_a)\)</span>，<span
class="math inline">\(b(x_b,y_b)\)</span>，<span
class="math inline">\(c(x_c,y_c)\)</span>
，再根据共线方程，反求该像片的外方位元素 <span
class="math inline">\(X_s,Y_s,Z_s,\varphi,\omega,\kappa\)</span>。这种解法是以单张像片为基础，所以也称做单像空间后方交会。</p>
<h2 id="推导">2. 推导</h2>
<h3 id="基本关系式">2.1. 基本关系式</h3>
<p>共线方程： <span class="math display">\[
\begin{array}{c}
x=-f\frac{a_1\left( X-X_s \right) +b_1\left( Y-Y_s \right) +c_1\left(
Z-Z_s \right)}{a_3\left( X-X_s \right) +b_3\left( Y-Y_s \right)
+c_3\left( Z-Z_s \right)} \\
y=-f\frac{a_2\left( X-X_s \right) +b_2\left( Y-Y_s \right) +c_2\left(
Z-Z_s \right)}{a_3\left( X-X_s \right) +b_3\left( Y-Y_s \right)
+c_3\left( Z-Z_s \right)} \\
\end{array}
\]</span></p>
<p>为了方便计算，需要把非线性的共线方程线性化。<span
class="math inline">\(x,y\)</span>
是关于六个外方位元素的多元函数，进行一次泰勒展开： <span
class="math display">\[\label{共线方程}
\begin{array}{c}
x = \tilde{x} + \frac{\partial x}{\partial X_s}dX_s + \frac{\partial
x}{\partial Y_s}dY_s+\frac{\partial x}{\partial Z_s}dZ_s+\frac{\partial
x}{\partial \varphi}d\varphi +\frac{\partial x}{\partial \omega}d\omega
+\frac{\partial x}{\partial \kappa}d\kappa  \\
y = \tilde{y} +\frac{\partial y}{\partial X_s}dX_s+\frac{\partial
y}{\partial Y_s}dY_s+\frac{\partial y}{\partial Z_s}dZ_s+\frac{\partial
y}{\partial \varphi}d\varphi +\frac{\partial y}{\partial \omega}d\omega
+\frac{\partial y}{\partial \kappa}d\kappa
\end{array}
\]</span> <span class="math inline">\(\tilde{x},\tilde{y}\)</span>
是函数的近似值，是把外方位元素的初值 <span
class="math inline">\(X_{s0},Y_{s0},Z_{s0},\varphi_0,\omega_0,\kappa_0\)</span>
带入共线方程中得到的结果；<br />
<span
class="math inline">\(dX_s,dY_x,dZ_s,d\varphi_,d\omega,d\kappa\)</span>
是对应外方位元素近似值的改正数（也就是增量）；<br />
<span class="math inline">\(\frac{\partial x}{\partial
X_s},\dots,\frac{\partial y}{\partial \kappa}\)</span>
为偏导数，是外方位元素改正数的系数。</p>
<p>为了方便表示，式 <span
class="math inline">\(\eqref{共线方程}\)</span> 记为： <span
class="math display">\[\label{共线方程简化}
\begin{array}{c}
x = \tilde{x} + a_{11}\ dX_s + a_{12}\ dY_s+a_{13}\ dZ_s+a_{14}\
d\varphi +a_{15}\ d\omega +a_{16}\ d\kappa= \tilde{x} + dx  \\
y = \tilde{y} +a_{21}\ dX_s+a_{22}\ dY_s+a_{23}\ dZ_s+a_{24}\ d\varphi
+a_{25}\ d\omega +a_{26}\ d\kappa=\tilde{y} + dy
\end{array}
\]</span> <span class="math inline">\(dx,dy\)</span>
表示近似值的改正值。</p>
<p>因为上述近似是一阶的，结果较为粗略，所以需要不断迭代趋近，直到改正值小于某一阈值。<br />
对于一个控制点就能由共线方程列写两个式子，所以一个像片中有三个点就能列出六个方程，求出六个外方位元素的改正值。</p>
<h3 id="误差方程与法方程">2.2. 误差方程与法方程</h3>
<p>为了提高解算外方位元素的精度，常有多余观测方程。在空间后方交会中，通常是在像片的四个角上选取四个或者更多的地面控制点，因此要用最小二乘法平差计算。<br />
<strong>计算中，通常将控制点的地面坐标视为真值，而把相应的像点坐标视为观测值</strong>，加入相应的改正数
<span class="math inline">\(v_x,v_y\)</span>，按照
<code>观测值 + 观测值改正数 = 近似值 + 近似值改正数</code>
的改正原则，得： <span class="math display">\[
\begin{array}{c}
x+v_x=\tilde{x}+dx \\
y+v_y=\tilde{y}+dy
\end{array}
\Longrightarrow
\begin{array}{c}
v_x=\tilde{x}+dx-x \\
v_y=\tilde{y}+dy-y
\end{array}
\]</span> 这里 <span class="math inline">\(v_x,v_y\)</span>
的意义就比较明显了，代表 近似值经过改正后与真实值之间的误差。</p>
<p>结合式 <span
class="math inline">\(\eqref{共线方程简化}\)</span>，我们可以用矩阵形式表示这个方程组
<span class="math display">\[
V=AX-l
\]</span> 其中 <span class="math display">\[
\begin{equation*}
\begin{aligned}
V&amp;=\left[v_x, v_y\right]^T \in\mathbb{R}^{2\times 1} \\\\
A&amp;=\begin{bmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} &amp; a_{15} &amp; a_{16}
\\
a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} &amp; a_{25} &amp; a_{26}
\end{bmatrix} \in\mathbb{R}^{2\times 6} \\\\
X&amp;=\left[dX_s,dY_s,dZ_s,d\varphi,d\omega,d\kappa\right]^T
\in\mathbb{R}^{6\times 1} \\\\
l&amp;=\left[l_x,l_y\right]^T=\left[x-\tilde{x}, y-\tilde{y}\right]^T
\in\mathbb{R}^{2\times 1}
\end{aligned}
\end{equation*}
\]</span> 上面只是一个控制点的形式，当存在 <span
class="math inline">\(n\)</span> 个控制点的时候，则有： <span
class="math display">\[\label{误差方程}
V=AX-L
\]</span> 其中 <span class="math display">\[
\begin{equation*}
\begin{aligned}
V&amp;=\left[V_1^T , V_2^T,\dots,V_n^T\right]^T \in \mathbb{R}^{2n\times
1} \\\\
A&amp;=\left[A_1^T,A_2^T,\dots,A_n^T \right] \in\mathbb{R}^{2n\times 6}
\\\\
X&amp;=\left[dX_s,dY_s,dZ_s,d\varphi,d\omega,d\kappa\right]^T
\in\mathbb{R}^{6\times 1} \\\\
l&amp;=\left[l_1^T,l_2^T,\dots,l_n^T \right]^T \in\mathbb{R}^{2n\times
1}
\end{aligned}
\end{equation*}
\]</span> 注意矩阵的大小，写代码的时候要用到。</p>
<p>根据最小二乘间接平差原理，可列出法方程： <span
class="math display">\[
A^T P A X=A^T L
\]</span> 其中，<span class="math inline">\(P\)</span>
为像点观测值的权值矩阵，表示观测值测量的相对精度，一般认为是等精度测量，故取
<span class="math inline">\(P\)</span> 为单位阵，因此可解得： <span
class="math display">\[\label{封闭解}
X=(A^T A)^{-1}A^T L
\]</span> 从而求得外方位元素近似值的改正数 <span
class="math inline">\(dX_s,dY_s,dZ_s,d\varphi,d\omega,d\kappa\)</span>
。</p>
<details class="note info"><summary><p>一些解释</p>
</summary>
<p>这里的计算过程其实就是很常见的线性模型，最小化误差即 <span
class="math display">\[\nonumber X=arg\
\underset{X}{min}\|V^TV\|_{2}^{2}\]</span>
这是一个经典的凸优化问题，求偏导，令偏导等于 0 即可。</p>

</details>
<p>根据上面的内容，我们可以得到第 <span class="math inline">\(i\)</span>
次计算的外方位元素的改正值 <span
class="math inline">\(X_i\)</span>，直到第 <span
class="math inline">\(k\)</span> 次收敛的时，得到最后的外方位元素：
<span class="math display">\[
\begin{equation*}
\begin{aligned}
X_s &amp;= X_{s0}+dX_{s1}+dX_{s2}+\dots+dX_{sk} \\
Y_s &amp;= Y_{s0}+dY_{s1}+dY_{s2}+\dots+dY_{sk} \\
Z_s &amp;= Z_{s0}+dZ_{s1}+dZ_{s2}+\dots+dZ_{sk} \\
\varphi &amp;= \varphi_0 + d\varphi_1 + d\varphi_2+\dots+d\varphi_k \\
\omega &amp;= \omega_0 + d\omega_1+d\omega_2 + \dots+d\omega_k \\
\kappa &amp;= \kappa_0+d\kappa_1+d\kappa_2+\dots+d\kappa_k
\end{aligned}
\end{equation*}
\]</span></p>
<p>即 <span class="math display">\[
X = X_0 + X_1 + X_2 +\dots+X_k
\]</span></p>
<p>观察式 <span class="math inline">\(\eqref{封闭解}\)</span>
可知，目前仅 <span class="math inline">\(A\)</span> 未知，下面对 <span
class="math inline">\(A\)</span> 进行求解。 <details class="note info"><summary><p>求解 <span class="math inline">\(A\)</span></p>
</summary>
<p>为书写方便，令共线方程中的分子、分母如下： <span
class="math display">\[\begin{equation}\label{共线方程分子分母}
\begin{aligned}
\overline{X} = a_1\left( X-X_s \right) +b_1\left( Y-Y_s \right)
+c_1\left( Z-Z_s \right) \\
\overline{Y} = a_2\left( X-X_s \right) +b_2\left( Y-Y_s \right)
+c_2\left( Z-Z_s \right) \\
\overline{Z} = a_3\left( X-X_s \right) +b_3\left( Y-Y_s \right)
+c_3\left( Z-Z_s \right) \\
\end{aligned}
\end{equation}
\]</span></p>
<p>由 <span class="math inline">\(\eqref{共线方程}\)</span> 和 <span
class="math inline">\(\eqref{共线方程简化}\)</span> 可知 <span
class="math display">\[
\begin{equation*}
\begin{aligned}
a_{11} = \frac{\partial x}{\partial X_s} &amp;= \frac{\partial
\left(-f\frac{\overline{X}}{\overline{Z}}\right)}{\partial X_s} &amp;
分式求导\\
&amp;=-f \frac{\frac{\partial \overline{X}}{\partial X_s}\overline{Z} -
\overline{X}\frac{\partial \overline{Z}}{\partial X_s}}{\overline{Z}^2}
&amp;x=-f\frac{\overline{X}}{\overline{Z}}\\
&amp;=-f\left(-\frac{a_1}{\overline{Z}} - \frac{1}{f\overline{Z}}x
a_3\right) \\
&amp;=\frac{1}{\overline{Z}}\left(a_1 f + a_3 x\right)
\end{aligned}
\end{equation*}
\]</span></p>
<p>同理可得 <span class="math display">\[
\begin{align}
&amp;
\begin{cases}\label{对XYZ偏导}
a_{11}=\frac{\partial x}{\partial X_{s}}=\frac{1}{\overline{Z}}(a_{1}f +
a_{3}x)\\\\
a_{12}=\frac{\partial x}{\partial Y_{s}}=\frac{1}{\overline{Z}}(b_{1}f +
b_{3}x)\\\\
a_{13}=\frac{\partial x}{\partial Z_{s}}=\frac{1}{\overline{Z}}(c_{1}f +
c_{3}x)\\\\
a_{21}=\frac{\partial y}{\partial X_{s}}=\frac{1}{\overline{Z}}(a_{2}f +
a_{3}y)\\\\
a_{22}=\frac{\partial y}{\partial Y_{s}}=\frac{1}{\overline{Z}}(b_{2}f +
b_{3}y)\\\\
a_{23}=\frac{\partial y}{\partial Z_{s}}=\frac{1}{\overline{Z}}(c_{2}f +
c_{3}y)
\end{cases}
\\\nonumber \\
&amp;
\begin{cases}\label{对角度偏导}
a_{14}=\frac{\partial x}{\partial
\varphi}=-\frac{f}{(\overline{Z})^{2}}(\frac{\partial
\overline{X}}{\partial \varphi}\overline{Z}-\frac{\partial
\overline{Z}}{\partial \varphi}\overline{X})\\\\
a_{15}=\frac{\partial x}{\partial
\omega}=-\frac{f}{(\overline{Z})^{2}}(\frac{\partial
\overline{X}}{\partial \omega}\overline{Z}-\frac{\partial
\overline{Z}}{\partial \omega}\overline{X})\\\\
a_{16}=\frac{\partial x}{\partial
\kappa}=-\frac{f}{(\overline{Z})^{2}}(\frac{\partial
\overline{X}}{\partial \kappa}\overline{Z}-\frac{\partial
\overline{Z}}{\partial \kappa}\overline{X})\\\\
a_{24}=\frac{\partial y}{\partial
\varphi}=-\frac{f}{(\overline{Z})^{2}}(\frac{\partial
\overline{Y}}{\partial \varphi}\overline{Z}-\frac{\partial
\overline{Z}}{\partial \varphi}\overline{Y})\\\\
a_{25}=\frac{\partial y}{\partial
\omega}=-\frac{f}{(\overline{Z})^{2}}(\frac{\partial
\overline{Y}}{\partial \omega}\overline{Z}-\frac{\partial
\overline{Z}}{\partial \omega}\overline{Y})\\\\
a_{26}=\frac{\partial y}{\partial
\kappa}=-\frac{f}{(\overline{Z})^{2}}(\frac{\partial
\overline{Y}}{\partial \kappa}\overline{Z}-\frac{\partial
\overline{Z}}{\partial \kappa}\overline{Y})
\end{cases}
\end{align}
\]</span></p>
<p>由式 <span class="math inline">\(\eqref{共线方程分子分母}\)</span>
可知 <span class="math display">\[
\begin{aligned}
\left[ \begin{array}{c}
\overline{X} \\
\overline{Y} \\
\overline{Z} \\
\end{array} \right]
&amp;=\left[\begin{array}{c}
a_1 &amp; a_2 &amp; a_3 \\
b_1 &amp; b_2 &amp; b_3 \\
c_1 &amp; c_2 &amp; c_3 \\
\end{array}\right]
\left[\begin{array}{c}
X-X_s\\
Y-Y_s\\
Z-Z_s
\end{array}\right]
=R^T\left[\begin{array}{c}
X-X_s\\
Y-Y_s\\
Z-Z_s
\end{array}\right] \\
&amp;=R_{\kappa}^T R_{\omega}^T R_{\varphi}^T \left[\begin{array}{c}
X-X_s\\
Y-Y_s\\
Z-Z_s
\end{array}\right]
=R_{\kappa}^{-1} R_{\omega}^{-1} R_{\varphi}^{-1} \left[\begin{array}{c}
X-X_s\\
Y-Y_s\\
Z-Z_s
\end{array}\right]
\end{aligned}
\]</span></p>
<p>所以 <span class="math display">\[
\begin{equation}
\begin{aligned}
\frac{\partial}{\partial \varphi}
\begin{bmatrix}
\overline{X} \\
\overline{Y} \\
\overline{Z}
\end{bmatrix}
&amp;= R_{\kappa}^{-1} R_{\omega}^{-1} \frac{\partial
R_{\varphi}^{-1}}{\partial \varphi}
\begin{bmatrix}
X - X_{s} \\
Y - Y_{s} \\
Z - Z_{s}
\end{bmatrix}\\
&amp;= R_{\kappa}^{-1} R_{\omega}^{-1} R_{\varphi}^{-1} R_{\varphi}
\frac{\partial R_{\varphi}^{-1}}{\partial \varphi}
\begin{bmatrix}
X - X_{s} \\
Y - Y_{s} \\
Z - Z_{s}
\end{bmatrix}\\
&amp;= R^{-1} R_{\varphi} \frac{\partial R_{\varphi}^{-1}}{\partial
\varphi}
\begin{bmatrix}
X - X_{s} \\
Y - Y_{s} \\
Z - Z_{s}
\end{bmatrix}
\end{aligned}
\end{equation}
\]</span></p>
<p>而 <span class="math display">\[
R_{\varphi}^{-1} = R_{\varphi}^{\mathrm{T}}
=\begin{bmatrix}
\cos\varphi &amp; 0 &amp; \sin\varphi \\
0 &amp; 1 &amp; 0 \\
-\sin\varphi &amp; 0 &amp; \cos\varphi
\end{bmatrix}
\]</span> 则 <span class="math display">\[
R_{\varphi} \frac{\partial R_{\varphi}^{-1}}{\partial \varphi}
=\begin{bmatrix}
\cos\varphi &amp; 0 &amp; -\sin\varphi \\
0 &amp; 1 &amp; 0 \\
\sin\varphi &amp; 0 &amp; \cos\varphi
\end{bmatrix}
\begin{bmatrix}
-\sin\varphi &amp; 0 &amp; \cos\varphi \\
0 &amp; 0 &amp; 0 \\
-\cos\varphi &amp; 0 &amp; -\sin\varphi
\end{bmatrix}
=\begin{bmatrix}
0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 \\
-1 &amp; 0 &amp; 0
\end{bmatrix}
\]</span></p>
<p>代入上式，得： <span class="math display">\[
\begin{equation}\label{varphi偏导}
\begin{aligned}
\frac{\partial}{\partial \varphi}
\begin{bmatrix}
\overline{X} \\
\overline{Y} \\
\overline{Z}
\end{bmatrix}
&amp;=\begin{bmatrix}
a_{1} &amp; b_{1} &amp; c_{1} \\
a_{2} &amp; b_{2} &amp; c_{2} \\
a_{3} &amp; b_{3} &amp; c_{3}
\end{bmatrix}
\begin{bmatrix}
0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 \\
-1 &amp; 0 &amp; 0
\end{bmatrix}
\begin{bmatrix}
X - X_{s} \\
Y - Y_{s} \\
Z - Z_{s}
\end{bmatrix}\\
&amp;=\begin{bmatrix}
a_{1} &amp; b_{1} &amp; c_{1} \\
a_{2} &amp; b_{2} &amp; c_{2} \\
a_{3} &amp; b_{3} &amp; c_{3}
\end{bmatrix}
\begin{bmatrix}
0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 \\
-1 &amp; 0 &amp; 0
\end{bmatrix}
\begin{bmatrix}
a_{1} &amp; a_{2} &amp; a_{3} \\
b_{1} &amp; b_{2} &amp; b_{3} \\
c_{1} &amp; c_{2} &amp; c_{3}
\end{bmatrix}
\begin{bmatrix}
\overline{X} \\
\overline{Y} \\
\overline{Z}
\end{bmatrix}\\
&amp;=\begin{bmatrix}
0 &amp; -b_{3} &amp; b_{2} \\
b_{3} &amp; 0 &amp; -b_{1} \\
-b_{2} &amp; b_{1} &amp; 0
\end{bmatrix}
\begin{bmatrix}
\overline{X} \\
\overline{Y} \\
\overline{Z}
\end{bmatrix}
\end{aligned}
\end{equation}
\]</span> 按相仿的方法，得： <span class="math display">\[
\begin{equation}\label{omega偏导}
\begin{aligned}
    \frac{\partial}{\partial \omega}
    \begin{bmatrix}
    \overline{X} \\
    \overline{Y} \\
    \overline{Z}
    \end{bmatrix}
    &amp;= R_{\kappa}^{-1} \frac{\partial R_{\omega}^{-1}}{\partial
\omega} R_{\varphi}^{-1}
    \begin{bmatrix}
    X - X_{s} \\
    Y - Y_{s} \\
    Z - Z_{s}
    \end{bmatrix}\\
    &amp;= R_{\kappa}^{-1} \frac{\partial R_{\omega}^{-1}}{\partial
\omega} R_{\omega} R_{\kappa} R_{\kappa}^{-1} R_{\omega}^{-1}
R_{\varphi}^{-1}
    \begin{bmatrix}
    X - X_{s} \\
    Y - Y_{s} \\
    Z - Z_{s}
    \end{bmatrix}\\
    &amp;=R_{\kappa}^{-1}
    \begin{bmatrix}
    0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 \\
    0 &amp; -1 &amp; 0
    \end{bmatrix}
    R_{\kappa}R^{-1}
    \begin{bmatrix}
    X - X_{s} \\
    Y - Y_{s} \\
    Z - Z_{s}
    \end{bmatrix}\\
    &amp;=\begin{bmatrix}
    \overline{Z}\sin\kappa \\
    \overline{Z}\cos\kappa \\
    -\overline{X}\sin\kappa - Y\cos\kappa
    \end{bmatrix}
\end{aligned}
\end{equation}
\]</span></p>
<p><span class="math display">\[
\begin{equation}\label{kappa偏导}
\begin{aligned}
    \frac{\partial}{\partial \kappa}
    \begin{bmatrix}
    \overline{X} \\
    \overline{Y} \\
    \overline{Z}
    \end{bmatrix}
    &amp;=\frac{\partial R_{\kappa}^{-1}}{\partial
\kappa}R_{\kappa}R_{\kappa}^{-1}R_{\omega}^{-1}R_{\varphi}^{-1}
    \begin{bmatrix}
    X - X_{s} \\
    Y - Y_{s} \\
    Z - Z_{s}
    \end{bmatrix}\\
    &amp;=\begin{bmatrix}
    0 &amp; 1 &amp; 0 \\
    -1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0
    \end{bmatrix}
    \begin{bmatrix}
    a_{1} &amp; b_{1} &amp; c_{1} \\
    a_{2} &amp; b_{2} &amp; c_{2} \\
    a_{3} &amp; b_{3} &amp; c_{3}
    \end{bmatrix}
    \begin{bmatrix}
    X - X_{s} \\
    Y - Y_{s} \\
    Z - Z_{s}
    \end{bmatrix}\\
    &amp;=\begin{bmatrix}
    \overline{Y} \\
    -\overline{X} \\
    0
    \end{bmatrix}
\end{aligned}
\end{equation}
\]</span></p>
<p>将 <span class="math inline">\(\eqref{varphi偏导} \eqref{omega偏导}
\eqref{kappa偏导}\)</span> 带入 <span
class="math inline">\(\eqref{对角度偏导}\)</span>，整理得： <span
class="math display">\[
\begin{equation}\label{对角度偏导化简}
\begin{aligned}
a_{14} &amp;= y\sin\omega - \left[\frac{x}{f}(x\cos\kappa - y\sin\kappa)
+ f\cos\kappa\right]\cos\omega\\
a_{15} &amp;= -f\sin\kappa - \frac{x}{f}(x\sin\kappa + y\cos\kappa)\\
a_{16} &amp;= y\\
a_{24} &amp;= -x\sin\omega - \left[\frac{y}{f}(x\cos\kappa -
y\sin\kappa) - f\sin\kappa\right]\cos\omega\\
a_{25} &amp;= -f\cos\kappa - \frac{y}{f}(x\sin\kappa + y\cos\kappa)\\
a_{26} &amp;= -x
\end{aligned}
\end{equation}
\]</span></p>

</details></p>
<p>在<strong>竖直摄影</strong>情况下，角元素都是小角<span
class="math inline">\((\lt 3°)\)</span>，可用 <span
class="math inline">\(\varphi=\omega=\kappa=0\)</span> 及 <span
class="math inline">\(Z-Z_s=-H\)</span> 代替，得到各系数的近似值： <span
class="math display">\[
\begin{equation}
\begin{aligned}
a_{11} &amp;= -\frac{f}{H} &amp; a_{12} &amp;= 0 &amp; a_{13} &amp;=
-\frac{x}{H}\\
a_{14} &amp;= -f\left(1 + \frac{x^2}{f^2}\right) &amp; a_{15} &amp;=
-\frac{xy}{f} &amp; a_{16} &amp;= y\\
a_{21} &amp;= 0 &amp; a_{22} &amp;= -\frac{f}{H} &amp; a_{23} &amp;=
-\frac{y}{H}\\
a_{24} &amp;= -\frac{xy}{f} &amp; a_{25} &amp;= -f\left(1 +
\frac{y^2}{f^2}\right) &amp; a_{26} &amp;= -x
\end{aligned}
\end{equation}
\]</span></p>
<h2 id="解算步骤">3. 解算步骤</h2>
<p>综上所述，空间后方交会的求解过程如下：</p>
<ol type="1">
<li>获取已知数据：从摄影资料中查取像片比例尺<span
class="math inline">\(1/m\)</span>，平均航高，内方元素<span
class="math inline">\(x_0\)</span>、<span
class="math inline">\(y_0\)</span>、<span
class="math inline">\(f\)</span>；从外业测量成果中，获取控制点的地面测量坐标<span
class="math inline">\(X_t\)</span>、<span
class="math inline">\(Y_t\)</span>、<span
class="math inline">\(Z_t\)</span>，并转化成地面摄影测量坐标<span
class="math inline">\(X\)</span>、<span
class="math inline">\(Y\)</span>、<span
class="math inline">\(Z\)</span>。</li>
<li>量测控制点的像点坐标：将控制点标刺在像片上，利用立体坐标量测仪量测控制点的像框标坐标，并经像点坐标改正，得到像点坐标<span
class="math inline">\(x\)</span>、<span
class="math inline">\(y\)</span>。</li>
<li>确定未知数的初始值：在竖直摄影情况下，角元素的初始值为<span
class="math inline">\(0\)</span>，即<span
class="math inline">\(\varphi_0 = \omega_0 = \kappa_0 =
0\)</span>；线元素中，<span class="math inline">\(Z_{s0} = H =
mf\)</span>，<span class="math inline">\(X_{s0}\)</span>、<span
class="math inline">\(Y_{s0}\)</span>的取值可用四个角上控制点坐标的平均值，即：<span
class="math inline">\(X_{s0} = \frac{1}{4} \sum_{i = 1}^{4}
X_i\)</span>，<span class="math inline">\(Y_{s0} = \frac{1}{4} \sum_{i =
1}^{4} Y_i\)</span>。</li>
<li>计算旋转矩阵<span
class="math inline">\(R\)</span>：利用角元素的近似值计算方向余弦值，组成<span
class="math inline">\(R\)</span>阵。</li>
<li>逐点计算像点坐标的近似值：利用未知数的近似值按共线方程式计算控制点像点坐标的近似值<span
class="math inline">\(\tilde{x}\)</span>、<span
class="math inline">\(\tilde{y}\)</span>。</li>
<li>组成误差方程式：按式 <span
class="math inline">\(\eqref{对XYZ偏导}\eqref{对角度偏导化简}\eqref{误差方程}\)</span>
逐点计算误差方程式的系数和常数项。</li>
<li>组成法方程式：计算法方程的系数矩阵<span
class="math inline">\(A^{\mathrm{T}}A\)</span>与常数项<span
class="math inline">\(A^{\mathrm{T}}L\)</span>。</li>
<li>解求外方位元素：根据法方程，按式<span
class="math inline">\(\eqref{封闭解}\)</span>解求外方位元素改正数，并与相应的近似值求和，得到外方位元素新的近似值。</li>
<li>检查计算是否收敛：将求得的外方位元素的改正数与规定的限差比较，小于限差则计算终止，否则用新的近似值重复第4至第8步骤的计算，直到满足要求为止。</li>
</ol>
<h2 id="精度">4. 精度</h2>
<p>由平差理论可知，法方程系数的逆矩阵 <span
class="math inline">\((A^{\mathrm{T}}A)^{-1}\)</span>
等于未知数的协因数阵 <span
class="math inline">\(Q_{x}\)</span>，因此可按下式计算未知数的中误差：
<span class="math display">\[
m_{i}=m_{0} \cdot \sqrt{Q_{ii}}
\]</span> 式中，<span class="math inline">\(i\)</span>
表示相应的未知数，<span class="math inline">\(Q_{ii}\)</span> 为 <span
class="math inline">\(Q_{x}\)</span> 阵中的主对角线元素，<span
class="math inline">\(m_{0}\)</span> 称为单位权中误差，计算公式为：
<span class="math display">\[
m_{0}=\pm\sqrt{\frac{\|V^TV\|_{2}^{2}}{2n - 6}}
\]</span> 这里，<span class="math inline">\(n\)</span>
表示控制点的总数。</p>
<h2 id="python-实现">5. python 实现</h2>
<p>以 <a href="#reference1">[1]</a> 的课后题为例</p>
<p>目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├─mian.py</span><br><span class="line">├─data.txt</span><br><span class="line">├─result.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>main.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> cos, sin</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        raw_data = f.read()</span><br><span class="line">        <span class="comment"># print(raw_data)</span></span><br><span class="line">    raw_data = raw_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(raw_data)):</span><br><span class="line">        tmp = [np.float64(it) <span class="keyword">for</span> it <span class="keyword">in</span> raw_data[i].split()]</span><br><span class="line">        data.extend([tmp])</span><br><span class="line">    <span class="keyword">return</span> np.array(data)[:, <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_path = <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">save_path = <span class="string">&quot;result.txt&quot;</span></span><br><span class="line"></span><br><span class="line">m = <span class="number">4_0000</span>  <span class="comment"># 比例尺 1/m</span></span><br><span class="line">f = <span class="number">0.15324</span>  <span class="comment"># 主距</span></span><br><span class="line">x0, y0 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">phi, omega, kappa = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 俯仰角、横摇角和偏航角</span></span><br><span class="line"></span><br><span class="line">data = get_data(data_path)  <span class="comment"># 像坐标和地面坐标数据</span></span><br><span class="line">n_points = data.shape[<span class="number">0</span>]  <span class="comment"># 控制点的个数</span></span><br><span class="line">img_coord = data[:, :<span class="number">2</span>] / <span class="number">1000</span>  <span class="comment"># 像点坐标，除以 1000 将单位换算为 m</span></span><br><span class="line">ground_coord = data[:, <span class="number">2</span>:]  <span class="comment"># 地面坐标</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Xs = np.mean(ground_coord[:, <span class="number">0</span>])</span><br><span class="line">Ys = np.mean(ground_coord[:, <span class="number">1</span>])</span><br><span class="line">Zs = m * f</span><br><span class="line"><span class="comment"># print(f&quot;外方位元素初始值：&#123;Xs,Ys,Zs,phi,omega,kappa&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">R = np.zeros((<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 旋转矩阵</span></span><br><span class="line">x = y = np.zeros((n_points, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># V = AX - L</span></span><br><span class="line">V = L = np.zeros((<span class="number">2</span> * n_points, <span class="number">1</span>))</span><br><span class="line">A = np.zeros((<span class="number">2</span> * n_points, <span class="number">6</span>))</span><br><span class="line">X = np.zeros((<span class="number">6</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">n_iter, MAX_ITER = <span class="number">0</span>, <span class="number">150</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    a1 = R[<span class="number">0</span>, <span class="number">0</span>] = cos(phi) * cos(kappa) - sin(phi) * sin(omega) * sin(kappa)</span><br><span class="line">    a2 = R[<span class="number">0</span>, <span class="number">1</span>] = (-<span class="number">1.0</span>) * cos(phi) * sin(kappa) - sin(phi) * sin(omega) * cos(kappa)</span><br><span class="line">    a3 = R[<span class="number">0</span>, <span class="number">2</span>] = (-<span class="number">1.0</span>) * sin(phi) * cos(omega)</span><br><span class="line">    b1 = R[<span class="number">1</span>, <span class="number">0</span>] = cos(omega) * sin(kappa)</span><br><span class="line">    b2 = R[<span class="number">1</span>, <span class="number">1</span>] = cos(omega) * cos(kappa)</span><br><span class="line">    b3 = R[<span class="number">1</span>, <span class="number">2</span>] = (-<span class="number">1.0</span>) * sin(omega)</span><br><span class="line">    c1 = R[<span class="number">2</span>, <span class="number">0</span>] = sin(phi) * cos(kappa) + cos(phi) * sin(omega) * sin(kappa)</span><br><span class="line">    c2 = R[<span class="number">2</span>, <span class="number">1</span>] = (-<span class="number">1.0</span>) * sin(phi) * sin(kappa) + cos(phi) * sin(omega) * cos(kappa)</span><br><span class="line">    c3 = R[<span class="number">2</span>, <span class="number">2</span>] = cos(phi) * cos(omega)</span><br><span class="line"></span><br><span class="line">    X_bar = a1 * (ground_coord[:, <span class="number">0</span>] - Xs) + b1 * (ground_coord[:, <span class="number">1</span>] - Ys) + c1 * (ground_coord[:, <span class="number">2</span>] - Zs)</span><br><span class="line">    Y_bar = a2 * (ground_coord[:, <span class="number">0</span>] - Xs) + b2 * (ground_coord[:, <span class="number">1</span>] - Ys) + c2 * (ground_coord[:, <span class="number">2</span>] - Zs)</span><br><span class="line">    Z_bar = a3 * (ground_coord[:, <span class="number">0</span>] - Xs) + b3 * (ground_coord[:, <span class="number">1</span>] - Ys) + c3 * (ground_coord[:, <span class="number">2</span>] - Zs)</span><br><span class="line"></span><br><span class="line">    x = (-<span class="number">1.0</span>) * f * X_bar / Z_bar</span><br><span class="line">    y = (-<span class="number">1.0</span>) * f * Y_bar / Z_bar</span><br><span class="line"></span><br><span class="line">    L = (img_coord - np.array((x, y)).T).flatten()</span><br><span class="line">    H = Zs - ground_coord[:, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    A[::<span class="number">2</span>, <span class="number">0</span>] = (-<span class="number">1.0</span>) * f / H</span><br><span class="line">    A[::<span class="number">2</span>, <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    A[::<span class="number">2</span>, <span class="number">2</span>] = (-<span class="number">1.0</span>) * x / H</span><br><span class="line">    A[::<span class="number">2</span>, <span class="number">3</span>] = (-<span class="number">1.0</span>) * f * (<span class="number">1</span> + x**<span class="number">2</span> / f**<span class="number">2</span>)</span><br><span class="line">    A[::<span class="number">2</span>, <span class="number">4</span>] = (-<span class="number">1.0</span>) * x * y / f</span><br><span class="line">    A[::<span class="number">2</span>, <span class="number">5</span>] = y</span><br><span class="line"></span><br><span class="line">    A[<span class="number">1</span>::<span class="number">2</span>, <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    A[<span class="number">1</span>::<span class="number">2</span>, <span class="number">1</span>] = (-<span class="number">1.0</span>) * f / H</span><br><span class="line">    A[<span class="number">1</span>::<span class="number">2</span>, <span class="number">2</span>] = (-<span class="number">1.0</span>) * y / H</span><br><span class="line">    A[<span class="number">1</span>::<span class="number">2</span>, <span class="number">3</span>] = (-<span class="number">1.0</span>) * x * y / f</span><br><span class="line">    A[<span class="number">1</span>::<span class="number">2</span>, <span class="number">4</span>] = (-<span class="number">1.0</span>) * f * (<span class="number">1</span> + y**<span class="number">2</span> / f**<span class="number">2</span>)</span><br><span class="line">    A[<span class="number">1</span>::<span class="number">2</span>, <span class="number">5</span>] = (-<span class="number">1.0</span>) * x</span><br><span class="line"></span><br><span class="line">    ATA_inv = np.linalg.inv(A.T @ A)</span><br><span class="line">    X = ATA_inv @ A.T @ L</span><br><span class="line"></span><br><span class="line">    Xs += X[<span class="number">0</span>]</span><br><span class="line">    Ys += X[<span class="number">1</span>]</span><br><span class="line">    Zs += X[<span class="number">2</span>]</span><br><span class="line">    phi += X[<span class="number">3</span>]</span><br><span class="line">    omega += X[<span class="number">4</span>]</span><br><span class="line">    kappa += X[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    n_iter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (X[<span class="number">3</span>] &lt; <span class="number">1e-6</span> <span class="keyword">and</span> X[<span class="number">4</span>] &lt; <span class="number">1e-6</span> <span class="keyword">and</span> X[<span class="number">5</span>] &lt; <span class="number">1e-6</span>) <span class="keyword">or</span> (n_iter &gt; MAX_ITER):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;迭代次数:%0.f\n&quot; % n_iter)</span></span><br><span class="line"></span><br><span class="line">R[<span class="number">0</span>, <span class="number">0</span>] = cos(phi) * cos(kappa) - sin(phi) * sin(omega) * sin(kappa)</span><br><span class="line">R[<span class="number">0</span>, <span class="number">1</span>] = (-<span class="number">1.0</span>) * cos(phi) * sin(kappa) - sin(phi) * sin(omega) * cos(kappa)</span><br><span class="line">R[<span class="number">0</span>, <span class="number">2</span>] = (-<span class="number">1.0</span>) * sin(phi) * cos(omega)</span><br><span class="line">R[<span class="number">1</span>, <span class="number">0</span>] = cos(omega) * sin(kappa)</span><br><span class="line">R[<span class="number">1</span>, <span class="number">1</span>] = cos(omega) * cos(kappa)</span><br><span class="line">R[<span class="number">1</span>, <span class="number">2</span>] = (-<span class="number">1.0</span>) * sin(omega)</span><br><span class="line">R[<span class="number">2</span>, <span class="number">0</span>] = sin(phi) * cos(kappa) + cos(phi) * sin(omega) * sin(kappa)</span><br><span class="line">R[<span class="number">2</span>, <span class="number">1</span>] = (-<span class="number">1.0</span>) * sin(phi) * sin(kappa) + cos(phi) * sin(omega) * cos(kappa)</span><br><span class="line">R[<span class="number">2</span>, <span class="number">2</span>] = cos(phi) * cos(omega)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精度计算</span></span><br><span class="line">V = A @ X - L</span><br><span class="line">VV = np.<span class="built_in">sum</span>(np.linalg.norm(V, <span class="built_in">ord</span>=<span class="number">2</span>) ** <span class="number">2</span>)</span><br><span class="line">m0 = np.sqrt(VV / (<span class="number">2</span> * n_points - <span class="number">6</span>))</span><br><span class="line">Qx = ATA_inv.diagonal()</span><br><span class="line">m = m0 * np.sqrt(Qx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(save_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(<span class="string">&quot;外方位元素及其精度： \n&quot;</span>)</span><br><span class="line">    f.writelines(<span class="string">f&quot;Xs:<span class="subst">&#123;Xs:<span class="number">.6</span>f&#125;</span>  m:±<span class="subst">&#123;m[<span class="number">0</span>]:<span class="number">.6</span>f&#125;</span>\n&quot;</span>)</span><br><span class="line">    f.writelines(<span class="string">f&quot;Ys:<span class="subst">&#123;Ys:<span class="number">.6</span>f&#125;</span>  m:±<span class="subst">&#123;m[<span class="number">1</span>]:<span class="number">.6</span>f&#125;</span>\n&quot;</span>)</span><br><span class="line">    f.writelines(<span class="string">f&quot;Zs:<span class="subst">&#123;Zs:<span class="number">.6</span>f&#125;</span>  m:±<span class="subst">&#123;m[<span class="number">2</span>]:<span class="number">.6</span>f&#125;</span>\n&quot;</span>)</span><br><span class="line">    f.writelines(<span class="string">f&quot;phi:<span class="subst">&#123;phi:<span class="number">.6</span>f&#125;</span>  m:±<span class="subst">&#123;m[<span class="number">3</span>]:<span class="number">.6</span>f&#125;</span>\n&quot;</span>)</span><br><span class="line">    f.writelines(<span class="string">f&quot;omega:<span class="subst">&#123;omega:<span class="number">.6</span>f&#125;</span>  m:±<span class="subst">&#123;m[<span class="number">4</span>]:<span class="number">.6</span>f&#125;</span>\n&quot;</span>)</span><br><span class="line">    f.writelines(<span class="string">f&quot;kappa:<span class="subst">&#123;kappa:<span class="number">.6</span>f&#125;</span>  m:±<span class="subst">&#123;m[<span class="number">5</span>]:<span class="number">.6</span>f&#125;</span>\n&quot;</span>)</span><br><span class="line">    f.writelines(<span class="string">&quot;\n旋转矩阵：\n&quot;</span>)</span><br><span class="line">    f.write(<span class="string">f&quot;<span class="subst">&#123;R&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>data.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">NO.            x(mm)          y(mm)          X(m)           Y(m)           Z(m)</span><br><span class="line">1              -86.15         -68.99         36589.41       25273.32       2195.17</span><br><span class="line">2              -53.40         82.21          37631.08       31324.51       728.69         </span><br><span class="line">3              -14.78         -76.63         39100.97       24934.98       2386.50</span><br><span class="line">4              10.46          64.43          40426.54       30319.81       757.31</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>result.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">外方位元素及其精度： </span><br><span class="line">Xs:39795.443401  m:±1.125402</span><br><span class="line">Ys:27476.464840  m:±1.243674</span><br><span class="line">Zs:7572.688331  m:±0.483771</span><br><span class="line">phi:-0.003986  m:±0.000182</span><br><span class="line">omega:0.002114  m:±0.000160</span><br><span class="line">kappa:-0.067578  m:±0.000072</span><br><span class="line"></span><br><span class="line">旋转矩阵：</span><br><span class="line">[[ 0.99770901  0.06753409  0.00398554]</span><br><span class="line"> [-0.06752607  0.99771527 -0.00211367]</span><br><span class="line"> [-0.00411918  0.0018397   0.99998982]]</span><br></pre></td></tr></table></figure>
<p>如果你觉得这篇博客对你有所帮助，不妨在 GitHub 上给它点个
star🌟，这将是对我莫大的鼓励。<br />
<a
href="https://github.com/Blackspace2/space-resection-of-single-image.git">Github
地址</a></p>
<h2 id="参考资料">6. 参考资料</h2>
<p><strong>[1]</strong>
王佩军，徐亚明等编著<span>.</span>摄影测量学[M].武汉：武汉大学出版社，2016.5
<span id="reference1"></span></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>后方交会</tag>
        <tag>摄影测量</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机-SVM</title>
    <url>/2025/01/18/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-SVM/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="概要">1. 概要</h2>
<p>支持向量机 (support vector machine, SVM)</p>
<ul>
<li>有监督学习</li>
<li><strong>线性</strong>分类器</li>
<li>利用<strong>核技巧</strong>解决<strong>非线性</strong>分类问题</li>
</ul>
<p><strong>为方便可视化，以二维二分类问题为例子对 SVM
进行说明。</strong></p>
<strong>目标</strong>：<span
id="SVM_purpose"></span>支持向量机想要求解的是离正负样本都尽可能远且刚好位于“正中间”的划分超平面，因为这样的超平面理论上泛化性能更好。<br />
<span id="fig1"></span>
<figure>
<img src="SVM示意图.svg" alt="SVM示意图" width="50%" height="50%" loading="lazy"/>
<figcaption>
图1. SVM示意图，蓝色为负例，红色为正例，<span
class="math inline">\(H_0\)</span> 为所求
</figcaption>
</figure>
<h2 id="符号说明与一些定义">2. 符号说明与一些定义</h2>
<h3 id="符号说明">2.1. 符号说明</h3>
<ul>
<li>数据集 <span
class="math inline">\(T=\{(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)\}\)</span>
<ul>
<li><span class="math inline">\(\boldsymbol{x}_i \in \mathbb{R}^d,\quad
y_i \in \{+1,-1\},\quad i=1,2,\dots,n\)</span></li>
<li><span class="math inline">\(y_i=1\)</span> 时 <span
class="math inline">\(\boldsymbol{x}_i\)</span> 为正例，<span
class="math inline">\(y_i=-1\)</span> 时 <span
class="math inline">\(\boldsymbol{x}_i\)</span> 为负例</li>
<li><strong>假设数据是线性可分的</strong>，即存在一个超平面能够将不同类的样本完全分开。</li>
</ul></li>
<li>超平面 <span
class="math inline">\(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b=0\)</span>，简记为<span
class="math inline">\((\boldsymbol{w},b)\)</span>
<ul>
<li><strong>缩放不变性</strong>：<span
class="math inline">\(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b=0\)</span>
与 <span
class="math inline">\((k\boldsymbol{w})^\mathrm{T}\boldsymbol{x}+kb=0\
(k\gt 0)\)</span> 表示的是同一个超平面</li>
</ul></li>
</ul>
<details class="note info"><summary><p>关于<strong>缩放不变性</strong></p>
</summary>
<p>虽然 <span class="math inline">\(k&lt;0\)</span>
在数学上也满足缩放不变性，但在 SVM 的推导和实现中，通常限制 <span
class="math inline">\(k&gt;0\)</span>
以避免分类方向的反转和优化问题的复杂性。下面是一个简单的例子：</p>
<p>假设原始超平面参数为 <span class="math inline">\(\boldsymbol{w} = (1,
0)\)</span>，<span class="math inline">\(b =
0\)</span>，分类规则为：<br />
如果 <span class="math inline">\(x_1 &gt; 0\)</span>，则预测为 <span
class="math inline">\(y = +1\)</span>；<br />
如果 <span class="math inline">\(x_1 &lt; 0\)</span>，则预测为 <span
class="math inline">\(y = -1\)</span>。</p>
<p><strong>情况 1：<span class="math inline">\(k &gt; 0\)</span>（例如
<span class="math inline">\(k = 2\)</span>）</strong><br />
缩放后的超平面参数为 <span class="math inline">\(\boldsymbol{w}&#39; =
(2, 0)\)</span>，<span class="math inline">\(b&#39; =
0\)</span>，分类规则不变：<br />
如果 <span class="math inline">\(2x_1 &gt; 0 \quad \Rightarrow \quad x_1
&gt; 0\)</span>，则预测为 <span class="math inline">\(y =
+1\)</span>;<br />
如果 <span class="math inline">\(2x_1 &lt; 0 \quad \Rightarrow \quad x_1
&lt; 0\)</span>，则预测为 <span class="math inline">\(y =
-1\)</span>。</p>
<p><strong>情况 2：<span class="math inline">\(k &lt; 0\)</span>（例如
<span class="math inline">\(k = -1\)</span>）</strong><br />
缩放后的超平面参数为 <span class="math inline">\(\boldsymbol{w}&#39; =
(-1, 0)\)</span>，<span class="math inline">\(b&#39; =
0\)</span>，分类规则反转：<br />
如果 <span class="math inline">\(-x_1 &gt; 0 \quad \Rightarrow \quad x_1
&lt; 0\)</span>，则预测为 <span class="math inline">\(y =
+1\)</span>；<br />
如果 <span class="math inline">\(-x_1 &lt; 0 \quad \Rightarrow \quad x_1
&gt; 0\)</span>，则预测为 <span class="math inline">\(y =
-1\)</span>。</p>

</details>
<h3 id="定义">2.2. 定义</h3>
<h4 id="支持向量">2.2.1. 支持向量</h4>
<p><a href="#fig1">图1</a> 中，<span
class="math inline">\(H_1,H_{-1}\)</span>
经过的向量（一个蓝色，两个红色）即为支持向量。<br />
支持向量 <span class="math inline">\(\boldsymbol{x}_*\)</span>满足 <span
class="math display">\[\label{SV}
y_* \left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_*+b\right) = 1
\]</span></p>
<hr />
<p>根据 <a href="#SVM_purpose">SVM 的目标</a>，记超平面 <span
class="math inline">\(H_1\)</span> 与 <span
class="math inline">\(H_{-1}\)</span> 之间的距离为 <span
class="math inline">\(d\)</span>，我们很容易想到需要找到合适的 <span
class="math inline">\(H_1\)</span> 与 <span
class="math inline">\(H_{-1}\)</span> 使得 <span
class="math inline">\(d\)</span> 最大，此时超平面 <span
class="math inline">\(H_1\)</span> 与 <span
class="math inline">\(H_{-1}\)</span> 正中间的超平面 <span
class="math inline">\(H_0\)</span> 即为我们所求。<br />
为此我们需要定义关于距离 <span class="math inline">\(d\)</span>
的描述，也就是<strong>间隔 (margin)</strong>。</p>
<h4 id="函数间隔">2.2.2. 函数间隔</h4>
<p>对于给定的训练数据集 <span class="math inline">\(T\)</span> 和超平面
<span class="math inline">\((\boldsymbol{w},b)\)</span> ，定义超平面
<span class="math inline">\((\boldsymbol{w},b)\)</span> 关于样本点 <span
class="math inline">\((\boldsymbol{x}_i,y_i)\)</span> 的函数间隔为 <span
class="math display">\[\hat{\gamma}_i = y_i
\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i + b\right)\]</span></p>
<p>定义超平面 <span class="math inline">\((\boldsymbol{w},b)\)</span>
关于训练数据集 <span class="math inline">\(T\)</span> 的函数间隔为超平面
<span class="math inline">\((\boldsymbol{w},b)\)</span> 关于 <span
class="math inline">\(T\)</span> 中所有样本点 <span
class="math inline">\((\boldsymbol{x}_i,y_i)\)</span>
的函数间隔之最小值，即 <span class="math display">\[\hat{\gamma} =
\min_{i = 1,2,\dots,n}
\hat{\gamma}_i=y_*\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_*+b\right)\]</span>
其中 <span class="math inline">\(\boldsymbol{x}_*\)</span>
为支持向量。</p>
<p>函数间隔可以表示分类的正确性以及确信度。<br />
注意到函数间隔存在一些问题：当 <span
class="math inline">\(\boldsymbol{w},b\)</span>
成比例的改变时，虽然超平面没有改变，但函数间隔也会以同样的比例变化，因此不适合用于优化。</p>
<h4 id="几何间隔">2.2.3. 几何间隔</h4>
<p>对于给定的训练数据集 <span class="math inline">\(T\)</span> 和超平面
<span class="math inline">\((\boldsymbol{w},b)\)</span>，定义超平面
<span class="math inline">\((\boldsymbol{w},b)\)</span> 关于样本点 <span
class="math inline">\((\boldsymbol{x}_i,y_i)\)</span> 的几何间隔为 <span
class="math display">\[\gamma_i =
\frac{y_i\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i +
b\right)}{\|\boldsymbol{w}\|}\]</span></p>
<p>定义超平面 <span class="math inline">\((\boldsymbol{w},b)\)</span>
关于训练数据集 <span class="math inline">\(T\)</span> 的几何间隔为超平面
<span class="math inline">\((\boldsymbol{w},b)\)</span> 关于 <span
class="math inline">\(T\)</span> 中所有样本点 <span
class="math inline">\((\boldsymbol{x}_i,y_i)\)</span>
的几何间隔之最小值，即 <span class="math display">\[\gamma = \min_{i =
1,2,\dots,n}
\gamma_i=\frac{y_*\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_* +
b\right)}{\|\boldsymbol{w}\|}\]</span> 其中 <span
class="math inline">\(\boldsymbol{x}_*\)</span> 为支持向量。</p>
<p>超平面关于样本点的几何间隔指的就是点到超平面带符号的距离，当样本点被超平面分类正确的时候就是实际的距离了。</p>
<p>另外，几何间隔弥补了函数间隔存在的缺陷，即便 <span
class="math inline">\(\boldsymbol{w},b\)</span> 成比例的改变，但因为有了
<span class="math inline">\(\|\boldsymbol{w}\|\)</span>
这个分母项，使得几何间隔不变。<br />
也就是说几何间隔只与超平面的位置有关，比函数间隔更适合作为一个变量进行最优化。</p>
<p>根据函数间隔和几何间隔的定义，我们可以知道二者存在如下关系 <span
class="math display">\[
\begin{align}
\label{间隔关系1} \gamma_i = \frac{\hat{\gamma}_i}{\|\boldsymbol{w}\|}
\\
\label{间隔关系2} \gamma = \frac{\hat{\gamma}}{\|\boldsymbol{w}\|}
\end{align}
\]</span> 当 <span class="math inline">\(\|\boldsymbol{w}\|=1\)</span>
时，函数间隔和几何间隔二者相等。</p>
<h2 id="推导">3. 推导</h2>
<h3 id="目标函数">3.1. 目标函数</h3>
<p>由前文可知，我们需要最大化几何间隔，又称为硬间隔最大化。</p>
<p>间隔最大化的直观解释是：对训练数据集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类。也就是说，不仅将正负实例点分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开。这样的超平面应该对未知的新实例有很好的分类预测能力。</p>
<p>因此我们考虑如何求得一个几何间隔最大的分离超平面，即最大间隔分离超平面。用数学语言可以表示为如下的优化问题
<span class="math display">\[
\begin{equation}\label{opt}
\begin{aligned}
\max_{\boldsymbol{w},b} \quad&amp;\gamma = \max_{\boldsymbol{w},b} \min
\gamma_i \ ,\ i=1,2,\dots,n\\
\text{s.t.} \quad&amp; y_i
\frac{\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i + b}{\|\boldsymbol{w}\|}
\ge \gamma,\quad i=1,2,\dots,n
\end{aligned}
\end{equation}
\]</span></p>
<p>即最大化最小几何间隔，我们希望最大化超平面 <span
class="math inline">\((\boldsymbol{w},b)\)</span>
关于训练数据集的几何间隔 <span
class="math inline">\(\gamma\)</span>；约束条件表明，超平面 <span
class="math inline">\((\boldsymbol{w},b)\)</span>
关于每个训练样本的点的几何间隔至少为 <span
class="math inline">\(\gamma\)</span>。</p>
<p>考虑函数间隔和几何间隔的关系 <span
class="math inline">\(\eqref{间隔关系2}\)</span>，代入 <span
class="math inline">\(\eqref{opt}\)</span> 有 <span
class="math display">\[
\begin{align}
\max_{\boldsymbol{w},b} \quad&amp;
\frac{\hat{\gamma}}{\|\boldsymbol{w}\|}\\
\text{s.t.} \quad&amp; y_i
\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i + b\right) \ge
\hat{\gamma},\quad i=1,2,\dots,n
\end{align}
\]</span> 注意到，函数间隔 <span
class="math inline">\(\hat{\gamma}\)</span>
的取值并不影响最优化问题的解。例如 <span
class="math inline">\(\boldsymbol{w},b\)</span> 变为 <span
class="math inline">\(\lambda\boldsymbol{w},\lambda b\ (\lambda \gt
0)\)</span>，则有 <span class="math display">\[
\begin{equation}
\begin{aligned}
&amp;\frac{\hat{\gamma}}{\|\boldsymbol{w}\|}\rightarrow\frac{\lambda
\hat{\gamma}}{\lambda \|\boldsymbol{w}\|}\\
&amp;y_i \left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i + b\right) \ge
\hat{\gamma} \rightarrow y_i
\left(\left(\lambda\boldsymbol{w}\right)^\mathrm{T}\boldsymbol{x}_i +
\lambda b\right)=y_i \left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i +
b\right) \ge \lambda\hat{\gamma}
\end{aligned}
\end{equation}
\]</span></p>
<p>根据<strong>缩放不变性</strong>以及数据的线性可分性可知，取 <span
class="math inline">\(\lambda \hat{\gamma}=1\)</span>。</p>
<details class="note info"><summary><p>说明</p>
</summary>
<p>我还是认为从 B 站这个<a
href="https://b23.tv/UuJtZE5">讲解</a>的角度比较好理解<br />
从距离公式入手，结合缩放不变性 <span class="math display">\[\nonumber
d=\frac{|\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_0+b|}{\|\boldsymbol{w}\|}\quad
\xrightarrow{\text{经过缩放}} \frac{1}{\|\boldsymbol{w}\|}
\]</span></p>

</details>
<p>最终优化问题可以写为 <span class="math display">\[
\begin{equation}\label{final_opt}
\begin{aligned}
\min_{\boldsymbol{w},b} \quad&amp;\frac{1}{2}\|\boldsymbol{w}\|^2\\
\text{s.t.} \quad&amp; y_i
\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i + b\right) \ge 1,\quad
i=1,2,\dots,n
\end{aligned}
\end{equation}
\]</span></p>
<p>约束条件表明，每个样本都被正确分类。</p>
<h3 id="求解">3.2. 求解</h3>
<p>拉格朗日函数 <span class="math display">\[
\begin{equation}
\begin{aligned}
\mathcal{L}(\boldsymbol{w},b,\boldsymbol{\alpha})&amp;=\frac{1}{2}\|\boldsymbol{w}\|^2
+ \sum_{i = 1}^{n} \alpha_i(1 - y_i(\boldsymbol{w}^T\boldsymbol{x}_i +
b)),\quad \alpha_i \ge 0\\
&amp;=\frac{1}{2}\|\boldsymbol{w}\|^2 + \sum_{i = 1}^{n} (\alpha_i -
\alpha_iy_i\boldsymbol{w}^T\boldsymbol{x}_i - \alpha_iy_ib)\\
&amp;=\frac{1}{2}\boldsymbol{w}^T\boldsymbol{w}+\sum_{i = 1}^{n}
\alpha_i - \sum_{i = 1}^{n} \alpha_iy_i\boldsymbol{w}^T\boldsymbol{x}_i
- \sum_{i = 1}^{n} \alpha_iy_ib
\end{aligned}
\end{equation}
\]</span></p>
<p>对 <span class="math inline">\(\boldsymbol{w}\)</span> 和 <span
class="math inline">\(b\)</span> 分别求偏导数并令其为零</p>
<p><span class="math display">\[
\begin{align}
\label{diff_w}&amp;\frac{\partial L}{\partial\boldsymbol{w}}=\frac{1}{2}
\times 2\boldsymbol{w}+0 - \sum_{i = 1}^{n} \alpha_iy_i\boldsymbol{x}_i
- 0 = 0 \Longrightarrow \boldsymbol{w}=\sum_{i = 1}^{n}
\alpha_iy_i\boldsymbol{x}_i\\
\label{diff_b}&amp;\frac{\partial L}{\partial b}=0 + 0 - 0 - \sum_{i =
1}^{n} \alpha_iy_i = 0 \Longrightarrow \sum_{i = 1}^{n} \alpha_iy_i = 0
\end{align}
\]</span></p>
<p>将结果代回拉格朗日函数中消去 <span
class="math inline">\(\boldsymbol{w},b\)</span>，再考虑 <span
class="math inline">\(\eqref{diff_b}\)</span> 的约束条件，即可得到 <span
class="math inline">\(\eqref{final_opt}\)</span> 的对偶问题 <span
class="math display">\[
\begin{equation}\label{dual_problem}
\begin{aligned}
\max_{\boldsymbol{\alpha}}
\quad&amp;\sum_{i=1}^{n}\alpha_i-\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\alpha_i
\alpha_j y_i y_j \boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}_j\\
\text{s.t.} \quad&amp; \sum_{i=1}^n \alpha_i y_i=0,\quad \alpha_i \ge 0
\end{aligned}
\end{equation}
\]</span></p>
<p>解出 <span class="math inline">\(\alpha\)</span> 即可通过 <span
class="math inline">\(\eqref{diff_w}\)</span> 解出 <span
class="math inline">\(\boldsymbol{w}\)</span>，根据支持向量，代入 <span
class="math inline">\(\eqref{SV}\)</span> 中可得 <span
class="math display">\[
y_* \left(\sum_{i = 1}^{n}
\alpha_iy_i\boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}_*+b\right) =
1\Longrightarrow b=y_* - \sum_{i = 1}^{n}
\alpha_iy_i\boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}_*
\]</span></p>
<p>为了提高数值稳定性，考虑对全部支持向量的计算 <span
class="math inline">\(b\)</span> 并取平均值 <span
class="math display">\[
b=\frac{1}{N}\sum_{k=1}^{N}\left(y_k - \sum_{i = 1}^{n}
\alpha_iy_i\boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}_k\right)
\]</span> 其中， <span class="math inline">\(N\)</span>
是支持向量的总数</p>
<details class="note info"><summary><p>补充 求解 <span
class="math inline">\(\eqref{dual_problem}\)</span></p>
</summary>
<p><strong>线性约束二次规划问题</strong> Linearly Constraint Quadratic
Programming<br />
<span class="math inline">\(\eqref{dual_problem}\)</span>
属于线性约束二次规划问题。<br />
该类型问题有两个特点：</p>
<ul>
<li>目标函数为二次项</li>
<li>约束条件为一次项</li>
</ul>
<p>该问题要么无解，要么只有一个极值。</p>
<p>求解 <span class="math inline">\(\eqref{dual_problem}\)</span>
可以用高效的 SMO 算法</p>
<p>todo</p>

</details>
<h3 id="核函数">3.3. 核函数</h3>
在前文中，我们始终是在数据集是线性可分的条件下讨论的，如 <a
href="#fig1">图1</a>，即存在一个超平面能够将不同类的样本完全分开。但是现实任务中在<strong>原始样本空间</strong>中或许并不存在一个能正确划分两类样本的超平面。例如如下这种“甜甜圈”形状的数据
<span id="fig2"></span>
<figure>
<img src="2d.svg" alt="2d" width="40%" height="40%" loading="lazy"/>
<figcaption>
图2. 非线性数据
</figcaption>
</figure>
对于这样的问题，我们可以将样本数据从原始空间映射到更高纬的线性空间，使得样本在这个特征空间内线性可分。例如将
<a href="#fig2">图2</a>
中的数据从原始的二维空间映射到一个合适的三维空间（如下图），那么就能找到一个合适的划分超平面。
<span id="fig3"></span>
<figure>
<img src="2d_kernel_3d.svg" alt="3d" width="80%" height="80%" loading="lazy"/>
<figcaption>
图3. 非线性映射
</figcaption>
</figure>
<p>幸运的是，根据 <a
href="https://en.wikipedia.org/wiki/Cover%27s_theorem">Cover 定理</a>
可知，<strong>如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分</strong>
（这里的"一定"指的是概率上趋近于 1）。</p>
<p><a href="#fig3">图3</a> 中 <span
class="math inline">\(\phi(\boldsymbol{x})\)</span> 表示将 <span
class="math inline">\(\boldsymbol{x}\)</span>
映射后的结果，则在该特征空间中对应的优化问题为 <span
class="math display">\[
\begin{equation}\label{kernel_opt}
\begin{aligned}
\min_{\boldsymbol{w},b} \quad&amp;\frac{1}{2}\|\boldsymbol{w}\|^2\\
\text{s.t.} \quad&amp; y_i
\left(\boldsymbol{w}^\mathrm{T}\phi\left(\boldsymbol{x}_i\right) +
b\right) - 1\ge 0,\quad i=1,2,\dots,n
\end{aligned}
\end{equation}
\]</span> 其对偶问题为 <span class="math display">\[
\begin{equation}\label{phi_dual}
\begin{aligned}
\max_{\boldsymbol{\alpha}}
\quad&amp;\sum_{i=1}^{n}\alpha_i-\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\alpha_i
\alpha_j y_i
y_j\  \phi\left(\boldsymbol{x}_i\right)^\mathrm{T}\phi\left(\boldsymbol{x}_j\right)\\
\text{s.t.} \quad&amp; \sum_{i=1}^n \alpha_i y_i=0,\quad \alpha_i \ge 0
\end{aligned}
\end{equation}
\]</span></p>
<p>映射后的特征空间维度可能很高，为了避免显式计算映射 <span
class="math inline">\(\phi(\boldsymbol{x})\)</span>，引入核函数 <span
class="math inline">\(\kappa\left(\boldsymbol{x}_i,\boldsymbol{x}_j\right)\)</span>
直接计算高维空间的内积 <span
class="math inline">\(\phi\left(\boldsymbol{x}_i\right)^\mathrm{T}\phi\left(\boldsymbol{x}_j\right)\)</span>，即
<span class="math display">\[
\kappa\left(\boldsymbol{x}_i,\boldsymbol{x}_j\right)=\phi\left(\boldsymbol{x}_i\right)^\mathrm{T}\phi\left(\boldsymbol{x}_j\right)
\]</span></p>
<p>核函数通过直接利用原始数据 <span
class="math inline">\(\boldsymbol{x}_i,\boldsymbol{x}_j\)</span>
来计算映射到高维空间后的内积，从而避免因维度爆炸产生的高复杂度的计算以及存储问题。</p>
<p>因此 <span class="math inline">\(\eqref{phi_dual}\)</span> 可重写为
<span class="math display">\[
\begin{equation}\label{kernel_dual}
\begin{aligned}
\max_{\boldsymbol{\alpha}}
\quad&amp;\sum_{i=1}^{n}\alpha_i-\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\alpha_i
\alpha_j y_i y_j
\  \kappa\left(\boldsymbol{x}_i,\boldsymbol{x}_j\right)\\
\text{s.t.} \quad&amp; \sum_{i=1}^n \alpha_i y_i=0,\quad \alpha_i \ge 0
\end{aligned}
\end{equation}
\]</span></p>
<p>只要一个对称函数所对应的核矩阵 <span class="math inline">\(K\)</span>
是半正定的，那它就能作为核函数，即 <span class="math display">\[
K=\begin{bmatrix}
\kappa\left(\boldsymbol{x}_1,\boldsymbol{x}_1\right) &amp; \dots &amp;
\kappa\left(\boldsymbol{x}_1,\boldsymbol{x}_j\right) &amp; \dots &amp;
\kappa\left(\boldsymbol{x}_1,\boldsymbol{x}_n\right)\\
\vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots\\
\kappa\left(\boldsymbol{x}_i,\boldsymbol{x}_1\right) &amp; \dots &amp;
\kappa\left(\boldsymbol{x}_i,\boldsymbol{x}_j\right) &amp; \dots &amp;
\kappa\left(\boldsymbol{x}_i,\boldsymbol{x}_n\right)\\
\vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots\\
\kappa\left(\boldsymbol{x}_n,\boldsymbol{x}_1\right) &amp; \dots &amp;
\kappa\left(\boldsymbol{x}_n,\boldsymbol{x}_j\right) &amp; \dots &amp;
\kappa\left(\boldsymbol{x}_n,\boldsymbol{x}_n\right)\\
\end{bmatrix}
\succeq 0
\]</span></p>
<p>下表列出了几个常用的核函数</p>
<table>
<caption>
表1. 常见核函数
</caption>
<tr>
<th>
名称
</th>
<th>
表达式
</th>
<th>
参数
</th>
</tr>
<tr>
<td>
线性核
</td>
<td>
<span class="math inline">\(\kappa(x_i, x_j) = x_i^T x_j\)</span>
</td>
<td>
</td>
</tr>
<tr>
<td>
多项式核
</td>
<td>
<span class="math inline">\(\kappa(x_i, x_j) = (x_i^T x_j)^d\)</span>
</td>
<td>
<span class="math inline">\(d \geq 1\)</span> 为多项式的次数
</td>
</tr>
<tr>
<td>
高斯核，RBF 核
</td>
<td>
<span class="math inline">\(\kappa(x_i, x_j) = \exp \left( -\frac{\|x_i
- x_j\|^2}{2\sigma^2} \right)\)</span>
</td>
<td>
<span class="math inline">\(\sigma &gt; 0\)</span> 为高斯核的带宽
</td>
</tr>
<tr>
<td>
拉普拉斯核
</td>
<td>
<span class="math inline">\(\kappa(x_i, x_j) = \exp \left( -\frac{\|x_i
- x_j\|}{\sigma} \right)\)</span>
</td>
<td>
<span class="math inline">\(\sigma &gt; 0\)</span>
</td>
</tr>
<tr>
<td>
Sigmoid核
</td>
<td>
<span class="math inline">\(\kappa(x_i, x_j) = \tanh (\beta x_i^T x_j +
\theta)\)</span>
</td>
<td>
<span class="math inline">\(\tanh\)</span> 为双曲正切函数，<span
class="math inline">\(\beta &gt; 0, \theta &lt; 0\)</span>
</td>
</tr>
</table>
<h3 id="软间隔">3.4. 软间隔</h3>
<p>前文讨论都是建立在数据在原始样本空间或特征空间中是线性可分的，即硬间隔，但是实际任务中，往往很难确定一个超平面将不同类的样本完全分开，即使恰好找到了某个核函数使得样本在特征空间中线性可分，也很难判定不是由过拟合造成的。</p>
解决该问题的一个办法是允许支持向量机在一些样本上出错，因此引入软间隔的概念
<span id="fig4"></span>
<figure>
<img src="soft_svm.svg" alt="soft_svm" width="60%" height="60%" loading="lazy"/>
<figcaption>
图4. 软间隔
</figcaption>
</figure>
<p>明显的可以看到训练数据中存在一些<strong>离群点
(outliers)</strong>，也就是米黄色背景的样本，除去这些离群点后剩下的大部分样本点组成的集合是线性可分的。对于这些离群点，它们显然不满足
<span class="math inline">\(\eqref{final_opt}\)</span> 中的约束条件
<span class="math inline">\(y_i
\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i + b\right)  \ge
1\)</span>。为了解决这个问题，对每个样本点引入一个<strong>松弛变量</strong>
<span class="math inline">\(\xi_i \ge
0\)</span>，使函数间隔加上松弛变量大于等于1。这样约束变为 <span
class="math display">\[
y_i\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i+1\right) \ge 1-\xi_i
\]</span></p>
<p>同时对每个松弛变量支付一个代价。目标函数则变为 <span
class="math display">\[
\frac{1}{2}\|\boldsymbol{w}\|^2+C\sum_{i=1}^{n}\xi_i,\quad C \gt 0
\]</span> <span class="math inline">\(C\)</span> 为惩罚参数，<span
class="math inline">\(C\)</span>
越大，说明对误分类的惩罚越大；反之，对误分类的惩罚越小。</p>
<p>此时，支持向量机在软间隔下的优化问题可以描述为 <span
class="math display">\[
\begin{equation}\label{soft_opt}
\begin{aligned}
\min_{\boldsymbol{w},b,\xi}\quad &amp;
\frac{1}{2}\|\boldsymbol{w}\|^2+C\sum_{i=1}^{n}\xi_i\\
\text{s.t.}\quad &amp; y_i
\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i + b\right) \ge
1-\xi_i,\quad i=1,2,\dots,n\\
&amp; \xi_i \gt 0,\quad i=1,2,\dots,n
\end{aligned}
\end{equation}
\]</span> 最小化目标函数包含两层含义：使 <span
class="math inline">\(\frac{1}{2}\|\boldsymbol{w}\|^2\)</span>
尽可能小，即几何间隔尽可能大；同时使误分类的样本尽可能少。<span
class="math inline">\(C\)</span> 其实也相当于二者的调和系数。</p>
<p><span class="math inline">\(\eqref{spft_opt}\)</span> 的拉格朗日函数
<span class="math display">\[
\mathcal{L}\left(\boldsymbol{w},b,\boldsymbol{\xi},\boldsymbol{\alpha},\boldsymbol{\mu}\right)=\frac{1}{2}\|\boldsymbol{w}\|^2
+ C\sum_{i=1}^{n}\xi_i +
\sum_{i=1}^{n}\alpha_i\left(1-\xi_i-y_i\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i+b\right)\right)-\sum_{i=1}^{n}\mu_i\xi_i
\]</span> 其中，<span class="math inline">\(\xi_i \ge 0,\mu_i \ge
0\)</span>。</p>
<p>对偶问题为 <span class="math display">\[
\begin{aligned}
\max_{\boldsymbol{\alpha}} \quad &amp;-\frac{1}{2} \sum_{i = 1}^{n}
\sum_{j = 1}^{n} \alpha_i \alpha_j y_i y_j
\boldsymbol{x_i}^\mathrm{T}\boldsymbol{x_j} + \sum_{i = 1}^{n} \alpha_i
\\
\text{s.t.} \quad &amp;\sum_{i = 1}^{n} \alpha_i y_i = 0 \\
&amp; C - \alpha_i - \mu_i = 0 \\
&amp; \alpha_i \geq 0 \\
&amp; \mu_i \geq 0, \quad i = 1,2,\cdots,n
\end{aligned}
\]</span> 根据第二个等式约束条件消去 <span
class="math inline">\(\mu_i\)</span> 得 <span class="math display">\[
\begin{aligned}
\max_{\boldsymbol{\alpha}} \quad &amp;-\frac{1}{2} \sum_{i = 1}^{n}
\sum_{j = 1}^{n} \alpha_i \alpha_j y_i y_j
\boldsymbol{x_i}^\mathrm{T}\boldsymbol{x_j} + \sum_{i = 1}^{n} \alpha_i
\\
\text{s.t.} \quad &amp;\sum_{i = 1}^{n} \alpha_i y_i = 0 \\
&amp; 0\le\alpha_i \le C,\quad i = 1,2,\cdots,n
\end{aligned}
\]</span></p>
<details class="note info"><summary><p>SMO求解</p>
</summary>
<p>todo</p>

</details>
<h2 id="参考资料">4. 参考资料</h2>
<p><strong>[1]</strong>
李航著<span>.</span>机器学习方法[M].北京：清华大学出版社，2022.1<br />
<strong>[2]</strong> <a
href="https://blog.csdn.net/v_july_v/article/details/7624837">支持向量机通俗导论——理解SVM的三层境界</a><br />
<strong>[3]</strong> <a
href="https://timofey.pro/static/pdfdocs/AI_024_support_vector_machines_succinctly.pdf">Support
Vector Machines Succinctly</a><span id="ref3"></span><br />
<strong>[4]</strong>
周志华著<span>.</span>机器学习[M].北京：清华大学出版社，2016</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>python 装饰器</title>
    <url>/2025/01/17/python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="装饰器简介">1. 装饰器简介</h2>
<h3 id="函数装饰函数">1.1 函数装饰函数</h3>
<p>python 中的装饰器也是<strong>语法糖</strong>的一种。<br />
通常可以把装饰器理解为输入和输出都是函数的函数。
函数调用函数返回一个函数 (或者说 callab)。</p>
<p>装饰器的一大特性是，能把被装饰的函数替换成其他函数；第二个特性是，装饰器在加载模块时立即执行，函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个计时的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeit</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="comment"># 使用 *args, **kwargs 允许函数接受变长的参数</span></span><br><span class="line">    <span class="comment"># 就是说你这个函数来了什么参数 我都能接受</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        ret = f(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(time.time() - start)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">x</span>):</span><br><span class="line">    time.sleep(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于下面这种写法</span></span><br><span class="line"><span class="comment"># def myfunc(x):</span></span><br><span class="line"><span class="comment">#     time.sleep(x)</span></span><br><span class="line"><span class="comment"># myfunc = timeit(myfunc)</span></span><br></pre></td></tr></table></figure>
<p>带参数的装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timeit</span>(<span class="params">iteration</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">f</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start = time.time()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(iteration):</span><br><span class="line">                ret = f(*args, **kwargs)</span><br><span class="line">            <span class="built_in">print</span>(time.time() - start)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit(<span class="params"><span class="number">10</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面等价于：</span></span><br><span class="line"><span class="comment"># def double(x):</span></span><br><span class="line"><span class="comment">#     return x * 2</span></span><br><span class="line"><span class="comment"># double = timeit(10)(double)</span></span><br></pre></td></tr></table></figure>
<p>这里 <code>timeit(10)</code>
的返回值也是一个函数，并且这个函数的输入和输出都是函数</p>
<h3 id="类装饰函数">1.2 类装饰函数</h3>
<p>类调用一个函数返回一个 object，依然是 callable</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="variable language_">self</span>.func = func</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 变为 callable 的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        ret = <span class="variable language_">self</span>.func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Time: <span class="subst">&#123;time.time() - start&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="meta">@Timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="comment"># def add(a, b):</span></span><br><span class="line"><span class="comment">#     return a + b</span></span><br><span class="line"><span class="comment"># add = Timer(add)</span></span><br><span class="line"><span class="comment"># 相当于把一个函数变为了一个类的对象</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(add(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>带参数的类作为装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, prefix</span>):</span><br><span class="line">        <span class="variable language_">self</span>.prefix = prefix</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 变为 callable 的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, prefix</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">            start = time.time()</span><br><span class="line">            ret = <span class="variable language_">self</span>.func(*args, **kwargs)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.prefix&#125;</span><span class="subst">&#123;time.time() - start&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Timer(<span class="params">prefix=<span class="string">&quot;cost_time:&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="comment"># def add(a, b):</span></span><br><span class="line"><span class="comment">#     return a + b</span></span><br><span class="line"><span class="comment"># add = Timer(prefix=&quot;cost_time&quot;)(add)</span></span><br><span class="line"><span class="comment"># 相当于把一个函数变为了一个类的对象</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(add(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h3 id="函数装饰类">1.3 函数装饰类</h3>
<p>装饰器去装饰类</p>
<p>当打印一个自定义类的时候，不会输出任何有价值的内容，只会告诉你这是一个人什么类，除非重载他的
<code>__str__</code> 方法来改变他的 <code>print</code>
结果，但是每次都重载很麻烦，所以可以写一个装饰器来装饰类用于重载其
<code>__str__</code> 方法。下面就是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_str</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.__dict__)</span><br><span class="line">    cls.__str__ = __str__</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@add_str</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line"><span class="comment"># class MyObject:</span></span><br><span class="line"><span class="comment">#     def __init__(self, a, b):</span></span><br><span class="line"><span class="comment">#         self.a = a</span></span><br><span class="line"><span class="comment">#         self.b = b</span></span><br><span class="line"><span class="comment"># add_str(MyObject)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    obj = MyObject(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure>
<h3 id="类装饰类">1.4 类装饰类？</h3>
<p>emmm，本质上其实还是函数，是一个输入和输出都是类的函数</p>
<h3 id="小结">1.5 小结</h3>
<p>其实只要转化为等价形式就知道装饰器在干什么了，因为装饰器的本质毕竟还是语法糖。</p>
<h2 id="一些常见的装饰器">2. 一些常见的装饰器</h2>
<h3 id="staticmethod">2.1 <span class="citation"
data-cites="staticmethod">@staticmethod</span></h3>
<p>用于定义静态方法，意味着被它装饰的函数不需要创建类的实例（不需要传递
<code>self</code> 参数）就可以直接调用，即变为静态函数。</p>
<h3 id="classmethod">2.2 <span class="citation"
data-cites="classmethod">@classmethod</span></h3>
<p>用于定义类的方法，被它装饰的函数第一个参数应该为类 <code>cls</code>
，变为类的方法，但不能访问实例的属性，因为传入的是类本身
<code>cls</code> ，而不是实例 <code>self</code> 。</p>
<p>类方法可以访问类的属性和其他类方法，但不能访问实例的属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">cls, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(MyClass.static_method(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.class_method(<span class="number">2</span>, <span class="number">3</span>))   <span class="comment"># 输出: 6</span></span><br></pre></td></tr></table></figure>
<h3 id="property">2.3 <span class="citation"
data-cites="property">@property</span></h3>
<p>用于将一个方法转化为属性，可以让你在访问属性时调用一个函数，从而封装对属性的访问。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        <span class="variable language_">self</span>._radius = radius   <span class="comment"># 私有属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._radius  <span class="comment"># 只读属性     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @&lt;property_name&gt;.setter 是一个装饰器，</span></span><br><span class="line">    <span class="comment"># 用于为 @property 装饰的属性提供设置器即定义属性的写操作。</span></span><br><span class="line">    <span class="comment"># 通过这个装饰器，你可以指定如何修改某个属性的值，从而让这个属性变为可写的。</span></span><br><span class="line"><span class="meta">    @radius.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Radius cannot be negative&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._radius = value</span><br><span class="line"></span><br><span class="line">c = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(c.radius)  <span class="comment"># 输出: 5</span></span><br><span class="line">c.radius = <span class="number">10</span>    <span class="comment"># 设置 radius</span></span><br><span class="line"><span class="built_in">print</span>(c.radius)  <span class="comment"># 输出: 10</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>python 常用语法糖</title>
    <url>/2025/01/17/python-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="数字分隔符">1. 数字分隔符</h2>
<p>当数值较大时，可以用数字分隔符来进行划分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1_000_000</span> <span class="comment"># 等同于 1000000</span></span><br></pre></td></tr></table></figure>
<h2 id="交换变量值">2. 交换变量值</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>
<h2 id="连续比较式">3. 连续比较式</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">10</span> &lt; a &lt; <span class="number">20</span>:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串乘法">4. 字符串乘法</h2>
<p>可用于快速构造字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2 id="列表拼接">5. 列表拼接</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c = a + b  <span class="comment"># c = [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># a.extend(b) 后相当于 a = a + b = [1, 2, 3, 4, 5, 6], a 被改变了</span></span><br><span class="line"><span class="comment"># 不能用一个变量去接收，即 c = a.extend(b) 这样 c 的值是 None，并不会赋值给 c </span></span><br></pre></td></tr></table></figure>
<h2 id="打包解包">6. 打包解包</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x, y, z = a</span><br></pre></td></tr></table></figure>
<h2 id="with-语句">7. with 语句</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;file_name&quot;</span>,<span class="string">&#x27;mode&#x27;</span>) <span class="keyword">as</span> new_name:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>语法糖</tag>
      </tags>
  </entry>
  <entry>
    <title>git 命令思维导图</title>
    <url>/2025/01/16/git-%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<figure>
<img src="git.jpg" alt="git 命令思维导图" />
<figcaption aria-hidden="true">git 命令思维导图</figcaption>
</figure>
<p>来源：<a
href="https://github.com/toypipi/graph_bed/blob/master/image/20200810/git%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.jpg">github</a></p>
]]></content>
      <categories>
        <category>git 管理工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常用矩阵计算</title>
    <url>/2025/01/15/%E5%B8%B8%E7%94%A8%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="符号约定">1. 符号约定</h2>
<p>正常小写字母表示标量；<br />
加粗小写字母表示向量，无特殊说明时通常为<strong>列向量</strong>；<br />
大写字母表示矩阵；</p>
<h2 id="求导">2. 求导</h2>
<p>矩阵求导中的 <strong>分子布局</strong> 和 <strong>分母布局</strong>
是两种不同的约定方式，它们的主要区别在于约定导数的结果的维度和排列方式，二者均正确，但需要保障在同一环境下只能使用一种布局方式。<br />
区分是分子布局还是分母布局，可以看求导结果的第一个维度是等于分子的第一个维度还是分母的第一个维度。<br />
可以注意到分子布局和分母布局的结果互为转置。</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 36%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">分母布局</th>
<th style="text-align: center;">分子布局</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math display">\[\nonumber
\frac{\partial A\boldsymbol{x}}{\partial \boldsymbol{x}}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
A^T\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
A\]</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math display">\[\nonumber
\frac{\partial \boldsymbol{\alpha}^{T}\boldsymbol{x}}{\partial
\boldsymbol{x}} = \frac{\partial
\boldsymbol{x}^{T}\boldsymbol{\alpha}}{\partial
\boldsymbol{x}}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
\boldsymbol{\alpha}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
\boldsymbol{\alpha}^T\]</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math display">\[\nonumber
\frac{\partial\boldsymbol{y}^{T}\boldsymbol{Ax}}{\partial
A}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
\boldsymbol{y}\boldsymbol{x}^{T}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
\boldsymbol{y}^{T}\boldsymbol{x}\]</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math display">\[\nonumber
\frac{\partial
\boldsymbol{x}^TA\boldsymbol{x}}{\partial\boldsymbol{x}}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
\boldsymbol{Ax}+A^T\boldsymbol{x}\,,\ 2\boldsymbol{Ax}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
\boldsymbol{x}^TA^T+\boldsymbol{x}^TA\,,\ 2\boldsymbol{x}^T
A\]</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math display">\[\nonumber
\frac{\partial\  \mathrm{Tr}\left(X^TAX\right)}{\partial
X}=\frac{\partial\  \mathrm{Tr}\left(AXX^T\right)}{\partial
X}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
(A+A^T)X\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
X^T(A+A^T)\]</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math display">\[\nonumber
\frac{\partial\  \mathrm{Tr}\left(XAX^T\right)}{\partial
X}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
X(A^T+A)\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
(A^T+A)X^T\]</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math display">\[\nonumber
\frac{\partial \ \mathrm{Tr}(AX)}{\partial X} = \frac{\partial \
\mathrm{Tr}(XA)}{\partial X}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
A^T\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
A\]</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math display">\[\nonumber
\frac{\partial \ \mathrm{Tr}(AX^T)}{\partial X} = \frac{\partial \
\mathrm{Tr}(X^TA)}{\partial X}\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
A\]</span></td>
<td style="text-align: center;"><span class="math display">\[\nonumber
A^T\]</span></td>
</tr>
</tbody>
</table>
<h2 id="雅可比-jacobi-矩阵">3. 雅可比 (Jacobi) 矩阵</h2>
<h2 id="黑塞-hessian-矩阵">4. 黑塞 (Hessian) 矩阵</h2>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵计算</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性最小二乘</title>
    <url>/2025/01/15/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="前言">1. 前言</h2>
<p>先考虑一个最简单的最小二乘问题： <span class="math display">\[
\underset{x}{min} \frac{1}{2} \|f(\boldsymbol{x}) \|_{2}^{2}
\]</span> 这里自变量 <span class="math inline">\(\boldsymbol{x} \in
\mathbb{R}^n\)</span> ， <span class="math inline">\(f\)</span>
是任意一个非线性函数，假设他有 <span class="math inline">\(m\)</span>
维： <span class="math inline">\(f(\boldsymbol{x}) \in
\mathbb{R}^m\)</span> 。</p>
<p>考虑 <span class="math inline">\(f\)</span>
的形式基本有两种解决方法：解析法和迭代法。</p>
<h3 id="解析法">1.1 解析法</h3>
<p>当 <span class="math inline">\(f\)</span>
的数学形式比较简单的时候，或许问题可以直接用解析形式来求解。也就是让目标函数的导数为
0 ，然后求解 <span class="math inline">\(\boldsymbol{x}\)</span>
的最优值： <span class="math display">\[
\frac{\partial f}{\partial \boldsymbol{x}}=0 \nonumber
\]</span> 解上述方程即可得到目标函数导数为 0
的极值，它可能是极大值、极小值或者鞍点处的值，依次比较即可得到最小值。<br />
显然这种方法较为局限。</p>
<h3 id="迭代法">1.2 迭代法</h3>
<p>对于不易直接求导的目标函数，我们可以用迭代的方法来求极小值。根据给定的初值，不断地更新当前的优化变量，使得目标函数朝着下降的方向变化。具体步骤列写如下：</p>
<ol type="1">
<li>给定初值 <span class="math inline">\(\boldsymbol{x}_0\)</span>
；<br />
</li>
<li>对于第 <span class="math inline">\(k\)</span> 次迭代，寻找一个增量
<span class="math inline">\(\Delta \boldsymbol{x}_k\)</span>，使得 <span
class="math inline">\(\|f(\boldsymbol{x}_k + \Delta
\boldsymbol{x}_k)\|_{2}^{2}\)</span> 达到极小值；<br />
</li>
<li>如果 <span class="math inline">\(\Delta \boldsymbol{x}_k\)</span>
足够小，则停止；<br />
</li>
<li>否则，令 <span
class="math inline">\(\boldsymbol{x}_{k+1}=\boldsymbol{x}_k + \Delta
\boldsymbol{x}_k\)</span>，返回2。</li>
</ol>
<p>这样问题就转化为如何确定增量 <span class="math inline">\(\Delta
\boldsymbol{x}_k\)</span>，使上述过程收敛，通常有下面的几种方法。</p>
<h2 id="一阶和二阶梯度法最速下降法和牛顿法">2.
一阶和二阶梯度法（最速下降法和牛顿法）</h2>
<p>求解增量最直观的方法就是将 <strong>目标函数</strong> <span
id="GM"></span> 在 <span class="math inline">\(\boldsymbol{x}\)</span>
进行泰勒展开： <span class="math display">\[
\|f(\boldsymbol{x}+\Delta\boldsymbol{x})
\|_{2}^{2}=\|f(\boldsymbol{x})\|_{2}^{2}+\boldsymbol{J}(\boldsymbol{x})\Delta
\boldsymbol{x}+\frac{1}{2}\Delta \boldsymbol{x }^T \boldsymbol{H} \Delta
\boldsymbol{x}.
\]</span></p>
<p>这里 <span class="math inline">\(\boldsymbol{J}\)</span> 是 <span
class="math inline">\(\|f(\boldsymbol{x}) \|_{2}^{2}\)</span> 关于 <span
class="math inline">\(x\)</span> 的导数（雅可比矩阵），<span
class="math inline">\(\boldsymbol{H}\)</span>
则是二阶导数（黑塞矩阵）。我们可以选择保留泰勒展开的一阶或二阶项，对应的求解方法则为一阶梯度或二阶梯度法。</p>
<p>如果保留一阶梯度，那么增量的方向为： <span class="math display">\[
\Delta \boldsymbol{x}^{*}=-\boldsymbol{J}^T(\boldsymbol{x})
\]</span> 这里的转置是为了满足矩阵乘法的维度匹配。<br />
它的直观意义非常简单，只要我们沿着反向梯度方向前进即可。当然，我们还需要该方向上取一个步长
λ，求得最快的下降方式。这种方法被称为<strong>最速下降法</strong>。</p>
<p>如果保留二阶梯度，那么增量的解为： <span
class="math display">\[\label{二阶梯度法}
\boldsymbol{H} \Delta \boldsymbol{x}^{*}= - \boldsymbol{J}^T
\]</span> 该方法称又为<strong>牛顿法</strong>。</p>
<h3 id="小结">2.1 小结</h3>
<p>我们看到，一阶和二阶梯度法都十分直观，只要把函数在迭代点附近进行泰勒展开，并针对更新量作最小化即可。由于泰勒展开之后函数变成了多项式，所以求解增量时只需解线性方程即可，避免了直接求导函数为零这样的非线性方程的困难。</p>
<p>不过，这两种方法也存在它们自身的问题。最速下降法过于贪心，容易走出锯齿路线，反而增加了迭代次数。而牛顿法则需要计算目标函数的
<span class="math inline">\(\boldsymbol{H}\)</span>
矩阵，这在问题规模较大时非常困难，我们通常倾向于避免 <span
class="math inline">\(\boldsymbol{H}\)</span>
的计算。所以，接下来我们详细地介绍两类更加实用的方法： Gauss-Newton 和
Levenberg-Marquadt 。</p>
<h2 id="gauss-newton">3. Gauss-Newton</h2>
<p>Gauss Newton 是最优化算法里面最简单的方法之一。它的思想是将 <span
class="math inline">\(f(\boldsymbol{x})\)</span>
进行一阶的泰勒展开：<br />
<span class="math display">\[\label{局部近似}
f(\boldsymbol{x}+\Delta \boldsymbol{x}) \approx
f(\boldsymbol{x})+\boldsymbol{J}(\boldsymbol{x})\Delta\boldsymbol{x}
\]</span> 这里 <span
class="math inline">\(\boldsymbol{J}(\boldsymbol{x})\)</span> 是 <span
class="math inline">\(f(\boldsymbol{x})\)</span> 关于 <span
class="math inline">\(\boldsymbol{x}\)</span> 的导数，实际上是一个 <span
class="math inline">\(m\times m\)</span>
的矩阵，也是一个雅可比矩阵。</p>
<div class="note danger"><p>这里是对 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在
<span class="math inline">\(\boldsymbol{x}\)</span>
处进行泰勒展开，而不是对目标函数进行泰勒展开，需要和 <a
href="#GM">梯度法</a> 中进行区分对比！</p>
</div>
<p>根据前面的思想，我们当前的目标是为了寻找下降矢量 <span
class="math inline">\(\Delta\boldsymbol{x}\)</span>，使 <span
class="math inline">\(\|f(\boldsymbol{x}+\Delta\boldsymbol{x})\|_{2}^{2}\)</span>
达到最小。即<br />
<span class="math display">\[
\Delta \boldsymbol{x}^{*}=arg\  \underset{\Delta \boldsymbol{x}}{min}
\frac{1}{2}\|f(\boldsymbol{x})+\boldsymbol{J}(\boldsymbol{x})\Delta\boldsymbol{x}\|_{2}^{2}
\]</span> 将目标函数展开化简得： <span class="math display">\[
\begin{equation*}
\begin{aligned}
\frac{1}{2}\|f(\boldsymbol{x})+\boldsymbol{J}(\boldsymbol{x})\Delta\boldsymbol{x}\|_{2}^{2}&amp;=\frac{1}{2}(f(\boldsymbol{x})+\boldsymbol{J}(\boldsymbol{x})\Delta\boldsymbol{x})^T(f(\boldsymbol{x})+\boldsymbol{J}(\boldsymbol{x})\Delta\boldsymbol{x})
\\
&amp;=\frac{1}{2}(\|f(\boldsymbol{x})\|_{2}^{2} +
2f(\boldsymbol{x})^T\boldsymbol{J}(\boldsymbol{x}+\Delta\boldsymbol{x}^T
\boldsymbol{J}(\boldsymbol{x})^T\boldsymbol{J}(x)^T\Delta
\boldsymbol{x}))
\end{aligned}
\end{equation*}
\]</span></p>
<p>求上述目标函数对 <span class="math inline">\(\Delta
\boldsymbol{x}\)</span> 的导数，并令其为 0： <span
class="math display">\[\nonumber
2\boldsymbol{J}(\boldsymbol{x})^T \boldsymbol{J}(\boldsymbol{x})\Delta
\boldsymbol{x}+2\boldsymbol{J}(\boldsymbol{x})^T f(\boldsymbol{x})=0
\]</span></p>
<p>可以得到： <span class="math display">\[
\boldsymbol{J}(\boldsymbol{x})^T \boldsymbol{J}(\boldsymbol{x})\Delta
\boldsymbol{x}=-\boldsymbol{J}(\boldsymbol{x})^T f(\boldsymbol{x})
\]</span></p>
<p>注意，我们要求解的变量是 <span class="math inline">\(\Delta
\boldsymbol{x}\)</span>，因此这是一个线性方程组，我们称它为<strong>增量方程</strong>，也可以称为<strong>高斯牛顿方程</strong>
(Gauss Newton equations) 或者<strong>正规方程</strong> (Normal
equations)。我们把左边的系数定义为 <span
class="math inline">\(\boldsymbol{H}\)</span>，右边定义为 <span
class="math inline">\(\boldsymbol{g}\)</span>，那么上式变为：<br />
<span class="math display">\[
\boldsymbol{H}\Delta \boldsymbol{x} = \boldsymbol{g}
\]</span></p>
<p>Gauss-Newton 的步骤可以写为：</p>
<ol type="1">
<li>给定初值 <span
class="math inline">\(\boldsymbol{x}_0\)</span>；<br />
</li>
<li>对于第 <span class="math inline">\(k\)</span>
次迭代，求出当前的雅可比矩阵 <span
class="math inline">\(\boldsymbol{J}(\boldsymbol{x}_k)\)</span>
和误差<span class="math inline">\(f(\boldsymbol{x}_k)\)</span>；<br />
</li>
<li>求解增量方程： <span class="math inline">\(\boldsymbol{H}\Delta
\boldsymbol{x}_k = \boldsymbol{g}\)</span> ；<br />
</li>
<li>如果 <span class="math inline">\(\Delta \boldsymbol{x}_k\)</span>
足够小，则停止；否则，令 <span
class="math inline">\(\boldsymbol{x}_{k+1}=\boldsymbol{x}_k+\Delta
\boldsymbol{x}_k\)</span> ，返回 2。</li>
</ol>
<p><strong>求解增量方程是整个优化问题的核心所在</strong>。</p>
<h3 id="小结-1">3.1 小结</h3>
<p>和 二阶梯度法（牛顿法）<span
class="math inline">\(\eqref{二阶梯度法}\)</span>
的增量解进行对比，可以发现 Gauss-Newton 中用 <span
class="math inline">\(\boldsymbol{J}^{T}\boldsymbol{J}\)</span>
作为牛顿法中二阶 Hessian 矩阵的近似，从而省略了计算 <span
class="math inline">\(\boldsymbol{H}\)</span> 的过程。</p>
<p>Gauss-Newton 的核心在于求解增量方程，但它要求 <span
class="math inline">\(\boldsymbol{H}\)</span>
是可逆且正定的，但实际中计算的 <span
class="math inline">\(\boldsymbol{H}=\boldsymbol{J}^{T}\boldsymbol{J}\)</span>
通常只是半正定的。因此，在使用 Gauss-Newton 的时候可能会出现 <span
class="math inline">\(\boldsymbol{H}\)</span>
是奇异或者病态的情况，导致算法不收敛。更严重的是，就算我们假设 <span
class="math inline">\(\boldsymbol{H}\)</span>
非奇异也非病态，如果我们求出来的步长 <span class="math inline">\(\Delta
\boldsymbol{x}\)</span> 太大，也会导致我们采用的局部近似 <span
class="math inline">\(\eqref{局部近似}\)</span>
不够准确，这样一来我们甚至都无法保证它的迭代收敛，哪怕是让目标函数变得更大都是有可能的。</p>
<p>尽管 Gauss-Newton
有这些缺点，但是它依然值得我们去学习，因为在非线性优化里，相当多的算法都可以归结为
Gauss-Newton 的变种。这些算法都借助了 Gauss-Newton
法的思想并且通过自己的改进修正 Gauss-Newton 法的缺点。例如一些线搜索方法
(line search method)，这类改进就是加入了一个标量 <span
class="math inline">\(\alpha\)</span>，在确定了 <span
class="math inline">\(\Delta \boldsymbol{x}\)</span> 进一步找到 <span
class="math inline">\(\alpha\)</span> 使得 <span
class="math inline">\(\|f(\boldsymbol{x}+\alpha \Delta
\boldsymbol{x})\|_{2}^{2}\)</span> 达到最小，而不是像 Gauss-Newton
法那样简单地令 <span class="math inline">\(α = 1\)</span>。</p>
<p>Levenberg-Marquadt
方法在一定程度上修正了这些问题，被称之为阻尼牛顿法(Damped Newton
Method)，一般认为它比高斯牛顿更为鲁棒。尽管它的收敛速度可能会比高斯牛顿更慢，但是在
SLAM 里面却被大量应用。</p>
<h2 id="levenberg-marquadt">4. Levenberg-Marquadt</h2>
<p>前文提到当 <span class="math inline">\(\Delta \boldsymbol{x}\)</span>
太大时，Gauss-Newton 方法中采用的近似二阶泰勒展开 <span
class="math inline">\(\eqref{局部近似}\)</span>
存在不够准确的问题，很自然的想到对 <span class="math inline">\(\Delta
\boldsymbol{x}\)</span> 增加一个信赖区域 (Trust Region)，不能让 <span
class="math inline">\(\Delta \boldsymbol{x}\)</span>
因太大而使得近似不够准却。这种添加信赖区域的方法在非线性优化中被称为
<strong>信赖区域方法 (Trust Region Method)</strong>
。只有在规定的信赖区域中的 <span class="math inline">\(\Delta
\boldsymbol{x}\)</span> 才认为近似是有效的。<br />
那么如何确定这个信赖区域的范围呢？一个比较好的方法是根据我们的近似模型跟实际函数之间的差异来确定这个范围：如果差异小，我们就让范围尽可能大；如果差异大，我们就缩小这个近似范围。因此，考虑使用下式来判断泰勒近似是否够好。
<span class="math display">\[
\rho=\frac{f(\boldsymbol{x+\Delta
\boldsymbol{x}})-f(\boldsymbol{x})}{\boldsymbol{J}(\boldsymbol{x})\Delta
\boldsymbol{x}}=\frac{实际函数下降值}{近似模型下降值}
\]</span> 显然，当 <span class="math inline">\(\rho \rightarrow
1\)</span> 时，近似效果最好；<br />
当 <span class="math inline">\(\rho \ll 1\)</span>
时，说明实际下降值远小于近似下降值，我们需要缩小近似范围，即减小 <span
class="math inline">\(\Delta \boldsymbol{x}\)</span> ；<br />
当 <span class="math inline">\(\rho \gg 1\)</span>
时，说明实际下降值远大于近似下降值，我们需要增大近似范围，即增大 <span
class="math inline">\(\Delta \boldsymbol{x}\)</span> 。</p>
<p>依此，我们可以改进 Gauss-Newton 非线性优化的框架：</p>
<ol type="1">
<li>给定初始值 <span
class="math inline">\(\boldsymbol{x}_0\)</span>，以及初始优化半径 <span
class="math inline">\(\mu\)</span>；</li>
<li>对于第 <span class="math inline">\(k\)</span> 次迭代，求解：<span
class="math display">\[\label{L-M} \underset{\Delta
\boldsymbol{x}_k}{min}
\frac{1}{2}\|f(\boldsymbol{x}_k)+\boldsymbol{J}(\boldsymbol{x}_k)\Delta
\boldsymbol{x}_k\|_{2}^{2},\ s.t.\|\boldsymbol{D}\Delta
\boldsymbol{x}_k\|^{2}\le \mu\]</span> 这里 <span
class="math inline">\(\mu\)</span> 是信赖区域的半径，<span
class="math inline">\(\boldsymbol{D}\)</span> 是一个调整矩阵</li>
<li>计算 <span class="math inline">\(\rho\)</span>；</li>
<li>如果 <span class="math inline">\(\rho \gt \frac{3}{4}\)</span>，则
<span class="math inline">\(\mu = 2\mu\)</span>；如果 <span
class="math inline">\(\rho \lt \frac{1}{4}\)</span>，则 <span
class="math inline">\(\mu = 0.5\mu\)</span>；否则，<span
class="math inline">\(\mu\)</span>
保持不变。这里的阈值和扩大倍数都是经验值，可视情况调整；</li>
<li>如果 <span class="math inline">\(\rho\)</span>
大于某阈值，认为近似可行。令 <span
class="math inline">\(\boldsymbol{x}_{k+1}=\boldsymbol{x}_k+\Delta
\boldsymbol{x}_k\)</span>；</li>
<li>判断算法是否收敛。如果不收敛则返回2，否则结束。</li>
</ol>
<p>关于 <span class="math inline">\(\eqref{L-M}\)</span> 中 <span
class="math inline">\(\boldsymbol{D}\)</span> 的说明：<br />
当 <span class="math inline">\(\boldsymbol{D}=\boldsymbol{I}\)</span>
时，这里的约束条件可看作是将 <span class="math inline">\(\Delta
\boldsymbol{x}\)</span> 约束在一个半径为 <span
class="math inline">\(\mu\)</span> 的球内；当 <span
class="math inline">\(\boldsymbol{D} \ne \boldsymbol{I}\)</span>
时，可以认为这是一个椭球。 在 L-M 算法中，取 <span
class="math inline">\(\boldsymbol{D}\)</span> 为非负对角矩阵（由 <span
class="math inline">\(\boldsymbol{J}^{T}\boldsymbol{J}\)</span>
的对角元素平方根构成），使得在梯度小的维度上约束范围更大一些。</p>
<p>根据<span class="math inline">\(\eqref{L-M}\)</span> 求解增量，
拉格朗日法： <span class="math display">\[
\nonumber
L=\frac{1}{2}\|f(\boldsymbol{x}_k)+\boldsymbol{J}(\boldsymbol{x}_k)\Delta
\boldsymbol{x}_k\|_{2}^{2}+\frac{\lambda}{2}\|\boldsymbol{D}\Delta\boldsymbol{x}_k\|_{2}^{2},\lambda
\gt 0
\]</span> 令偏导为0，可得增量方程： <span class="math display">\[
\frac{\partial L}{\partial \Delta\boldsymbol{x}_k}=\boldsymbol{0}
\Longrightarrow (\boldsymbol{H}+\lambda
\boldsymbol{D}^{T}\boldsymbol{D})\Delta \boldsymbol{x}_k=\boldsymbol{g}
\]</span></p>
<p>从结果来看，当 <span class="math inline">\(\lambda\)</span>
较小时，<span class="math inline">\(\boldsymbol{H}\)</span>
占主导地位，说明二次近似模型效果在该范围内是比较好的，此时 L-M 法接近于
G-N 法；当 <span class="math inline">\(\lambda\)</span> 较大时，考虑
<span class="math inline">\(\boldsymbol{D}=\boldsymbol{I}\)</span>
的简化形式，此时 <span class="math inline">\(\lambda \boldsymbol{D}^T
\boldsymbol{D}=\lambda \boldsymbol{I}\)</span>
占主导地位，说明二次近似的不够好，此时 L-M 法更接近于
一阶梯度下降法（最速下降法）。</p>
<p>L-M
的求解方式，可在一定程度上避免线性方程组的系数矩阵的非奇异和病态问题，提供更稳定更准确的增量
<span class="math inline">\(\Delta \boldsymbol{x}\)</span>。</p>
<p>总而言之，非线性优化问题的框架，分为 Line Search 和 Trust Region
两类。<br />
Line Search 先固定搜索方向，然后在该方向寻找步长，以最速下降法和
Gauss-Newton 法为代表。而 TrustRegion
则先固定搜索区域，再考虑找该区域内的最优点。此类方法以 L-M
为代表。实际问题中，我们通常选择 G-N 或 L-M 之一作为梯度下降策略。</p>
<h2 id="参考资料">5. 参考资料</h2>
<p><strong>[1]</strong> 视觉 SLAM 十四讲 —— 高翔</p>
]]></content>
      <categories>
        <category>最优化</category>
      </categories>
      <tags>
        <tag>Levenberg-Marquadt</tag>
      </tags>
  </entry>
  <entry>
    <title>B样条曲线简介及其python实现</title>
    <url>/2025/01/08/B%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="b样条曲线的计算公式">1. B样条曲线的计算公式</h2>
<p>B 样条曲线 <span class="math inline">\(P(u)\)</span>
可以表示为控制点和基函数的加权和： <span class="math display">\[
P(u)=\sum_{i=0}^{n} {p_i B_{i,k}(u)} \ ,u\in \left[ u_{k-1}, u_{k+1}
\right]
\tag{1}
\]</span></p>
<h2 id="符号解释">2. 符号解释</h2>
<h3 id="pu">2.1 <span class="math inline">\(P(u)\)</span></h3>
<p>B 样条曲线上的点，也是我们所要求的结果。</p>
<h3 id="p_i">2.2 <span class="math inline">\(p_i\)</span></h3>
<p>控制点， <span class="math inline">\(i=0,1,2,..,n\)</span>，一共有
<span class="math inline">\(n+1\)</span> 个。</p>
<h3 id="b_ik">2.3 <span class="math inline">\(B_{i,k}\)</span></h3>
<p>基函数</p>
<h3 id="u">2.4 <span class="math inline">\(u\)</span> <span
id="2.4"></span></h3>
<p>相当于自变量，有效区间为 <span class="math inline">\(\left[ u_{k-1},
u_{k+1} \right]\)</span>。</p>
<h3 id="k">2.5 <span class="math inline">\(k\)</span></h3>
<p>B
样条曲线的<strong>次数</strong>，这里要注意次数和阶数的区别和联系：次数
= 阶数 - 1。</p>
<p>对于 B 样条的次数 <span
class="math inline">\(k\)</span>，必须满足：<span id="(2)"></span> <span
class="math display">\[k = m - n - 1 \tag{2}\]</span> 其中 <span
class="math inline">\(m\)</span><span id="m"></span> 是 <strong>节点
(knots)</strong> 将 B 样条曲线划分的段数，<span
class="math inline">\(n\)</span> 为控制点的个数减一。</p>
<p>上面说的节点就是划分 B
样条的比例，由节点组成的一组向量就成为节点矢量，例如
<code>[0, 0.2, 0.4, 0.6, 0.8, 1]</code>。不同的节点矢量进而产生了不同的
B 样条种类，例如均匀 B 样条、准均匀 B 样条、分段 B 样条以及非均匀 B
样条等等。</p>
<h2 id="基函数的计算">3. 基函数的计算</h2>
<p>de Boor-Cox递归方法<br />
<span class="math display">\[
B_{i,k}(u)=\frac{u-u_i}{u_{i+1}-u_i}B_{i,k-1}(u)+\frac{u_{i+k}-u}{u_{i+k}-u_{i+1}}B_{i+1,k-1}(u)
\tag{3}
\]</span></p>
<p>这里需要给出说明，不带下标的 <span class="math inline">\(u\)</span>
指的是 <a href="#2.4">2.4</a> 中的 <span
class="math inline">\(u\)</span>，而带下标则指的是节点矢量。</p>
<p>在代码实现中，我们规定 <span
class="math inline">\(\frac{0}{0}=0\)</span>。</p>
<h2 id="节点矢量-knots-的计算">4. 节点矢量 (knots) 的计算</h2>
<p>节点矢量的取值可以是在 0 到 1
之间，也可以是其他范围，但是在代码是实现的时候一定要注意前后保持一致。<br />
本文使用节点矢量取值为 0 到 1，这样也可以表示比例嘛。</p>
<p>这里需要注意节矢量的长度，也就是 <span
class="math inline">\(m\)</span>，通过式 <a href="#(2)">(2)</a>
可知，<span class="math inline">\(m=k+n+1\)</span>。</p>
<h3 id="均匀节点-uniform-node">4.1 均匀节点 (uniform node)</h3>
<p>显然，节点的分布是均匀的，故从 0 到
1按照节点矢量的长度均匀划分即可。<br />
（因为要将曲线划分为 <a href="#m">m</a> 段，当然需要 m+1个点）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uniform_node</span>(<span class="params">control_points, k=<span class="number">3</span></span>):</span><br><span class="line">    num, _ = control_points.shape</span><br><span class="line">    n = num - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> np.linspace(<span class="number">0</span>, <span class="number">1</span>, n + k + <span class="number">2</span>)  <span class="comment"># m = n + k + 1</span></span><br></pre></td></tr></table></figure>
<p>均匀 B 样条曲线不一定过首尾控制点，并且在图像上是闭合的</p>
<h3 id="准均匀节点-quasi-uniform-node">4.2 准均匀节点 (quasi uniform
node)</h3>
<p>准均匀节点可以目的在于对曲线的端点进行行为控制，通过设计节点矢量，使得生成的
B 样条曲线经过首尾控制点。<br />
<span class="math inline">\(k\)</span>
次准均匀节点矢量中，两端节点具有重复度 <span
class="math inline">\(k+1\)</span>，所有内节点呈现均匀分布。<br />
在代码实现中，我们可以让节点矢量首尾分别为 <span
class="math inline">\(k\)</span> 个 0 和 1，然后中间 <span
class="math inline">\(n-k+2\)</span> 为 0 到 1 的均匀分布就行了，即
<span class="math display">\[ \nonumber
\left[ \begin{matrix}
\underset{k}{\underbrace{0,0,...,0}},\
\underset{n-k+2}{\underbrace{0,...,1}},\
\underset{k}{\underbrace{1,1,...,1}}\\
\end{matrix} \right]
\]</span></p>
<figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quasi_uniform_node</span>(<span class="params">control_points, k=<span class="number">3</span></span>):</span><br><span class="line">    num, _ = control_points.shape</span><br><span class="line">    n = num - <span class="number">1</span></span><br><span class="line">    mid = np.linspace(<span class="number">0</span>, <span class="number">1</span>, n - k + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.r_[np.zeros(k), mid, np.ones(k)]  <span class="comment"># 拼接</span></span><br></pre></td></tr></table></figure>
<h3 id="分段节点-piecewise-node">4.3 分段节点 (piecewise node)</h3>
<p>基于该节点矢量的 B 样样条曲线又称为分段 Bezier
曲线，是一组顺序首尾相接且同为 <span class="math inline">\(k\)</span>
次的 Bezier 曲线。<br />
<span class="math inline">\(k\)</span>
次的分段节点矢量中，首末端节点重复度依旧为 <span
class="math inline">\(k+1\)</span>，内节点重复度为 <span
class="math inline">\(k\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">piecewise_node</span>(<span class="params">control_points, k=<span class="number">3</span></span>):</span><br><span class="line">    num, _ = control_points.shape</span><br><span class="line">    n = num - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## restricted condition</span></span><br><span class="line">    <span class="keyword">assert</span> (n - k) % k == <span class="number">0</span>, <span class="string">&quot;input is valid.&quot;</span></span><br><span class="line"></span><br><span class="line">    tmp = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">int</span>((n - k) / k + <span class="number">2</span>))</span><br><span class="line">    mid = np.r_[tmp[<span class="number">0</span>], np.repeat(tmp[<span class="number">1</span>:-<span class="number">1</span>], k), tmp[-<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">return</span> np.r_[np.zeros(k), mid, np.ones(k)]</span><br></pre></td></tr></table></figure>
<p>需要注意 <span class="math inline">\(n-k\)</span> 必须是 <span
class="math inline">\(k\)</span> 的整数倍，否则不能生成曲线。</p>
<h3 id="非均匀节点-non-uniform-node">4.4 非均匀节点 (non-uniform
node)</h3>
<p>Hartley-Judd 算法 首尾重合度为 <span
class="math inline">\(k+1\)</span>，内节点定义为：</p>
<p><span class="math display">\[
\begin{cases}
t_k=0\\
t_i=\sum_{j=k+1}^i{\bigl( t_j-t_{j-1} \bigr)} \\
t_{n+1}=1\\
\end{cases}
\tag{4}
\]</span> <span class="math display">\[
t_i-t_{i-1}=\frac{\sum_{j=i-k}^{i-1}{l_j}}{\sum_{i=k+1}^{n+1}{\sum_{j=i-k}^{i-1}{l_j}}}
\tag{5}
\]</span></p>
<figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">non_uniform_node</span>(<span class="params">control_points, k=<span class="number">3</span></span>):</span><br><span class="line">    num, _ = control_points.shape</span><br><span class="line">    n = num - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    l = np.sqrt(np.<span class="built_in">sum</span>(np.diff(control_points, axis=<span class="number">0</span>) ** <span class="number">2</span>, axis=<span class="number">1</span>))</span><br><span class="line">    ll = l[<span class="number">0</span> : <span class="built_in">len</span>(l) - <span class="number">1</span>] + l[<span class="number">1</span>::]</span><br><span class="line">    L = np.<span class="built_in">sum</span>(ll)</span><br><span class="line"></span><br><span class="line">    mid_size = n - k</span><br><span class="line">    mid = np.zeros(mid_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mid_size):</span><br><span class="line">        mid[i] = np.<span class="built_in">sum</span>(ll[<span class="number">0</span> : i + <span class="number">1</span>]) / L</span><br><span class="line"></span><br><span class="line">    knots = np.r_[np.zeros(k + <span class="number">1</span>), mid, np.ones(k + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> knots</span><br></pre></td></tr></table></figure>
<h2 id="python-实现">5. python 实现</h2>
<figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uniform_node</span>(<span class="params">control_points, k=<span class="number">3</span></span>):</span><br><span class="line">    num, _ = control_points.shape</span><br><span class="line">    n = num - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.linspace(<span class="number">0</span>, <span class="number">1</span>, n + k + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quasi_uniform_node</span>(<span class="params">control_points, k=<span class="number">3</span></span>):</span><br><span class="line">    num, _ = control_points.shape</span><br><span class="line">    n = num - <span class="number">1</span></span><br><span class="line">    mid = np.linspace(<span class="number">0</span>, <span class="number">1</span>, n - k + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.r_[np.zeros(k), mid, np.ones(k)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">piecewise_node</span>(<span class="params">control_points, k=<span class="number">3</span></span>):</span><br><span class="line">    num, _ = control_points.shape</span><br><span class="line">    n = num - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## restricted condition</span></span><br><span class="line">    <span class="keyword">assert</span> (n - k) % k == <span class="number">0</span>, <span class="string">&quot;input is valid.&quot;</span></span><br><span class="line"></span><br><span class="line">    tmp = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">int</span>((n - k) / k + <span class="number">2</span>))</span><br><span class="line">    mid = np.r_[tmp[<span class="number">0</span>], np.repeat(tmp[<span class="number">1</span>:-<span class="number">1</span>], k), tmp[-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.r_[np.zeros(k), mid, np.ones(k)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">non_uniform_node</span>(<span class="params">control_points, k=<span class="number">3</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Hartley-Judd algorithem</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num, _ = control_points.shape</span><br><span class="line">    n = num - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    l = np.sqrt(np.<span class="built_in">sum</span>(np.diff(control_points, axis=<span class="number">0</span>) ** <span class="number">2</span>, axis=<span class="number">1</span>))</span><br><span class="line">    ll = l[<span class="number">0</span> : <span class="built_in">len</span>(l) - <span class="number">1</span>] + l[<span class="number">1</span>::]</span><br><span class="line">    L = np.<span class="built_in">sum</span>(ll)</span><br><span class="line"></span><br><span class="line">    mid_size = n - k</span><br><span class="line">    mid = np.zeros(mid_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mid_size):</span><br><span class="line">        mid[i] = np.<span class="built_in">sum</span>(ll[<span class="number">0</span> : i + <span class="number">1</span>]) / L</span><br><span class="line"></span><br><span class="line">    knots = np.r_[np.zeros(k + <span class="number">1</span>), mid, np.ones(k + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> knots</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_B</span>(<span class="params">i, k, knots, u</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    de Boor-Cox recursion</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        i (int): ith point idx</span></span><br><span class="line"><span class="string">        k (int): degree of b-spline , equal to ord - 1</span></span><br><span class="line"><span class="string">        knots (ndarray): 1 dim</span></span><br><span class="line"><span class="string">        u : independent variable</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        B: B_&#123;i,k&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        B = <span class="number">1</span> <span class="keyword">if</span> knots[i] &lt;= u &lt;= knots[i + <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span>  <span class="comment">##</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        coef1 = coef2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> knots[i + k - <span class="number">1</span>] - knots[i] != <span class="number">0</span>:</span><br><span class="line">            coef1 = (u - knots[i]) / (knots[i + k - <span class="number">1</span>] - knots[i])</span><br><span class="line">        <span class="keyword">if</span> knots[i + k] - knots[i + <span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">            coef2 = (knots[i + k] - u) / (knots[i + k] - knots[i + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        B = coef1 * cal_B(i, k - <span class="number">1</span>, knots, u) + coef2 * cal_B(i + <span class="number">1</span>, k - <span class="number">1</span>, knots, u)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_curve</span>(<span class="params">control_points, knots, t</span>):</span><br><span class="line"></span><br><span class="line">    num, dims = control_points.shape</span><br><span class="line">    n = num - <span class="number">1</span></span><br><span class="line">    k = <span class="built_in">len</span>(knots) - n - <span class="number">1</span>  <span class="comment"># degree of b-spline</span></span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">len</span>(t)</span><br><span class="line">    P = np.zeros((N, dims))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        u = t[idx]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num):</span><br><span class="line">            P[idx, :] += control_points[i, :] * cal_B(i, k, knots, u)</span><br><span class="line">    <span class="keyword">return</span> P</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 体验 https://superjerryshen.github.io/b-spline-demos/##/uniform-b-spline-of-order-3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">    control_points = np.array([[<span class="number">50</span>, <span class="number">50</span>], [<span class="number">100</span>, <span class="number">300</span>], [<span class="number">300</span>, <span class="number">100</span>], [<span class="number">380</span>, <span class="number">200</span>], [<span class="number">400</span>, <span class="number">600</span>], [<span class="number">500</span>, <span class="number">400</span>], [<span class="number">300</span>, <span class="number">600</span>]])</span><br><span class="line">    </span><br><span class="line">    N = <span class="number">500</span></span><br><span class="line">    t = np.linspace(<span class="number">0.0</span>, <span class="number">1.0</span>, N)</span><br><span class="line"></span><br><span class="line">    uniform_knots = uniform_node(control_points)</span><br><span class="line">    quasi_knots = quasi_uniform_node(control_points)</span><br><span class="line">    piecewise_knots = piecewise_node(control_points)</span><br><span class="line">    non_knots = non_uniform_node(control_points)</span><br><span class="line"></span><br><span class="line">    P_uniform = cal_curve(control_points, uniform_knots, t)</span><br><span class="line">    P_quasi = cal_curve(control_points, quasi_knots, t)</span><br><span class="line">    P_piecewise = cal_curve(control_points, piecewise_knots, t)</span><br><span class="line">    P_non = cal_curve(control_points, non_knots, t)</span><br><span class="line"></span><br><span class="line">    fig, axs = plt.subplots(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 均匀 会闭合</span></span><br><span class="line">    axs[<span class="number">0</span>, <span class="number">0</span>].scatter(control_points[:, <span class="number">0</span>], control_points[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, facecolors=<span class="string">&quot;none&quot;</span>, label=<span class="string">&quot;control points&quot;</span>)</span><br><span class="line">    axs[<span class="number">0</span>, <span class="number">0</span>].plot(control_points[:, <span class="number">0</span>], control_points[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, linewidth=<span class="number">0.2</span>)</span><br><span class="line">    axs[<span class="number">0</span>, <span class="number">0</span>].plot(P_uniform[:, <span class="number">0</span>], P_uniform[:, <span class="number">1</span>], color=<span class="string">&quot;C3&quot;</span>, label=<span class="string">&quot;uniform&quot;</span>)</span><br><span class="line">    axs[<span class="number">0</span>, <span class="number">0</span>].legend()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 准均匀</span></span><br><span class="line">    axs[<span class="number">0</span>, <span class="number">1</span>].scatter(control_points[:, <span class="number">0</span>], control_points[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, facecolors=<span class="string">&quot;none&quot;</span>, label=<span class="string">&quot;control points&quot;</span>)</span><br><span class="line">    axs[<span class="number">0</span>, <span class="number">1</span>].plot(control_points[:, <span class="number">0</span>], control_points[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, linewidth=<span class="number">0.2</span>)</span><br><span class="line">    axs[<span class="number">0</span>, <span class="number">1</span>].plot(P_quasi[:, <span class="number">0</span>], P_quasi[:, <span class="number">1</span>], color=<span class="string">&quot;C3&quot;</span>, label=<span class="string">&quot;quasi&quot;</span>)</span><br><span class="line">    axs[<span class="number">0</span>, <span class="number">1</span>].legend()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 分段</span></span><br><span class="line">    axs[<span class="number">1</span>, <span class="number">0</span>].scatter(control_points[:, <span class="number">0</span>], control_points[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, facecolors=<span class="string">&quot;none&quot;</span>, label=<span class="string">&quot;control points&quot;</span>)</span><br><span class="line">    axs[<span class="number">1</span>, <span class="number">0</span>].plot(control_points[:, <span class="number">0</span>], control_points[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, linewidth=<span class="number">0.2</span>)</span><br><span class="line">    axs[<span class="number">1</span>, <span class="number">0</span>].plot(P_piecewise[:, <span class="number">0</span>], P_piecewise[:, <span class="number">1</span>], color=<span class="string">&quot;C3&quot;</span>, label=<span class="string">&quot;piecewise&quot;</span>)</span><br><span class="line">    axs[<span class="number">1</span>, <span class="number">0</span>].legend()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">## HJ 非均匀</span></span><br><span class="line">    axs[<span class="number">1</span>,<span class="number">1</span>].scatter(control_points[:, <span class="number">0</span>], control_points[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, facecolors=<span class="string">&quot;none&quot;</span>, label=<span class="string">&quot;control points&quot;</span>)</span><br><span class="line">    axs[<span class="number">1</span>,<span class="number">1</span>].plot(control_points[:, <span class="number">0</span>], control_points[:, <span class="number">1</span>], color=<span class="string">&quot;C0&quot;</span>, linewidth=<span class="number">0.2</span>)</span><br><span class="line">    axs[<span class="number">1</span>,<span class="number">1</span>].plot(P_non[:, <span class="number">0</span>], P_non[:, <span class="number">1</span>], color=<span class="string">&quot;C3&quot;</span>, label=<span class="string">&quot;non uniform&quot;</span>)</span><br><span class="line">    axs[<span class="number">1</span>,<span class="number">1</span>].legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：<br />
<img src="BSpline.png" alt="BSpline" /></p>
<p>todo：<br />
很诡异的一点，在 <code>cal_curve</code> 函数中计算 <span
class="math inline">\(k\)</span> 的时候，满足 <span
class="math inline">\(k=m-n-1\)</span>
的时候，后三种样条曲线都不经过首尾控制点，这是不符合预期的，但是用 <span
class="math inline">\(k = (m+1) - n - 1\)</span>
的时候，却和正常预期的结果一样，不知道是哪里出问题了。<br />
有空了再来填补空缺</p>
<h2 id="参考">6. 参考</h2>
<p><strong>[1]</strong> <a
href="https://b23.tv/e93CqZR">计算机图形学-中国农大-赵明-B站
8.5.1~8.6.2</a><br />
<strong>[2]</strong> <a
href="https://blog.csdn.net/deepsprings/article/details/107828889?spm=1001.2014.3001.5506">详解样条曲线-CSDN</a><br />
<strong>[3]</strong> <a
href="https://zhuanlan.zhihu.com/p/686518292">B样条曲线和Nurbs曲线
图文并茂的理解节点和节点区间-知乎</a><br />
<strong>[4]</strong>《计算几何算法与实现》—— 孔令德</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>B样条</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 中的 markdown 语法</title>
    <url>/2025/01/07/Hexo%E4%B8%AD%E7%9A%84md%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<h2 id="页内跳转">1. 页内跳转</h2>
<p>跳转到地方后面加上
<code>&lt;span id="jump"&gt;&lt;/span&gt;</code><br />
需要跳转的地方 <code>[跳转到](#jump)</code><br />
注：<code>jump</code> 字段不能有中文、空格</p>
<h2 id="博客嵌入图片">2. 博客嵌入图片</h2>
<p>在 Hexo 的 <code>_config.yml</code> 文件下设置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>此后当新建 <code>.md</code>
文件时，会在同级目录下自动生成一个同名文件夹，里面课以用于存放附件（如图片等）。<br />
此时图片引用语法： <code>![文本](图片名字)</code></p>
<h2 id="html-插入图片">3. html 插入图片</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片路径&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;说明&quot;</span> <span class="attr">width</span>=<span class="string">&quot;像素或者百分比&quot;</span> <span class="attr">height</span>=<span class="string">&quot;像素或者百分比&quot;</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>图例<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="数学公式以及编号问题">4. 数学公式以及编号问题</h2>
<p>渲染引擎：MathJax<br />
插件：hexo-renderer-pandoc<br />
参数（位于<code>_config.next.yml</code>）：<code>mathjax.tags = all</code></p>
<p>写行间公式的时候，两个 <code>$$</code>
一定要分别紧靠开头和结尾，并且中间不能有空行，否则在网页上会看见开头和结尾的两个
<code>$$</code> 符号（虽然公式可以正常渲染出来）。</p>
<p>在上述环境下，hexo 会自动给每个公式进行编号，当然也可以用
<code>\tag&#123;&#125;</code> 自己设置编号。如果使用 <code>\tag&#123;&#125;</code>
自定义编号，那么 hexo
依然会跳过这个公式并且对后面的公式进行自动编号。<br />
当公式不需要编号的时候，可以用 <code>\nonumber</code> 或
<code>\notag</code> 来标记；此外，也可以使用 带 <code>*</code> 的
<code>equation</code> 环境来取消对公式的编号。</p>
<p>对于公式引用，Next 官方文档中提到可以用 <code>\label&#123;&#125;</code>
和对应的 <code>\eqref&#123;&#125;</code> 来进行相应的公式引用。</p>
<p>参考：<br />
[1] <a
href="https://theme-next.js.org/docs/third-party-services/math-equations">Next
官方文档</a><br />
[2] <a
href="https://docs.mathjax.org/en/latest/input/tex/eqnumbers.html">MathJax
公式编号说明</a></p>
<h2 id="参考文献符号问题">5. 参考文献符号问题</h2>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**[1]**</span> 小明著.小明的书[M]</span><br></pre></td></tr></table></figure>
<p>这里的英文句号会被渲染为中文的圆圈句号,改用
<code>&lt;span&gt;.&lt;/span&gt;</code> 插入<code>html</code>即可</p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
