<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blackspace2.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":800},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"twikoo","storage":true,"lazyload":false,"nav":{"twikoo":{"order":-1}},"activeClass":"twikoo"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="OpenCV入门学习-核心功能（下）">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV入门学习-核心功能（下）">
<meta property="og:url" content="https://blackspace2.github.io/2025/01/27/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/index.html">
<meta property="og:site_name" content="Peace">
<meta property="og:description" content="OpenCV入门学习-核心功能（下）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blackspace2.github.io/2025/01/27/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/io_gamma.svg">
<meta property="article:published_time" content="2025-01-27T09:36:56.000Z">
<meta property="article:modified_time" content="2025-02-03T16:30:38.566Z">
<meta property="article:author" content="smile">
<meta property="article:tag" content="计算机视觉">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blackspace2.github.io/2025/01/27/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/io_gamma.svg">


<link rel="canonical" href="https://blackspace2.github.io/2025/01/27/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blackspace2.github.io/2025/01/27/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/","path":"2025/01/27/OpenCV入门学习-核心功能（下）/","title":"OpenCV入门学习-核心功能（下）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>OpenCV入门学习-核心功能（下） | Peace</title>
  







<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Peace" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  
  
   
  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Peace</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Sider mens eadem mutato</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-jottings"><a href="/jottings" rel="section"><i class="fa fa-sticky-note fa-fw"></i>杂记</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E7%9A%84%E5%AF%B9%E6%AF%94%E5%BA%A6%E5%92%8C%E4%BA%AE%E5%BA%A6"><span class="nav-text">1. 调整图像的对比度和亮度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">1.1. 理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">1.2. 代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">1.2.1. 核心代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="nav-text">1.2.2. 代码说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">1.3. 实际应用示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gamma-%E6%A0%A1%E6%AD%A3"><span class="nav-text">1.4. Gamma 校正</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-text">1.4.1. 实现代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8F%90%E7%A4%BA"><span class="nav-text">1.5. 性能优化提示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-text">2. 离散傅里叶变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-text">2.1. 什么是离散傅里叶变换？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#opencv%E5%AE%9E%E7%8E%B0dft%E7%9A%84%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="nav-text">2.2. OpenCV实现DFT的关键步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%9B%BE%E5%83%8F%E8%87%B3%E6%9C%80%E4%BD%B3%E5%B0%BA%E5%AF%B8"><span class="nav-text">2.2.1. 扩展图像至最佳尺寸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%95%B0%E7%9F%A9%E9%98%B5"><span class="nav-text">2.2.2. 创建复数矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8Cdft%E5%8F%98%E6%8D%A2"><span class="nav-text">2.2.3. 执行DFT变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B9%85%E5%BA%A6%E8%B0%B1"><span class="nav-text">2.2.4. 计算幅度谱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%91%E8%B0%B1%E4%B8%AD%E5%BF%83%E5%8C%96%E4%B8%8E%E5%BD%92%E4%B8%80%E5%8C%96"><span class="nav-text">2.2.5. 频谱中心化与归一化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.3. 应用场景示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.4. 完整代码示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#opencv%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">3. OpenCV文件输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80"><span class="nav-text">3.1. 文件操作基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8Eopencv%E7%BB%93%E6%9E%84%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-text">3.2.
基本数据类型与OpenCV结构的读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E4%B8%8E%E6%95%B0%E5%AD%97"><span class="nav-text">3.2.1. 文本与数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#opencv%E7%9F%A9%E9%98%B5cvmat"><span class="nav-text">3.2.2. OpenCV矩阵（cv::Mat）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E4%B8%8E%E6%98%A0%E5%B0%84%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-text">3.3. 序列与映射的读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E6%95%B0%E7%BB%84"><span class="nav-text">3.3.1. 序列（数组）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E5%AD%97%E5%85%B8"><span class="nav-text">3.3.2. 映射（字典）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">3.4. 自定义数据结构的序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="nav-text">3.5. 示例代码与输出结果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E5%86%99%E5%85%A5%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.5.1. 完整写入示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8Byaml"><span class="nav-text">3.5.2. 文件输出示例（YAML）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">3.6. 注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%8D%B7%E7%A7%AF%E8%BF%90%E7%AE%97"><span class="nav-text">4. 并行化卷积运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87"><span class="nav-text">4.1. 目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="nav-text">4.2. 前提条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B7%E7%A7%AF%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">4.3. 卷积理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%8D%B7%E7%A7%AF%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.4. 顺序卷积实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%8D%B7%E7%A7%AF%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.5. 并行卷积实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B9%B6%E8%A1%8C%E5%BE%AA%E7%8E%AF%E4%BD%93"><span class="nav-text">4.5.1. 自定义并行循环体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8Fc11"><span class="nav-text">4.5.2. 使用Lambda表达式（C++11）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="nav-text">4.6. 性能对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">4.7. 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%90%91%E9%87%8F%E5%8C%96"><span class="nav-text">5. 代码向量化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-1"><span class="nav-text">5.1. 目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#simd%E4%B8%8Euniversal-intrinsics%E5%9F%BA%E7%A1%80"><span class="nav-text">5.2. SIMD与Universal
Intrinsics基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#simd%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="nav-text">5.2.1. SIMD技术原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7"><span class="nav-text">5.2.2. 通用内联函数特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">5.2.3. 寄存器类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5"><span class="nav-text">5.3. 核心操作实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="nav-text">5.3.1. 数据加载与存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97"><span class="nav-text">5.3.2. 向量运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E7%BA%A6%E4%B8%8E%E6%8E%A9%E7%A0%81%E6%93%8D%E4%BD%9C"><span class="nav-text">5.3.3. 规约与掩码操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B7%E7%A7%AF%E7%AE%97%E6%B3%95%E5%90%91%E9%87%8F%E5%8C%96%E5%AE%9E%E6%88%98"><span class="nav-text">5.4. 卷积算法向量化实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E6%A0%87%E9%87%8F%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.4.1. 原始标量实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#simd%E5%90%91%E9%87%8F%E5%8C%96%E6%94%B9%E9%80%A0"><span class="nav-text">5.4.2. SIMD向量化改造</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF%E6%89%A9%E5%B1%95"><span class="nav-text">5.5. 二维卷积扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="nav-text">5.6. 性能对比与建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">6. 参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="smile"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">smile</p>
  <div class="site-description" itemprop="description">记录学习生活</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Blackspace2" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Blackspace2" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zezhong_xie@163.com" title="E-Mail → mailto:zezhong_xie@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    

    <link rel="stylesheet" href="/dist/APlayer.min.css">
    <div id="aplayer"></div>
    <script type="text/javascript" src="/dist/APlayer.min.js"></script>
    <script type="text/javascript" src="/dist/music.js"></script>

  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blackspace2.github.io/2025/01/27/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="smile">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peace">
      <meta itemprop="description" content="记录学习生活">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="OpenCV入门学习-核心功能（下） | Peace">
      <meta itemprop="description" content="OpenCV入门学习-核心功能（下）">
    </span>

      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OpenCV入门学习-核心功能（下）
        </h1>

        <div class="post-meta-container">

          <div class="post-meta">
    
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-27 17:36:56" itemprop="dateCreated datePublished" datetime="2025-01-27T17:36:56+08:00">2025-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-04 00:30:38" itemprop="dateModified" datetime="2025-02-04T00:30:38+08:00">2025-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
  
</div>

            <div class="post-description">OpenCV入门学习-核心功能（下）</div>
          
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span>
<a href="/2025/01/26/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8A%EF%BC%89/" title="OpenCV入门学习-核心功能（上）">OpenCV入门学习-核心功能（上）</a>
<h2 id="调整图像的对比度和亮度">1. 调整图像的对比度和亮度</h2>
<p>OpenCV是计算机视觉领域的重要工具，本节将介绍如何使用像素变换调整图像的亮度和对比度，并通过
Gamma 校正优化图像质量。</p>
<h3 id="理论基础">1.1. 理论基础</h3>
<p>图像处理中的<strong>像素变换</strong>指输出像素仅依赖输入像素值的操作。调整亮度与对比度的公式为：<br />
<span class="math display">\[\nonumber g(i,j) = \alpha \cdot f(i,j) +
\beta\]</span></p>
<ul>
<li><strong>α（增益）</strong>：控制对比度（建议范围：<span
class="math inline">\(1.0-3.0\)</span>）。<br />
</li>
<li><strong>β（偏置）</strong>：控制亮度（建议范围：<span
class="math inline">\(0-100\)</span>）。</li>
</ul>
<p>通过 <code>cv::saturate_cast&lt;uchar&gt;</code> 确保计算结果在 <span
class="math inline">\(0-255\)</span> 范围内，避免数值溢出。</p>
<h3 id="代码实现">1.2. 代码实现</h3>
<h4 id="核心代码示例">1.2.1. 核心代码示例</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;lena.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load image!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化输出图像</span></span><br><span class="line">    cv::Mat new_image = cv::Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> alpha = <span class="number">1.0</span>; <span class="comment">// 对比度参数</span></span><br><span class="line">    <span class="type">int</span> beta = <span class="number">0</span>;       <span class="comment">// 亮度参数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter alpha [1.0-3.0]: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; alpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter beta [0-100]: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; beta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每个像素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; image.rows; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; image.cols; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; image.<span class="built_in">channels</span>(); c++) &#123;</span><br><span class="line">                new_image.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(y, x)[c] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(</span><br><span class="line">                    alpha * image.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(y, x)[c] + beta</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Adjusted&quot;</span>, new_image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码说明">1.2.2. 代码说明</h4>
<ol type="1">
<li><p><strong>像素遍历</strong>：通过三重循环访问每个像素的BGR通道。<br />
</p></li>
<li><p><strong>数值饱和处理</strong>：<code>cv::saturate_cast&lt;uchar&gt;</code>确保结果在合理范围内。<br />
</p></li>
<li><p><strong>高效替代方案</strong>：可使用<code>cv::Mat::convertTo</code>替代循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.<span class="built_in">convertTo</span>(new_image, <span class="number">-1</span>, alpha, beta);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="实际应用示例">1.3. 实际应用示例</h3>
<p>调整 <code>α=2.2</code> 和 <code>β=50</code>
可显著提升暗图像的亮度，但可能导致高光区域过曝（如云层细节丢失）。此时可结合
<span class="math inline">\(\gamma\)</span> 校正优化。</p>
<h3 id="gamma-校正">1.4. Gamma 校正</h3>
<p>Gamma 校正通过非线性变换调整亮度：<br />
<span class="math display">\[\nonumber O = \left( \frac{I}{255}
\right)^\gamma \times 255\]</span></p>
<ul>
<li><strong>γ &lt; 1</strong>：提升暗部亮度。<br />
</li>
<li><strong>γ &gt; 1</strong>：增强亮部对比度。</li>
</ul>
<span id="fig1"></span>
<figure>
<img src="io_gamma.svg" alt="io_gamma" loading="lazy"/>
<figcaption>
图1.不同 <span class="math inline">\(\gamma\)</span> 值对应的图像
</figcaption>
</figure>
<h4 id="实现代码">1.4.1. 实现代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建查找表</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">lookupTable</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line">uchar* p = lookupTable.<span class="built_in">ptr</span>();</span><br><span class="line"><span class="type">double</span> gamma = <span class="number">0.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 四舍五入，饱和时截断</span></span><br><span class="line">    p[i] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(<span class="built_in">pow</span>(i / <span class="number">255.0</span>, gamma) * <span class="number">255.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 Gamma 校正</span></span><br><span class="line">cv::Mat corrected;</span><br><span class="line">cv::<span class="built_in">LUT</span>(image, lookupTable, corrected);</span><br></pre></td></tr></table></figure>
<h3 id="性能优化提示">1.5. 性能优化提示</h3>
<ul>
<li><strong>避免逐像素操作</strong>：优先使用内置函数（如<code>cv::convertTo</code>和<code>cv::LUT</code>）。<br />
</li>
<li><strong>预计算查找表</strong>：减少重复计算，提升 Gamma
校正效率。</li>
</ul>
<p>通过调整α、β和 <span class="math inline">\(\gamma\)</span>
值，可灵活控制图像效果。这些方法虽基础，但能为复杂图像处理任务奠定基础。</p>
<h2 id="离散傅里叶变换">2. 离散傅里叶变换</h2>
<h3 id="什么是离散傅里叶变换">2.1. 什么是离散傅里叶变换？</h3>
<p>离散傅里叶变换（DFT）是一种将图像从空间域转换到频率域的数学工具。通过分解图像的正弦和余弦分量，DFT可以帮助我们分析图像中的几何结构特征。其数学表达式为：<br />
<span class="math display">\[
F(k, l) = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1}
f(i,j)e^{-i2\pi\left(\frac{jk}{N}+\frac{ik}{N}\right)} \nonumber  
\]</span> 其中，复数结果可表示为：<br />
<span class="math display">\[  
e^{ix} = \cos x + i\sin x \nonumber  
\]</span></p>
<h3 id="opencv实现dft的关键步骤">2.2. OpenCV实现DFT的关键步骤</h3>
<h4 id="扩展图像至最佳尺寸">2.2.1. 扩展图像至最佳尺寸</h4>
<p>DFT的计算效率与图像尺寸相关，最佳尺寸通常是2、3、5的倍数。通过<code>cv::getOptimalDFTSize()</code>获取最优尺寸，并用<code>cv::copyMakeBorder()</code>填充图像边界：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat padded;  </span><br><span class="line"><span class="type">int</span> rows_pad = cv::<span class="built_in">getOptimalDFTSize</span>(I.rows);  </span><br><span class="line"><span class="type">int</span> cols_pad = cv::<span class="built_in">getOptimalDFTSize</span>(I.cols);  </span><br><span class="line">cv::<span class="built_in">copyMakeBorder</span>(I, padded, <span class="number">0</span>, rows_pad - I.rows, <span class="number">0</span>, cols_pad - I.cols,  </span><br><span class="line">                   cv::BORDER_CONSTANT, cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));  </span><br></pre></td></tr></table></figure>
<h4 id="创建复数矩阵">2.2.2. 创建复数矩阵</h4>
<p>DFT结果为复数，需将图像转换为浮点类型并合并实部与虚部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat planes[] = &#123;  </span><br><span class="line">    cv::<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(padded),  </span><br><span class="line">    cv::Mat::<span class="built_in">zeros</span>(padded.<span class="built_in">size</span>(), CV_32F)  </span><br><span class="line">&#125;;  </span><br><span class="line">cv::Mat complexI;  </span><br><span class="line">cv::<span class="built_in">merge</span>(planes, <span class="number">2</span>, complexI);  </span><br></pre></td></tr></table></figure>
<h4 id="执行dft变换">2.2.3. 执行DFT变换</h4>
<p>使用<code>cv::dft()</code>进行傅里叶变换，支持原地计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">dft</span>(complexI, complexI);  </span><br></pre></td></tr></table></figure>
<h4 id="计算幅度谱">2.2.4. 计算幅度谱</h4>
<p>将复数结果分解为实部和虚部，计算幅度并转为对数尺度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">split</span>(complexI, planes);  </span><br><span class="line">cv::<span class="built_in">magnitude</span>(planes[<span class="number">0</span>], planes[<span class="number">1</span>], planes[<span class="number">0</span>]);  </span><br><span class="line">cv::Mat magI = planes[<span class="number">0</span>];  </span><br><span class="line">magI += cv::Scalar::<span class="built_in">all</span>(<span class="number">1</span>);  </span><br><span class="line">cv::<span class="built_in">log</span>(magI, magI);  </span><br></pre></td></tr></table></figure>
<h4 id="频谱中心化与归一化">2.2.5. 频谱中心化与归一化</h4>
<p>交换频谱象限使低频分量居中，并进行归一化以便显示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">magI = <span class="built_in">magI</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, magI.cols &amp; <span class="number">-2</span>, magI.rows &amp; <span class="number">-2</span>));  </span><br><span class="line"><span class="type">int</span> cx = magI.cols / <span class="number">2</span>, cy = magI.rows / <span class="number">2</span>;  </span><br><span class="line"><span class="comment">// 交换四个象限  </span></span><br><span class="line"><span class="function">cv::Mat <span class="title">q0</span><span class="params">(magI, cv::Rect(<span class="number">0</span>, <span class="number">0</span>, cx, cy))</span></span>;  </span><br><span class="line"><span class="function">cv::Mat <span class="title">q1</span><span class="params">(magI, cv::Rect(cx, <span class="number">0</span>, cx, cy))</span></span>;  </span><br><span class="line"><span class="function">cv::Mat <span class="title">q2</span><span class="params">(magI, cv::Rect(<span class="number">0</span>, cy, cx, cy))</span></span>;  </span><br><span class="line"><span class="function">cv::Mat <span class="title">q3</span><span class="params">(magI, cv::Rect(cx, cy, cx, cy))</span></span>;  </span><br><span class="line">q<span class="number">0.</span><span class="built_in">copyTo</span>(tmp); q<span class="number">3.</span><span class="built_in">copyTo</span>(q0); tmp.<span class="built_in">copyTo</span>(q3);  </span><br><span class="line">q<span class="number">1.</span><span class="built_in">copyTo</span>(tmp); q<span class="number">2.</span><span class="built_in">copyTo</span>(q1); tmp.<span class="built_in">copyTo</span>(q2);  </span><br><span class="line"><span class="comment">// 归一化到[0,1]范围  </span></span><br><span class="line">cv::<span class="built_in">normalize</span>(magI, magI, <span class="number">0</span>, <span class="number">1</span>, cv::NORM_MINMAX);  </span><br></pre></td></tr></table></figure>
<h3 id="应用场景示例">2.3. 应用场景示例</h3>
<p>通过分析频谱的亮度分布，可以检测图像中的几何方向特征。例如：</p>
<ul>
<li><strong>水平文本</strong>：频谱中会出现垂直方向的高亮线，对应文本的横向排列。<br />
</li>
<li><strong>旋转文本</strong>：高亮点会随文本旋转方向偏移，通过此偏移可计算校正角度。</li>
</ul>
<h3 id="完整代码示例">2.4. 完整代码示例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取灰度图像</span></span><br><span class="line">    cv::Mat I = cv::<span class="built_in">imread</span>(<span class="string">&quot;dog.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (I.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Could not load image&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1：扩展图像至最佳DFT尺寸</span></span><br><span class="line">    cv::Mat padded;</span><br><span class="line">    <span class="type">int</span> rows_opt = cv::<span class="built_in">getOptimalDFTSize</span>(I.rows);</span><br><span class="line">    <span class="type">int</span> cols_opt = cv::<span class="built_in">getOptimalDFTSize</span>(I.cols);</span><br><span class="line">    cv::<span class="built_in">copyMakeBorder</span>(I, padded,</span><br><span class="line">        <span class="number">0</span>, rows_opt - I.rows,</span><br><span class="line">        <span class="number">0</span>, cols_opt - I.cols,</span><br><span class="line">        cv::BORDER_CONSTANT, cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：创建复数矩阵（实部+虚部）</span></span><br><span class="line">    cv::Mat planes[] = &#123;</span><br><span class="line">        cv::<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(padded),</span><br><span class="line">        cv::Mat::<span class="built_in">zeros</span>(padded.<span class="built_in">size</span>(), CV_32F)</span><br><span class="line">    &#125;;</span><br><span class="line">    cv::Mat complexI;</span><br><span class="line">    cv::<span class="built_in">merge</span>(planes, <span class="number">2</span>, complexI);  <span class="comment">// 合并为双通道矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：执行离散傅里叶变换</span></span><br><span class="line">    cv::<span class="built_in">dft</span>(complexI, complexI);  <span class="comment">// 原地计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤4：计算幅度谱</span></span><br><span class="line">    cv::<span class="built_in">split</span>(complexI, planes);  <span class="comment">// planes[0] = Re, planes[1] = Im</span></span><br><span class="line">    cv::<span class="built_in">magnitude</span>(planes[<span class="number">0</span>], planes[<span class="number">1</span>], planes[<span class="number">0</span>]);</span><br><span class="line">    cv::Mat magI = planes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤5：对数尺度转换</span></span><br><span class="line">    magI += cv::Scalar::<span class="built_in">all</span>(<span class="number">1</span>);</span><br><span class="line">    cv::<span class="built_in">log</span>(magI, magI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤6：裁剪为偶数尺寸</span></span><br><span class="line">    magI = <span class="built_in">magI</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, magI.cols &amp; <span class="number">-2</span>, magI.rows &amp; <span class="number">-2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤7：频谱中心化（交换象限）</span></span><br><span class="line">    <span class="type">int</span> cx = magI.cols / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> cy = magI.rows / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">q0</span><span class="params">(magI, cv::Rect(<span class="number">0</span>, <span class="number">0</span>, cx, cy))</span></span>;   <span class="comment">// 左上</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">q1</span><span class="params">(magI, cv::Rect(cx, <span class="number">0</span>, cx, cy))</span></span>;  <span class="comment">// 右上</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">q2</span><span class="params">(magI, cv::Rect(<span class="number">0</span>, cy, cx, cy))</span></span>;  <span class="comment">// 左下</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">q3</span><span class="params">(magI, cv::Rect(cx, cy, cx, cy))</span></span>; <span class="comment">// 右下</span></span><br><span class="line"></span><br><span class="line">    cv::Mat tmp;</span><br><span class="line">    <span class="comment">// 交换左上与右下</span></span><br><span class="line">    q<span class="number">0.</span><span class="built_in">copyTo</span>(tmp);</span><br><span class="line">    q<span class="number">3.</span><span class="built_in">copyTo</span>(q0);</span><br><span class="line">    tmp.<span class="built_in">copyTo</span>(q3);</span><br><span class="line">    <span class="comment">// 交换右上与左下</span></span><br><span class="line">    q<span class="number">1.</span><span class="built_in">copyTo</span>(tmp);</span><br><span class="line">    q<span class="number">2.</span><span class="built_in">copyTo</span>(q1);</span><br><span class="line">    tmp.<span class="built_in">copyTo</span>(q2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤8：归一化显示范围</span></span><br><span class="line">    cv::<span class="built_in">normalize</span>(magI, magI, <span class="number">0</span>, <span class="number">1</span>, cv::NORM_MINMAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Input Image&quot;</span>, I);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Spectrum Magnitude&quot;</span>, magI);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述步骤，OpenCV实现了从空间域到频率域的高效转换，为图像分析与增强提供了重要基础。</p>
<h2 id="opencv文件输入输出">3. OpenCV文件输入输出</h2>
<p>在OpenCV中，文件输入输出（IO）是实现数据持久化的重要功能。通过XML、YAML和JSON格式，开发者可以方便地存储和读取配置参数、矩阵数据甚至自定义数据结构。本文将详细介绍如何利用OpenCV的<code>cv::FileStorage</code>类实现这些操作。</p>
<h3 id="文件操作基础">3.1. 文件操作基础</h3>
<p>使用OpenCV进行文件IO需借助<code>cv::FileStorage</code>类。其核心步骤包括<strong>打开文件</strong>、<strong>读写数据</strong>和<strong>关闭文件</strong>。以下示例展示了文件的基本操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::FileStorage <span class="title">fs</span><span class="params">(<span class="string">&quot;output.yml&quot;</span>, cv::FileStorage::WRITE)</span></span>; <span class="comment">// 打开文件（写模式）</span></span><br><span class="line"><span class="comment">// 操作代码...</span></span><br><span class="line">fs.<span class="built_in">release</span>(); <span class="comment">// 显式关闭文件</span></span><br></pre></td></tr></table></figure>
<p>文件扩展名决定输出格式（如<code>.xml</code>、<code>.yml</code>、<code>.json</code>），还支持压缩（如<code>.xml.gz</code>）。读写模式包括<code>WRITE</code>、<code>READ</code>和<code>APPEND</code>。</p>
<h3 id="基本数据类型与opencv结构的读写">3.2.
基本数据类型与OpenCV结构的读写</h3>
<h4 id="文本与数字">3.2.1. 文本与数字</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入</span></span><br><span class="line">fs &lt;&lt; <span class="string">&quot;iterationNr&quot;</span> &lt;&lt; <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="type">int</span> itNr;</span><br><span class="line">fs[<span class="string">&quot;iterationNr&quot;</span>] &gt;&gt; itNr;</span><br></pre></td></tr></table></figure>
<h4 id="opencv矩阵cvmat">3.2.2. OpenCV矩阵（<code>cv::Mat</code>）</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat R = cv::Mat_&lt;uchar&gt;::<span class="built_in">eye</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">cv::Mat T = cv::Mat_&lt;<span class="type">double</span>&gt;::<span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">fs &lt;&lt; <span class="string">&quot;R&quot;</span> &lt;&lt; R &lt;&lt; <span class="string">&quot;T&quot;</span> &lt;&lt; T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">fs[<span class="string">&quot;R&quot;</span>] &gt;&gt; R;</span><br><span class="line">fs[<span class="string">&quot;T&quot;</span>] &gt;&gt; T;</span><br></pre></td></tr></table></figure>
<h3 id="序列与映射的读写">3.3. 序列与映射的读写</h3>
<h4 id="序列数组">3.3.1. 序列（数组）</h4>
<p>序列用<code>[ ]</code>包裹：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入字符串序列</span></span><br><span class="line">fs &lt;&lt; <span class="string">&quot;strings&quot;</span> &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;image1.jpg&quot;</span> &lt;&lt; <span class="string">&quot;Awesomeness&quot;</span> &lt;&lt; <span class="string">&quot;../data/baboon.jpg&quot;</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">cv::FileNode node = fs[<span class="string">&quot;strings&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (node.<span class="built_in">type</span>() == cv::FileNode::SEQ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (cv::FileNodeIterator it = node.<span class="built_in">begin</span>(); it != node.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::string value = (std::string)*it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="映射字典">3.3.2. 映射（字典）</h4>
<p>映射用<code>&#123; &#125;</code>包裹：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入键值对</span></span><br><span class="line">fs &lt;&lt; <span class="string">&quot;Mapping&quot;</span> &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;One&quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;Two&quot;</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">cv::FileNode mapping = fs[<span class="string">&quot;Mapping&quot;</span>];</span><br><span class="line"><span class="type">int</span> one = (<span class="type">int</span>)mapping[<span class="string">&quot;One&quot;</span>];</span><br><span class="line"><span class="type">int</span> two = (<span class="type">int</span>)mapping[<span class="string">&quot;Two&quot;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="自定义数据结构的序列化">3.4. 自定义数据结构的序列化</h3>
<p>要为自定义类实现序列化，需定义<code>write</code>和<code>read</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> A;</span><br><span class="line">    <span class="type">double</span> X;</span><br><span class="line">    std::string id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(cv::FileStorage&amp; fs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        fs &lt;&lt; <span class="string">&quot;&#123;&quot;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; A</span><br><span class="line">           &lt;&lt; <span class="string">&quot;X&quot;</span> &lt;&lt; X</span><br><span class="line">           &lt;&lt; <span class="string">&quot;id&quot;</span> &lt;&lt; id</span><br><span class="line">           &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">const</span> cv::FileNode&amp; node)</span> </span>&#123;</span><br><span class="line">        A = (<span class="type">int</span>)node[<span class="string">&quot;A&quot;</span>];</span><br><span class="line">        X = (<span class="type">double</span>)node[<span class="string">&quot;X&quot;</span>];</span><br><span class="line">        id = (std::string)node[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数（必须添加）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">(cv::FileStorage&amp; fs, <span class="type">const</span> std::string&amp;, <span class="type">const</span> MyData&amp; x)</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">write</span>(fs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">const</span> cv::FileNode&amp; node, MyData&amp; x, <span class="type">const</span> MyData&amp; default_value = MyData())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="built_in">empty</span>()) x = default_value;</span><br><span class="line">    <span class="keyword">else</span> x.<span class="built_in">read</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyData data;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;MyData&quot;</span> &lt;&lt; data;  <span class="comment">// 写入</span></span><br><span class="line">fs[<span class="string">&quot;MyData&quot;</span>] &gt;&gt; data;    <span class="comment">// 读取</span></span><br></pre></td></tr></table></figure>
<h3 id="示例代码与输出结果">3.5. 示例代码与输出结果</h3>
<h4 id="完整写入示例">3.5.1. 完整写入示例</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::FileStorage <span class="title">fs</span><span class="params">(<span class="string">&quot;output.yml&quot;</span>, cv::FileStorage::WRITE)</span></span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;iterationNr&quot;</span> &lt;&lt; <span class="number">100</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;R&quot;</span> &lt;&lt; cv::Mat::<span class="built_in">eye</span>(<span class="number">3</span>, <span class="number">3</span>, CV_8U);</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;MyData&quot;</span> &lt;&lt; <span class="built_in">MyData</span>(<span class="number">97</span>, CV_PI, <span class="string">&quot;mydata1234&quot;</span>);</span><br><span class="line">fs.<span class="built_in">release</span>();</span><br></pre></td></tr></table></figure>
<h4 id="文件输出示例yaml">3.5.2. 文件输出示例（YAML）</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">iterationNr:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">R:</span> <span class="type">!!opencv</span><span class="string">-matrix</span></span><br><span class="line">  <span class="attr">rows:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">cols:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">dt:</span> <span class="string">u</span></span><br><span class="line">  <span class="attr">data:</span> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="attr">MyData:</span></span><br><span class="line">  <span class="attr">A:</span> <span class="number">97</span></span><br><span class="line">  <span class="attr">X:</span> <span class="number">3.14159</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">mydata1234</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项">3.6. 注意事项</h3>
<ol type="1">
<li><p><strong>节点不存在时的处理</strong>：读取时若节点不存在，可返回默认值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyData defaultData;</span><br><span class="line">fs[<span class="string">&quot;NonExisting&quot;</span>] &gt;&gt; defaultData;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>文件格式兼容性</strong>：JSON文件需OpenCV
3.0及以上版本支持。</p></li>
<li><p><strong>压缩文件</strong>：使用<code>.gz</code>扩展名可自动压缩文件，如<code>output.xml.gz</code>。</p></li>
</ol>
<p>通过灵活运用OpenCV的序列化功能，开发者可以高效管理复杂数据结构，为计算机视觉项目提供可靠的数据存储方案。</p>
<h2 id="并行化卷积运算">4. 并行化卷积运算</h2>
<h3 id="目标">4.1. 目标</h3>
<p>演示如何利用OpenCV的<code>cv::parallel_for_</code>框架轻松实现代码并行化。以图像卷积运算为例，对比分析顺序执行与并行执行的性能差异。</p>
<h3 id="前提条件">4.2. 前提条件</h3>
<ol type="1">
<li><strong>并行框架支持</strong>
OpenCV需在编译时启用并行框架支持。OpenCV
4.5支持的并行框架按优先级排序如下：
<ul>
<li>Intel TBB（需显式启用）</li>
<li>OpenMP（需显式启用）</li>
<li>APPLE GCD（自动调用）</li>
<li>Windows并发库（自动调用）</li>
<li>Pthreads</li>
</ul></li>
<li><strong>竞态条件管理</strong>
卷积运算属于<strong>单线程写多线程读</strong>场景，不存在竞态条件。而多线程共同修改同一内存区域时（如特征检测），需采用同步机制。</li>
</ol>
<h3 id="卷积理论基础">4.3. 卷积理论基础</h3>
<p>卷积通过滑动内核矩阵计算像素加权和，公式表示为： <span
class="math display">\[
\text{output}(i, j) = \sum_{k=-\frac{n}{2}}^{\frac{n}{2}}
\sum_{l=-\frac{n}{2}}^{\frac{n}{2}} \text{kernel}(k, l) \cdot
\text{src}(i + k, j + l) \nonumber
\]</span> 其中，内核尺寸需为奇数以确保中心锚点存在。</p>
<h3 id="顺序卷积实现">4.4. 顺序卷积实现</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conv_seq</span><span class="params">(cv::Mat src, cv::Mat &amp;dst, cv::Mat kernel)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line">    dst = cv::<span class="built_in">Mat</span>(rows, cols, src.<span class="built_in">type</span>());</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> sz = kernel.rows / <span class="number">2</span>;</span><br><span class="line">    cv::<span class="built_in">copyMakeBorder</span>(src, src, sz, sz, sz, sz, cv::BORDER_REPLICATE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        uchar *dptr = dst.<span class="built_in">ptr</span>&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = -sz; k &lt;= sz; k++) &#123;</span><br><span class="line">                uchar *sptr = src.<span class="built_in">ptr</span>&lt;uchar&gt;(i + sz + k);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = -sz; l &lt;= sz; l++) &#123;</span><br><span class="line">                    value += kernel.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(k + sz, l + sz) * sptr[j + sz + l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dptr[j] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并行卷积实现">4.5. 并行卷积实现</h3>
<h4 id="自定义并行循环体">4.5.1. 自定义并行循环体</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParallelConvolution</span> : <span class="keyword">public</span> cv::ParallelLoopBody &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    cv::Mat m_src, &amp;m_dst;</span><br><span class="line">    cv::Mat m_kernel;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ParallelConvolution</span>(cv::Mat src, cv::Mat &amp;dst, cv::Mat kernel)</span><br><span class="line">        : <span class="built_in">m_src</span>(src), <span class="built_in">m_dst</span>(dst), <span class="built_in">m_kernel</span>(kernel) &#123;</span><br><span class="line">        sz = kernel.rows / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> cv::Range &amp;range)</span> <span class="type">const</span> CV_OVERRIDE </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = range.start; r &lt; range.end; r++) &#123;</span><br><span class="line">            <span class="type">int</span> i = r / m_src.cols, j = r % m_src.cols;</span><br><span class="line">            <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = -sz; k &lt;= sz; k++) &#123;</span><br><span class="line">                uchar *sptr = m_src.<span class="built_in">ptr</span>&lt;uchar&gt;(i + sz + k);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = -sz; l &lt;= sz; l++) &#123;</span><br><span class="line">                    value += m_kernel.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(k + sz, l + sz) * sptr[j + sz + l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m_dst.<span class="built_in">ptr</span>&lt;uchar&gt;(i)[j] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="function">ParallelConvolution <span class="title">obj</span><span class="params">(src, dst, kernel)</span></span>;</span><br><span class="line">cv::<span class="built_in">parallel_for_</span>(cv::<span class="built_in">Range</span>(<span class="number">0</span>, rows * cols), obj);</span><br></pre></td></tr></table></figure>
<h4 id="使用lambda表达式c11">4.5.2. 使用Lambda表达式（C++11）</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">parallel_for_</span>(cv::<span class="built_in">Range</span>(<span class="number">0</span>, rows * cols), [&amp;](<span class="type">const</span> cv::Range &amp;range) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = range.start; r &lt; range.end; r++) &#123;</span><br><span class="line">        <span class="type">int</span> i = r / cols, j = r % cols;</span><br><span class="line">        <span class="type">double</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = -sz; k &lt;= sz; k++) &#123;</span><br><span class="line">            uchar *sptr = src.<span class="built_in">ptr</span>&lt;uchar&gt;(i + sz + k);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l = -sz; l &lt;= sz; l++) &#123;</span><br><span class="line">                value += kernel.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(k + sz, l + sz) * sptr[j + sz + l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dst.<span class="built_in">ptr</span>&lt;uchar&gt;(i)[j] = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="性能对比">4.6. 性能对比</h3>
<p>对512×512图像使用不同内核尺寸测试得到以下结果：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">实现方式</th>
<th style="text-align: center;">5×5内核时间 (s)</th>
<th style="text-align: center;">3×3内核时间 (s)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">顺序执行</td>
<td style="text-align: center;">0.0954</td>
<td style="text-align: center;">0.0301</td>
</tr>
<tr class="even">
<td style="text-align: center;">全图分块并行</td>
<td style="text-align: center;">0.0247</td>
<td style="text-align: center;">0.0117</td>
</tr>
<tr class="odd">
<td style="text-align: center;">按行分块并行</td>
<td style="text-align: center;">0.0249</td>
<td style="text-align: center;">0.0118</td>
</tr>
</tbody>
</table>
<p>并行实现通常可获得<strong>4-7倍加速比</strong>，实际性能取决于CPU核心数与任务调度策略。</p>
<h3 id="总结">4.7. 总结</h3>
<ol type="1">
<li>OpenCV <code>cv::parallel_for_</code>
自动划分计算任务，极大简化并行代码开发。</li>
<li>通过继承<code>cv::ParallelLoopBody</code>或使用Lambda表达式，均可实现高效并行。</li>
<li>线程数可通过<code>cv::setNumThreads()</code>调整，任务划分粒度由<code>nstripes</code>参数控制。</li>
</ol>
<p>通过合理使用并行框架，可显著提升图像处理算法的运行时效率。</p>
<h2 id="代码向量化">5. 代码向量化</h2>
<h3 id="目标-1">5.1. 目标</h3>
<p>本教程介绍如何利用OpenCV的<strong>Universal
Intrinsics</strong>特性对C++代码进行向量化优化，利用现代处理器的SIMD指令实现运行时加速。内容涵盖SIMD基础概念、寄存器操作及实际卷积算法向量化实现。</p>
<h3 id="simd与universal-intrinsics基础">5.2. SIMD与Universal
Intrinsics基础</h3>
<h4 id="simd技术原理">5.2.1. SIMD技术原理</h4>
<p>SIMD（单指令多数据）允许处理器使用宽寄存器同时对多个数据元素执行相同操作。例如：</p>
<ul>
<li>128位寄存器可同时处理4个32位浮点数</li>
<li>256位寄存器可处理8个32位整数</li>
</ul>
<h4 id="通用内联函数特性">5.2.2. 通用内联函数特性</h4>
<p>OpenCV Universal Intrinsics提供跨平台SIMD抽象层，支持多种指令集：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持SSE/AVX/NEON等指令集</span></span><br><span class="line">cv::v_uint8  <span class="comment">// 8位无符号整数寄存器</span></span><br><span class="line">cv::v_float32 <span class="comment">// 32位浮点数寄存器</span></span><br></pre></td></tr></table></figure>
<h4 id="寄存器类型">5.2.3. 寄存器类型</h4>
<ol type="1">
<li><p><strong>变长寄存器</strong>：自动适配硬件最大位宽</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::v_float32 reg;</span><br><span class="line"><span class="type">int</span> n = reg.nlanes; <span class="comment">// 根据硬件返回可容纳元素数量</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>定长寄存器</strong>：明确指定位宽</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::v_float32x4 reg; <span class="comment">// 明确使用128位寄存器（4元素）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="核心操作实践">5.3. 核心操作实践</h3>
<h4 id="数据加载与存储">5.3.1. 数据加载与存储</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载未对齐数据</span></span><br><span class="line"><span class="type">float</span> src[<span class="number">8</span>];</span><br><span class="line">cv::v_float32x4 reg = cv::<span class="built_in">v_load</span>(src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储到对齐内存</span></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">float</span> dst[<span class="number">4</span>];</span><br><span class="line">cv::<span class="built_in">v_store</span>(dst, reg);</span><br></pre></td></tr></table></figure>
<h4 id="向量运算">5.3.2. 向量运算</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cv::v_float32 a = cv::<span class="built_in">v_load</span>(ptr_a);</span><br><span class="line">cv::v_float32 b = cv::<span class="built_in">v_load</span>(ptr_b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量加减乘除</span></span><br><span class="line">cv::v_float32 sum = a + b;</span><br><span class="line">cv::v_float32 prod = a * b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较运算生成掩码</span></span><br><span class="line">cv::v_float32 cmp_mask = (a &gt; b);</span><br></pre></td></tr></table></figure>
<h4 id="规约与掩码操作">5.3.3. 规约与掩码操作</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求最大值</span></span><br><span class="line"><span class="type">float</span> max_val = cv::<span class="built_in">v_reduce_max</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件选择</span></span><br><span class="line">cv::v_float32 result = cv::<span class="built_in">v_select</span>(cmp_mask, a, b);</span><br></pre></td></tr></table></figure>
<h3 id="卷积算法向量化实战">5.4. 卷积算法向量化实战</h3>
<h4 id="原始标量实现">5.4.1. 原始标量实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scalar_conv1d</span><span class="params">(cv::Mat src, cv::Mat &amp;dst, cv::Mat kernel)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sz = kernel.cols/<span class="number">2</span>;</span><br><span class="line">    cv::<span class="built_in">copyMakeBorder</span>(src, src, <span class="number">0</span>, <span class="number">0</span>, sz, sz, cv::BORDER_REPLICATE);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.cols; ++i)&#123;</span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=-sz; k&lt;=sz; ++k)&#123;</span><br><span class="line">            sum += src.<span class="built_in">at</span>&lt;uchar&gt;(i+k+sz) * kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(k+sz);</span><br><span class="line">        &#125;</span><br><span class="line">        dst.<span class="built_in">at</span>&lt;uchar&gt;(i) = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="simd向量化改造">5.4.2. SIMD向量化改造</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vectorized_conv1d</span><span class="params">(cv::Mat src, cv::Mat kernel, <span class="type">float</span>* ans)</span> </span>&#123;</span><br><span class="line">    cv::Mat src_32;</span><br><span class="line">    src.<span class="built_in">convertTo</span>(src_32, CV_32F);</span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> step = cv::v_float32x4::nlanes;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;kernel.cols; ++k)&#123;</span><br><span class="line">        cv::v_float32x4 kernel_wide = cv::<span class="built_in">v_setall_f32</span>(kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(k));</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 主向量处理循环</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i+step &lt; src.cols; i+=step)&#123;</span><br><span class="line">            cv::v_float32x4 window = cv::<span class="built_in">v_load</span>(&amp;src_<span class="number">32.</span><span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i+k));</span><br><span class="line">            cv::v_float32x4 sum = cv::<span class="built_in">v_load</span>(ans+i) + window * kernel_wide;</span><br><span class="line">            cv::<span class="built_in">v_store</span>(ans+i, sum);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 尾部数据处理</span></span><br><span class="line">        <span class="keyword">for</span>(; i&lt;src.cols; ++i)&#123;</span><br><span class="line">            ans[i] += src_<span class="number">32.</span><span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i+k) * kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维卷积扩展">5.5. 二维卷积扩展</h3>
<p>通过水平+垂直方向的一维卷积组合实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">convolute_2d</span><span class="params">(cv::Mat src, cv::Mat &amp;dst, cv::Mat kernel)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ksize = kernel.rows/<span class="number">2</span>;</span><br><span class="line">    cv::<span class="built_in">copyMakeBorder</span>(src, src, ksize, ksize, <span class="number">0</span>, <span class="number">0</span>, cv::BORDER_REPLICATE);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; src.rows; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;kernel.rows; ++k)&#123;</span><br><span class="line">            <span class="type">float</span> tmp[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">vectorized_conv1d</span>(src.<span class="built_in">row</span>(i+k), kernel.<span class="built_in">row</span>(k), tmp);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 累加多行结果</span></span><br><span class="line">            <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j<span class="number">+4</span>&lt;src.cols; j+=<span class="number">4</span>)&#123;</span><br><span class="line">                cv::v_float32x4 sum = cv::<span class="built_in">v_load</span>(&amp;dst.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,j)) </span><br><span class="line">                                    + cv::<span class="built_in">v_load</span>(&amp;tmp[j]);</span><br><span class="line">                cv::<span class="built_in">v_store</span>(&amp;dst.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,j), sum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; j&lt;src.cols; ++j)&#123;</span><br><span class="line">                dst.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,j) += tmp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能对比与建议">5.6. 性能对比与建议</h3>
<ul>
<li>测试显示向量化版本相比标量实现可获得2-5倍加速</li>
<li>实际性能取决于：
<ul>
<li>CPU支持的SIMD指令集（SSE4/AVX2/AVX512）</li>
<li>数据对齐情况</li>
<li>算法内存访问模式</li>
</ul></li>
</ul>
<p><strong>优化建议</strong>：</p>
<ol type="1">
<li>优先处理连续内存块</li>
<li>尽量使用<code>vx_load_aligned</code>访问对齐数据</li>
<li>利用<code>v_reduce</code>系列函数代替标量累计</li>
<li>通过<code>v_select</code>实现条件分支消除</li>
</ol>
<p>通过合理使用Universal
Intrinsics，开发者可以在不损失代码可移植性的前提下，充分利用现代处理器的并行计算能力。建议结合性能分析工具，针对热点代码进行定向优化。</p>
<h2 id="参考资料">6. 参考资料</h2>
<p><strong>[1]</strong> <a
target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/de/d7a/tutorial_table_of_content_core.html">OpenCV官方文档</a></p>

    </div>

    
    
    
    <div>
         <div>
    
    <div style="text-align:center;color: #ccc;font-size:14px;">
        -------------本文结束 <i class="fa fa-paw"></i> 感谢您的阅读-------------
    </div>
    
</div> 
    </div>


    <footer class="post-footer">
          <div class="reward-container">
  
  
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="smile 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="smile 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>smile
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blackspace2.github.io/2025/01/27/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/" title="OpenCV入门学习-核心功能（下）">https://blackspace2.github.io/2025/01/27/OpenCV入门学习-核心功能（下）/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://github.com/Blackspace2">
            <span class="icon">
              <i class="fab fa-github"></i>
            </span>

            <span class="label">GitHub</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" rel="tag"><i class="fa fa-tag"></i> 计算机视觉</a>
              <a href="/tags/C-C/" rel="tag"><i class="fa fa-tag"></i> C/C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/02/02/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="prev" title="OpenCV入门学习-图像处理（上）">
                  <i class="fa fa-angle-left"></i> OpenCV入门学习-图像处理（上）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/01/26/OpenCV%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="next" title="OpenCV入门学习-核心功能（上）">
                  OpenCV入门学习-核心功能（上） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments"><div id="twikoo-comments"></div></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">smile</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">25k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:24</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        本站总访客量<span id="busuanzi_value_site_uv"></span>次
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        本站总访问量<span id="busuanzi_value_site_pv"></span>人次
      </span>
    </span>
</div>



<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("01/05/2025 16:48:27");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>


<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>



  <script src="/js/third-party/fancybox.js"></script>



  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="twikoo" type="application/json">{"enable":true,"visitor":false,"envId":"https://twikoo-eta-smoky-88.vercel.app","el":"#twikoo-comments"}</script>


<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>


<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.twikoo.el)
    .then(() => NexT.utils.getScript(
      CONFIG.twikoo.jsUrl || 'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',
      { condition: window.twikoo }
    ))
    .then(() => {
      twikoo.init(CONFIG.twikoo);
    });
});
</script>
<style>
.post-block, .comments {
  overflow: visible;
}
.tk-owo-emotion {
  display: inline-block;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
  
</body>
</html>
